{
  "description": "CRITICAL: Never swallow exceptions silently. Empty catch blocks hide failures and make debugging impossible. Always log, handle, or rethrow exceptions with context.",
  "examples": [
    {
      "do": {
        "description": "Always handle exceptions properly - log, rethrow, or take corrective action",
        "content": [
          "Always handle exceptions - never ignore them",
          "Log exceptions with full context before recovering",
          "Rethrow exceptions if you can't handle them properly",
          "Wrap and rethrow with additional context",
          "Take corrective action if you can recover",
          "",
          "Correct Examples (proper exception handling):",
          "- try { risky_operation() } except Exception as e: logger.error(f'Operation failed: {e}', exc_info=True); raise",
          "- try { process() } catch (e) { console.error('Process failed:', e); throw e; }",
          "- try { save() } catch (e) { logger.error('Save failed:', e); return fallback_value; }",
          "- try { connect() } catch (ConnectionError as e) { logger.warning('Retry attempt', e); retry(); }",
          "",
          "Exception Handling Best Practices:",
          "- ALWAYS log the exception with full stack trace",
          "- Include context: what operation failed, relevant IDs/data",
          "- Rethrow if you can't handle it properly",
          "- Use finally blocks for cleanup (close files, connections)",
          "- Document why you're catching and what recovery is",
          "- Preserve original exception when wrapping",
          "",
          "When to catch and handle:",
          "- You can take meaningful corrective action",
          "- You need to clean up resources (use finally)",
          "- You need to add context and rethrow",
          "- You're at a boundary (API, UI) and need to translate",
          "",
          "When to let it propagate:",
          "- You can't do anything useful with it",
          "- You don't know how to handle it",
          "- It should cause the operation to fail"
        ]
      },
      "dont": {
        "description": "NEVER swallow exceptions with empty catch blocks",
        "content": [
          "NEVER use empty catch/except blocks",
          "NEVER catch and ignore without logging",
          "NEVER catch Exception without specific reason",
          "NEVER suppress errors to 'make it work'",
          "",
          "Wrong Examples (swallowing exceptions):",
          "- try { risky_operation() } catch (e) { } // WRONG: Silent failure",
          "- try { process() } except: pass // WRONG: Hiding errors",
          "- try { save() } catch { return; } // WRONG: Ignoring failure",
          "- try { connect() } catch (Exception e) { /* TODO: handle */ } // WRONG: Empty handler",
          "- try { load() } except Exception: continue // WRONG: Silently skipping errors",
          "",
          "Swallowed Exception Indicators (CRITICAL FIX REQUIRED):",
          "- Empty catch/except blocks: catch (e) { }",
          "- Pass without logging: except: pass",
          "- Comment without action: catch (e) { /* ignore */ }",
          "- Generic catch-all without logging: except Exception:",
          "- Return/continue without handling: catch { return; }",
          "",
          "Why This Is Critical:",
          "- Hides bugs and makes debugging impossible",
          "- Creates silent failures users don't know about",
          "- Data corruption when errors are ignored",
          "- System state becomes inconsistent",
          "- Production issues with no error logs",
          "- Violates fail-fast principle",
          "",
          "Instead:",
          "- Log the exception with full context",
          "- Rethrow if you can't handle it: raise or throw e",
          "- Take corrective action if recovery is possible",
          "- Use finally for cleanup, not catch for ignoring",
          "- Document WHY you're catching and what you're doing",
          "- If you must catch-all, log and rethrow",
          "",
          "Only acceptable pattern for 'ignore':",
          "- try { optional_feature() } catch (e) { logger.info('Optional feature unavailable', e); // explicitly documented as optional }",
          "- Even then: ALWAYS log why you're ignoring it"
        ]
      }
    }
  ],
  "scanner": "agile_bot.bots.base_bot.src.scanners.swallowed_exceptions_scanner.SwallowedExceptionsScanner"
}
