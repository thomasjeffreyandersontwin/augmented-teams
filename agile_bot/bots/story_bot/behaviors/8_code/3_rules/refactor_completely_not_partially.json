{
  "description": "CRITICAL: When refactoring, replace old code completely - don't try to support both legacy and new patterns. Write new code, delete old code, fix tests. Clean breaks are better than compatibility bridges that create technical debt.",
  "examples": [
    {
      "do": {
        "description": "Replace old pattern completely with new pattern",
        "content": [
          "When refactoring, commit fully to the new approach",
          "Delete old code completely, don't leave it around",
          "Update all call sites to use new pattern",
          "Fix all tests to work with new code",
          "Clean break is better than supporting both ways",
          "",
          "Correct Refactoring Process:",
          "1. Write new code with better pattern",
          "2. Update all call sites to use new code",
          "3. Delete old code completely",
          "4. Update tests to match new implementation",
          "5. Verify all tests pass",
          "",
          "Example: Refactoring to template method",
          "STEP 1: Add template method execute_action()",
          "STEP 2: Update ALL action methods to use template",
          "STEP 3: Delete old duplicated code from each method",
          "STEP 4: Update tests if needed",
          "STEP 5: Verify all tests pass",
          "",
          "Benefits:",
          "- Clean codebase with one clear pattern",
          "- No confusion about which approach to use",
          "- No technical debt from compatibility code",
          "- Tests verify new pattern works",
          "- Easy to understand for future developers"
        ]
      },
      "dont": {
        "description": "Don't try to support both old and new patterns simultaneously",
        "content": [
          "Don't create compatibility layers for old code",
          "Don't support both old and new ways of doing things",
          "Don't leave old code around 'just in case'",
          "Don't add conditional logic to support legacy patterns",
          "Don't incrementally migrate - do complete refactor",
          "",
          "Wrong Refactoring (supporting both):",
          "```python",
          "def execute_action(action_name, action_class=None, action_logic_fn=None):  # WRONG",
          "    # Support both old way (logic function) and new way (action class)",
          "    if action_logic_fn:  # Old way",
          "        data = action_logic_fn(params)",
          "    elif action_class:  # New way",
          "        action = action_class(...)",
          "        data = action.execute(params)",
          "    # Now we have to maintain both paths!",
          "```",
          "",
          "Wrong Refactoring (leaving old code):",
          "```python",
          "# Old way (deprecated, use execute_action instead)",
          "def gather_context_old(self, params):",
          "    # ... 20 lines of old code ...",
          "",
          "# New way",
          "def gather_context(self, params):",
          "    return self.execute_action('gather_context', GatherContextAction, params)",
          "```",
          "",
          "Wrong Refactoring (partial migration):",
          "```python",
          "# Some actions use template",
          "def gather_context(self, params):",
          "    return self.execute_action('gather_context', GatherContextAction, params)",
          "",
          "# Some actions still use old pattern (inconsistent!)",
          "def build_knowledge(self, params):",
          "    if self.workflow.current_state != 'build_knowledge':",
          "        self.workflow.machine.set_state('build_knowledge')",
          "    self.workflow.save_state()",
          "    # ... old duplicated code ...",
          "```",
          "",
          "Problems with Supporting Both:",
          "- Technical debt accumulates",
          "- Two ways to do the same thing (confusion)",
          "- More code to maintain and test",
          "- Harder to reason about system behavior",
          "- Future developers don't know which pattern to follow",
          "- Tests may pass but codebase is messy",
          "- Refactoring never completes",
          "",
          "Instead:",
          "- Commit to new pattern completely",
          "- Update all code at once",
          "- Delete old code entirely",
          "- Fix all tests to match new pattern",
          "- Have one clear way to do things",
          "",
          "When to Use Compatibility Layer (RARE):",
          "- External API with many consumers you don't control",
          "- Deprecation period required by contract",
          "- Major version transition with migration period",
          "",
          "For Internal Code (99% of cases):",
          "- NO compatibility layer",
          "- Clean break refactor",
          "- Update all call sites",
          "- Delete old code",
          "- One clear pattern"
        ]
      }
    }
  ],
  "scanner": "agile_bot.bots.base_bot.src.scanners.complete_refactoring_scanner.CompleteRefactoringScanner"
}
