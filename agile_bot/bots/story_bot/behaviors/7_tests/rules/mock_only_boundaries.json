{
  "description": "Mock ONLY at architectural boundaries: external APIs, network calls, uncontrollable services. DON'T mock internal business logic, classes under test, or file operations (use temp files). Mocking internal code defeats the purpose of tests. From BDD Rule 8.2 (Proper Mocking).",
  "examples": [
    {
      "do": {
        "description": "Mock only external dependencies",
        "content": [
          "# ✅ DO: Mock external API (can't control)",
          "def test_agent_fetches_remote_configuration(self):",
          "    \"\"\"Agent fetches configuration from remote API.\"\"\"",
          "    # Given: Mock EXTERNAL HTTP request",
          "    with patch('requests.get') as mock_get:",
          "        mock_get.return_value.json.return_value = {",
          "            'name': 'story_bot',",
          "            'version': '1.0'",
          "        }",
          "        ",
          "        # When: Agent fetches from remote API",
          "        agent = Agent.from_remote_config('http://api.example.com/config')",
          "        ",
          "        # Then: Config loaded from API",
          "        assert agent.name == 'story_bot'",
          "        mock_get.assert_called_once_with('http://api.example.com/config')",
          "",
          "# ✅ DO: Mock external monitoring service",
          "def test_agent_sends_metrics_on_initialization(self):",
          "    \"\"\"Agent sends metrics to monitoring service.\"\"\"",
          "    # Given: Mock EXTERNAL metrics service",
          "    with patch('monitoring.send_metric') as mock_send:",
          "        agent = Agent('bot', Path('/tmp'))",
          "        ",
          "        # When: Agent initializes (sends metrics)",
          "        agent.initialize()",
          "        ",
          "        # Then: Metrics sent to external service",
          "        mock_send.assert_called_with('agent_initialized', {'name': 'bot'})",
          "",
          "# ✅ DO: Use real temp files instead of mocking file I/O",
          "def test_agent_loads_config_from_file(self, tmp_path):",
          "    \"\"\"Agent loads configuration from file.\"\"\"",
          "    # Given: REAL file in temp directory",
          "    config_file = tmp_path / 'config.json'",
          "    config_file.write_text('{\"name\": \"story_bot\"}')",
          "    ",
          "    # When: Agent loads from REAL file",
          "    agent = Agent()",
          "    config = agent.load_config(config_file)",
          "    ",
          "    # Then: Config loaded (real file I/O, no mocking!)",
          "    assert config['name'] == 'story_bot'"
        ]
      },
      "dont": {
        "description": "Mock internal business logic or file operations",
        "content": [
          "# DON'T: Mock the class under test",
          "def test_agent_initializes(self):",
          "    # WRONG: Mocking the class we're testing!",
          "    agent = Mock(spec=Agent)",
          "    agent.initialize.return_value = True",
          "    ",
          "    result = agent.initialize()",
          "    # This test is USELESS - we're testing the mock!",
          "",
          "# DON'T: Mock internal business logic",
          "def test_agent_validates_configuration(self):",
          "    # WRONG: Mocking internal validation method",
          "    with patch.object(Agent, 'validate_config') as mock_validate:",
          "        mock_validate.return_value = True",
          "        ",
          "        agent = Agent('bot', Path('/tmp'))",
          "        agent.initialize()",
          "        ",
          "        # This defeats the purpose - we WANT to test validation!",
          "        mock_validate.assert_called_once()",
          "",
          "# DON'T: Mock file operations (use real temp files)",
          "def test_agent_loads_config(self):",
          "    # WRONG: Mocking file I/O instead of using temp files",
          "    with patch('pathlib.Path.exists', return_value=True):",
          "        with patch('pathlib.Path.read_text') as mock_read:",
          "            mock_read.return_value = '{\"name\": \"bot\"}'",
          "            ",
          "            agent = Agent()",
          "            config = agent.load_config(Path('config.json'))",
          "            ",
          "            # WRONG: Use real temp files with tmp_path fixture!",
          "",
          "# DON'T: Mock json.loads (just use it!)",
          "def test_parses_json_config(self):",
          "    # WRONG: Mocking standard library that works fine",
          "    with patch('json.loads') as mock_json:",
          "        mock_json.return_value = {'name': 'bot'}",
          "        # Just use real json.loads! It's fast and reliable!",
          "",
          "# DON'T: Mock helper functions you own",
          "def test_creates_workspace(self):",
          "    # WRONG: Mocking your own helper",
          "    with patch('test_helpers.create_config_file'):",
          "        # Just call the real helper function!"
        ]
      }
    },
    {
      "do": {
        "description": "When to mock: external services only",
        "content": [
          "# Mock these EXTERNAL dependencies:",
          "",
          "# 1. Network/HTTP requests",
          "with patch('requests.get'): ...",
          "with patch('urllib.request.urlopen'): ...",
          "",
          "# 2. External APIs you don't control",
          "with patch('stripe.Customer.create'): ...",
          "with patch('boto3.client'): ...",
          "",
          "# 3. External services (email, SMS, monitoring)",
          "with patch('sendgrid.SendGridAPIClient.send'): ...",
          "with patch('twilio.rest.Client.messages.create'): ...",
          "with patch('monitoring.send_metric'): ...",
          "",
          "# 4. Time/date when you need deterministic values",
          "with patch('datetime.datetime.now') as mock_now:",
          "    mock_now.return_value = datetime(2025, 1, 1)",
          "",
          "# 5. Random values when you need deterministic tests",
          "with patch('random.randint') as mock_random:",
          "    mock_random.return_value = 42"
        ]
      },
      "dont": {
        "description": "Don't mock these - use real implementations",
        "content": [
          "# DON'T mock these - use REAL implementations:",
          "",
          "# 1. File I/O - use tmp_path fixture",
          "# ❌ DON'T: with patch('pathlib.Path.read_text')",
          "# ✅ DO: Use tmp_path fixture and real files",
          "",
          "# 2. Standard library functions (json, os, pathlib)",
          "# ❌ DON'T: with patch('json.loads')",
          "# ✅ DO: Use real json.loads - it's fast!",
          "",
          "# 3. Your own classes and business logic",
          "# ❌ DON'T: with patch.object(Agent, 'validate')",
          "# ✅ DO: Test real validation logic",
          "",
          "# 4. Database operations - use test database",
          "# ❌ DON'T: with patch('database.query')",
          "# ✅ DO: Use in-memory SQLite or test database",
          "",
          "# 5. Helper functions you wrote",
          "# ❌ DON'T: with patch('helpers.create_agent')",
          "# ✅ DO: Call real helper function",
          "",
          "# 6. Configuration objects",
          "# ❌ DON'T: Mock(spec=Config)",
          "# ✅ DO: Create real Config with test data"
        ]
      }
    },
    {
      "do": {
        "description": "Extract mock setup to helpers when repeated",
        "content": [
          "# Helper for common mock setup",
          "@pytest.fixture",
          "def mock_remote_api():",
          "    \"\"\"Fixture: Mock remote API responses.\"\"\"",
          "    with patch('requests.get') as mock_get:",
          "        mock_get.return_value.json.return_value = {",
          "            'name': 'story_bot',",
          "            'version': '1.0'",
          "        }",
          "        yield mock_get",
          "",
          "# Tests use fixture",
          "def test_fetches_remote_config(self, mock_remote_api):",
          "    agent = Agent.from_remote_config('http://api.com/config')",
          "    assert agent.name == 'story_bot'",
          "    mock_remote_api.assert_called_once()",
          "",
          "def test_retries_on_failure(self, mock_remote_api):",
          "    mock_remote_api.side_effect = [",
          "        ConnectionError(),",
          "        Mock(json=lambda: {'name': 'bot'})",
          "    ]",
          "    agent = Agent.from_remote_config('http://api.com/config')",
          "    assert mock_remote_api.call_count == 2"
        ]
      },
      "dont": {
        "description": "Duplicate mock setup across tests",
        "content": [
          "# DON'T: Duplicate mock setup",
          "def test_fetches_config(self):",
          "    with patch('requests.get') as mock_get:",
          "        mock_get.return_value.json.return_value = {'name': 'bot'}",
          "        agent = Agent.from_remote_config('http://api.com/config')",
          "        assert agent.name == 'bot'",
          "",
          "def test_retries_on_failure(self):",
          "    # WRONG: Duplicating same mock setup",
          "    with patch('requests.get') as mock_get:",
          "        mock_get.return_value.json.return_value = {'name': 'bot'}",
          "        # Use fixture instead!"
        ]
      }
    }
  ]
}


