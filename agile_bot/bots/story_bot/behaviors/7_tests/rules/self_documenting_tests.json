{
  "description": "Tests are self-documenting through code structure. Do NOT add verbose comments explaining that tests will fail or what API is needed. The imports, constructor calls, method calls, and assertions clearly show the expected API design. Let the code speak for itself.",
  "examples": [
    {
      "do": {
        "description": "Self-documenting test through code structure",
        "content": [
          "def test_generator_creates_server_for_test_bot(self, workspace_root):",
          "    \"\"\"",
          "    SCENARIO: Generator creates MCP server for test_bot",
          "    GIVEN: Bot config exists with behaviors configured",
          "    WHEN: Generator receives Bot Config",
          "    THEN: Generator creates MCP Server instance with unique server name",
          "    \"\"\"",
          "    # Given: Bot config and base templates exist",
          "    bot_name = 'test_bot'",
          "    behaviors = ['shape', 'discovery', 'exploration', 'specification']",
          "    config_file = create_bot_config(workspace_root, bot_name, behaviors)",
          "    create_base_server_template(workspace_root)",
          "    create_base_bot_class(workspace_root)",
          "    ",
          "    # When: Call REAL MCPServerGenerator API",
          "    from agile_bot.bots.base_bot.src.mcp_server_generator import MCPServerGenerator",
          "    generator = MCPServerGenerator(",
          "        bot_name=bot_name,",
          "        config_path=config_file,",
          "        workspace_root=workspace_root",
          "    )",
          "    server_file = generator.generate_server()",
          "    ",
          "    # Then: Server file created with unique name",
          "    assert server_file.exists()",
          "    assert server_file.name == f'{bot_name}_server.py'",
          "    assert server_file.parent.name == 'src'",
          "    ",
          "    # Verify server content includes bot config reference",
          "    server_content = server_file.read_text()",
          "    assert 'test_bot_server' in server_content",
          "    assert 'bot_config.json' in server_content",
          "    assert 'test_bot.py' in server_content",
          "",
          "# GOOD: Code is self-documenting:",
          "# - Import shows MCPServerGenerator class is needed",
          "# - Constructor shows bot_name, config_path, workspace_root parameters",
          "# - Method call shows generate_server() returns a Path",
          "# - Assertions show expected file properties and content",
          "# NO verbose comments needed!"
        ]
      },
      "dont": {
        "description": "Verbose comments explaining what will fail",
        "content": [
          "def test_generator_creates_server_for_test_bot(self, workspace_root):",
          "    # Given: Bot config exists",
          "    config_file = create_bot_config(workspace_root, 'test_bot', ['shape'])",
          "    ",
          "    # When: Call API",
          "    from agile_bot.bots.base_bot.src.mcp_server_generator import MCPServerGenerator",
          "    generator = MCPServerGenerator(",
          "        bot_name='test_bot',",
          "        config_path=config_file,",
          "        workspace_root=workspace_root",
          "    )",
          "    server_file = generator.generate_server()",
          "    ",
          "    # Then: Server created",
          "    assert server_file.exists()",
          "    ",
          "    # DON'T: Verbose comments explaining failures",
          "    # TEST WILL FAIL: ImportError or MCPServerGenerator doesn't exist yet",
          "    # Shows API needs: MCPServerGenerator(bot_name, config_path, workspace_root)",
          "    # Shows API needs: generator.generate_server() returns Path to server file",
          "    # Shows server file must reference bot config and bot instantiation",
          "    # WRONG: All of this is already obvious from the code above!"
        ]
      }
    },
    {
      "do": {
        "description": "Error handling test is self-documenting",
        "content": [
          "def test_generator_fails_when_config_missing(self, workspace_root):",
          "    \"\"\"",
          "    SCENARIO: Generator fails when Bot Config is missing",
          "    GIVEN: Bot config does not exist",
          "    WHEN: Generator attempts to receive Bot Config",
          "    THEN: Raises FileNotFoundError",
          "    \"\"\"",
          "    # Given: No bot config file exists",
          "    bot_name = 'test_bot'",
          "    config_path = workspace_root / 'agile_bot' / 'bots' / bot_name / 'config' / 'bot_config.json'",
          "    ",
          "    # When: Call REAL MCPServerGenerator API",
          "    from agile_bot.bots.base_bot.src.mcp_server_generator import MCPServerGenerator",
          "    generator = MCPServerGenerator(",
          "        bot_name=bot_name,",
          "        config_path=config_path,",
          "        workspace_root=workspace_root",
          "    )",
          "    ",
          "    # Then: Raises FileNotFoundError with clear message",
          "    with pytest.raises(FileNotFoundError) as exc_info:",
          "        generator.generate_server()",
          "    ",
          "    assert 'Bot Config not found' in str(exc_info.value)",
          "    assert 'bot_config.json' in str(exc_info.value)",
          "",
          "# GOOD: Code shows:",
          "# - FileNotFoundError should be raised",
          "# - Error message should mention 'Bot Config not found' and 'bot_config.json'",
          "# Self-documenting through pytest.raises and assertions!"
        ]
      },
      "dont": {
        "description": "Adding redundant failure explanations",
        "content": [
          "def test_generator_fails_when_config_missing(self, workspace_root):",
          "    # Given: No config",
          "    config_path = workspace_root / 'config.json'",
          "    ",
          "    # When: Call API",
          "    from agile_bot.bots.base_bot.src.mcp_server_generator import MCPServerGenerator",
          "    generator = MCPServerGenerator('test_bot', config_path, workspace_root)",
          "    ",
          "    # Then: Raises error",
          "    with pytest.raises(FileNotFoundError) as exc_info:",
          "        generator.generate_server()",
          "    assert 'Bot Config not found' in str(exc_info.value)",
          "    ",
          "    # DON'T: Redundant explanations",
          "    # TEST WILL FAIL: ImportError or MCPServerGenerator doesn't exist yet",
          "    # Shows API needs proper error handling for missing config",
          "    # WRONG: pytest.raises already shows this!"
        ]
      }
    },
    {
      "do": {
        "description": "Complex API revealed through code",
        "content": [
          "def test_generator_creates_tools_for_all_behaviors(self, workspace_root):",
          "    \"\"\"",
          "    SCENARIO: Generator creates tools for test_bot with 4 behaviors",
          "    GIVEN: Bot has 4 behaviors with 6 actions each",
          "    WHEN: Generator processes Bot Config",
          "    THEN: Creates 24 tool instances (4 x 6)",
          "    \"\"\"",
          "    # Given: Bot config with multiple behaviors",
          "    bot_name = 'test_bot'",
          "    behaviors = ['shape', 'discovery', 'exploration', 'specification']",
          "    config_file = create_bot_config(workspace_root, bot_name, behaviors)",
          "    ",
          "    # When: Call REAL ToolGenerator API",
          "    from agile_bot.bots.base_bot.src.tool_generator import ToolGenerator",
          "    generator = ToolGenerator(",
          "        bot_name=bot_name,",
          "        config_path=config_file,",
          "        workspace_root=workspace_root",
          "    )",
          "    tools = generator.generate_all_tools()",
          "    ",
          "    # Then: All behavior-action pairs generate tools",
          "    assert len(tools) == 24",
          "    assert all(hasattr(tool, 'name') for tool in tools)",
          "    assert all(hasattr(tool, 'behavior') for tool in tools)",
          "    assert all(hasattr(tool, 'action') for tool in tools)",
          "    ",
          "    # Verify tool naming format",
          "    tool_names = [tool.name for tool in tools]",
          "    assert 'test_bot_shape_gather_context' in tool_names",
          "",
          "# GOOD: Code reveals complete API:",
          "# - ToolGenerator class with constructor parameters",
          "# - generate_all_tools() returns list of tool objects",
          "# - Tool objects have name, behavior, action attributes",
          "# - Tool naming convention is clear from assertion",
          "# All self-documenting!"
        ]
      },
      "dont": {
        "description": "Explaining what code already shows",
        "content": [
          "    # Then: Tools generated",
          "    assert len(tools) == 24",
          "    assert all(hasattr(tool, 'name') for tool in tools)",
          "    ",
          "    # DON'T: Explaining the obvious",
          "    # TEST WILL FAIL: ImportError or ToolGenerator doesn't exist yet",
          "    # Shows API needs: ToolGenerator(bot_name, config_path, workspace_root)",
          "    # Shows API needs: generator.generate_all_tools() returns list of Tool objects",
          "    # Shows Tool needs: name, behavior, action properties",
          "    # WRONG: This is redundant - the code above already shows all of this!"
        ]
      }
    }
  ],
  "rationale": [
    "Tests that call real APIs are self-documenting - code reveals expected structure",
    "Import statements show what modules and classes are needed",
    "Constructor calls show what parameters are required (names and types)",
    "Method calls show what APIs must exist and what they return",
    "Assertions show expected properties, return types, and behavior",
    "pytest.raises shows expected exceptions and error messages",
    "Verbose comments add noise and duplicate information",
    "When tests fail, error messages clearly show what's missing",
    "Code is the documentation - comments should explain WHY not WHAT"
  ],
  "key_principles": [
    "Tests are self-documenting through code structure",
    "Do NOT add comments explaining 'TEST WILL FAIL' or 'Shows API needs'",
    "Import statements document required modules/classes",
    "Constructor calls document required parameters",
    "Method calls document expected APIs and return types",
    "Assertions document expected properties and behavior",
    "Error tests use pytest.raises to document expected exceptions",
    "Let the failing test error messages explain what's missing",
    "Comments should explain complex logic or business rules, not API structure",
    "If code needs explanation, it's probably not clear enough"
  ],
  "antipatterns": [
    "Adding 'TEST WILL FAIL' comments explaining obvious failures",
    "Documenting in comments what imports already show",
    "Explaining constructor parameters in comments when code is clear",
    "Listing what methods are needed when method calls show this",
    "Describing return types when assertions demonstrate them",
    "Verbose explanations that duplicate what pytest.raises shows",
    "Comments that explain WHAT the code does (code should be self-explanatory)",
    "Over-commenting to compensate for unclear code"
  ],
  "what_to_comment": {
    "do_comment": [
      "Complex business rules that aren't obvious from code",
      "Why a specific test approach was chosen",
      "External dependencies or system requirements",
      "Non-obvious test data values and why they were chosen",
      "Workarounds for known issues or limitations"
    ],
    "dont_comment": [
      "That test will fail (obvious when test is for unimplemented code)",
      "What classes or methods are needed (imports and calls show this)",
      "What parameters constructors take (constructor call shows this)",
      "What methods return (assertions show this)",
      "What exceptions are raised (pytest.raises shows this)"
    ]
  }
}


