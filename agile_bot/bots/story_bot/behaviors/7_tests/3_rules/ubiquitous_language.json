{
  "description": "Use Ubiquitous Language (DDD): The SAME language EVERYWHERE - domain model, stories, acceptance criteria, scenarios, AND code. Class names = domain entities/nouns (GatherContextAction, BotConfig, Guardrails). Method names = domain responsibilities/verbs (inject_questions_and_evidence, load_and_merge_instructions). Do NOT reinvent with generic technical terms (execute, process, handle, manager, service). You may refine for finer detail, but ALWAYS preserve domain terminology.",
  "examples": [
    {
      "do": {
        "description": "Class names from domain model entities/nouns",
        "content": [
          "# Domain Model Entity: 'Gather Context Action'",
          "class GatherContextAction:",
          "    pass",
          "",
          "# Domain Model Entity: 'Build Knowledge Action'",
          "class BuildKnowledgeAction:",
          "    pass",
          "",
          "# Domain Model Entity: 'Validate Rules Action'",
          "class ValidateRulesAction:",
          "    pass",
          "",
          "# Story/AC Noun: 'MCP Server Generator'",
          "class MCPServerGenerator:",
          "    pass",
          "",
          "# Story/AC Noun: 'Tool Generator'",
          "class ToolGenerator:",
          "    pass",
          "",
          "# Story/AC Noun: 'Bot Config'",
          "class BotConfig:",
          "    pass",
          "",
          "# Story/AC Noun: 'Guardrails'",
          "class Guardrails:",
          "    pass",
          "",
          "# GOOD: Classes use exact nouns from domain model and stories"
        ]
      },
      "dont": {
        "description": "Generic technical class names",
        "content": [
          "# DON'T: Generic technical names",
          "class Action:  # Which action? Use specific domain name!",
          "    pass",
          "",
          "class Loader:  # What does it load? Use domain noun!",
          "    pass",
          "",
          "class Handler:  # What does it handle? Use domain entity!",
          "    pass",
          "",
          "class Manager:  # What does it manage? Use domain term!",
          "    pass",
          "",
          "class Service:  # What service? Use domain language!",
          "    pass",
          "",
          "class Processor:  # What does it process? Use domain entity!",
          "    pass",
          "",
          "# WRONG: Generic technical terms instead of domain language"
        ]
      }
    },
    {
      "do": {
        "description": "Method names from domain responsibilities and story steps",
        "content": [
          "# Domain Model Responsibility: 'Inject gather context instructions: Behavior, Guardrails, Required Clarifications'",
          "",
          "class GatherContextAction:",
          "    def inject_guardrails_into_instructions(self) -> Instructions:",
          "        \"\"\"Inject guardrails into gather context instructions.\"\"\"",
          "        pass",
          "",
          "# Story AC: 'WHEN Action loads guardrails THEN guardrails are injected into instructions'",
          "# Uses 'inject' from AC, 'guardrails' from domain, 'instructions' from AC",
          "",
          "# Domain Model Responsibility: 'Load and merge base and behavior instructions'",
          "",
          "class GatherContextAction:",
          "    def load_and_merge_instructions(self) -> Instructions:",
          "        \"\"\"Load and merge base and behavior-specific instructions.\"\"\"",
          "        pass",
          "",
          "# Scenario Step: 'Generator loads trigger words from behavior folder'",
          "",
          "class ToolGenerator:",
          "    def load_trigger_words_from_behavior_folder(self, behavior: str) -> List[str]:",
          "        \"\"\"Load trigger words from behavior folder.\"\"\"",
          "        pass",
          "",
          "# Scenario Step: 'Tool routes to correct behavior action'",
          "",
          "class Tool:",
          "    def route_to_behavior_action(self, bot) -> Result:",
          "        \"\"\"Route invocation to correct behavior action.\"\"\"",
          "        pass",
          "",
          "# GOOD: Methods use exact domain/story language:",
          "# - 'inject', 'load', 'merge', 'route' are domain verbs",
          "# - 'guardrails', 'instructions', 'trigger words', 'behavior' are domain nouns"
        ]
      },
      "dont": {
        "description": "Generic technical method names",
        "content": [
          "# DON'T: Generic execute/process/handle methods",
          "",
          "class GatherContextAction:",
          "    def execute_with_guardrails(self):  # 'execute_with' not in domain!",
          "        pass",
          "    ",
          "    def execute_with_rendered_content(self):  # Generic technical pattern!",
          "        pass",
          "    ",
          "    def get_instructions_with_templates(self):  # 'get_with' not in domain!",
          "        pass",
          "    ",
          "    def process(self):  # What does it process? Use domain verb!",
          "        pass",
          "    ",
          "    def handle_request(self):  # 'handle' not in domain!",
          "        pass",
          "",
          "# DON'T: Made-up verbs not in domain",
          "",
          "class ToolGenerator:",
          "    def fetch_patterns(self):  # Domain says 'load trigger words'!",
          "        pass",
          "    ",
          "    def retrieve_config(self):  # Domain says 'load' not 'retrieve'!",
          "        pass",
          "",
          "# WRONG: Using generic technical terms instead of domain language"
        ]
      }
    },
    {
      "do": {
        "description": "Refine while preserving ubiquitous language",
        "content": [
          "# Domain Responsibility: 'Inject guardrails'",
          "# Refined into specific methods using domain terms:",
          "",
          "class GatherContextAction:",
          "    def inject_key_questions_into_instructions(self) -> Instructions:",
          "        \"\"\"Inject key questions guardrails into instructions.\"\"\"",
          "        # 'inject', 'key questions', 'guardrails', 'instructions' all from domain",
          "        pass",
          "    ",
          "    def inject_evidence_into_instructions(self) -> Instructions:",
          "        \"\"\"Inject evidence guardrails into instructions.\"\"\"",
          "        # 'inject', 'evidence', 'guardrails', 'instructions' all from domain",
          "        pass",
          "",
          "# Domain Responsibility: 'Merge validation rules'",
          "# Refined into specific steps:",
          "",
          "class ValidateRulesAction:",
          "    def load_common_validation_rules(self) -> List[Rule]:",
          "        # 'load', 'common', 'validation rules' from domain",
          "        pass",
          "    ",
          "    def load_behavior_validation_rules(self) -> List[Rule]:",
          "        # 'load', 'behavior', 'validation rules' from domain",
          "        pass",
          "    ",
          "    def merge_validation_rules(self, common, behavior) -> List[Rule]:",
          "        # 'merge', 'validation rules' from domain",
          "        pass",
          "",
          "# GOOD: Refinement preserves all domain terminology"
        ]
      },
      "dont": {
        "description": "Losing ubiquitous language during refinement",
        "content": [
          "# Domain: 'Inject guardrails'",
          "# DON'T: Lose domain terms",
          "",
          "class GatherContextAction:",
          "    def add_metadata(self):  # Lost 'inject' and 'guardrails'!",
          "        pass",
          "    ",
          "    def populate_config(self):  # Lost all domain language!",
          "        pass",
          "    ",
          "    def enhance_instructions(self):  # 'enhance' not in domain!",
          "        pass",
          "",
          "# Domain: 'Merge validation rules'",
          "# DON'T: Use generic verbs",
          "",
          "class ValidateRulesAction:",
          "    def combine_rules(self):  # Domain says 'merge' not 'combine'!",
          "        pass",
          "    ",
          "    def fetch_all_rules(self):  # Domain says 'load' not 'fetch'!",
          "        pass",
          "",
          "# WRONG: Lost ubiquitous language during refinement"
        ]
      }
    }
  ],
  "rationale": [
    "Ubiquitous Language is core DDD principle - same vocabulary in domain, stories, and code",
    "Business stakeholders can read and understand code using familiar terms",
    "Eliminates translation between business language and technical language",
    "Makes traceability between stories, domain model, and code obvious",
    "Reduces cognitive load - one vocabulary for entire team",
    "Domain language is more precise than generic technical terms",
    "Code becomes living documentation using business language",
    "Consistency across domain model, stories, tests, and production code"
  ],
  "key_principles": [
    "USE UBIQUITOUS LANGUAGE: Same terms in domain model, stories, AC, scenarios, AND code",
    "Class names = domain entities/nouns (GatherContextAction, BotConfig, Guardrails)",
    "Method names = domain responsibilities/verbs (inject, load, merge, route)",
    "Consult domain model FIRST when naming classes and methods",
    "Consult stories/AC/scenarios SECOND for behavioral language",
    "Preserve domain terms when refining to finer detail",
    "Do NOT use generic technical terms (execute, process, handle, manager, service)",
    "Do NOT replace domain terms with synonyms",
    "Code should read like the domain model and stories",
    "When in doubt, use exact phrase from domain model or story"
  ],
  "antipatterns": [
    "Generic class names: Action, Loader, Handler, Manager, Service, Processor",
    "Generic method names: execute, process, handle, perform, run",
    "execute_with_X pattern instead of domain verbs",
    "get/set when domain uses specific verbs (load, inject, merge, route)",
    "Made-up terms not in domain model or stories",
    "Synonyms of domain terms ('fetch' instead of 'load', 'combine' instead of 'merge')",
    "Technical jargon over business language",
    "Losing domain language during code refinement"
  ],
  "sources_for_naming": {
    "classes": [
      "Domain Model entities (exact nouns)",
      "Domain Model aggregates and value objects",
      "Story nouns and entities (MCP Server Generator, Tool Generator, Bot Config)",
      "Acceptance criteria entities"
    ],
    "methods": [
      "Domain Model responsibilities (exact verbs and phrases)",
      "Story acceptance criteria (WHEN/THEN language)",
      "Scenario steps (Given/When/Then phrases)",
      "Domain operations and behaviors"
    ],
    "allowed_refinement": [
      "Break responsibilities into smaller methods using domain terms",
      "Add specificity using domain language (e.g., 'inject_key_questions' from 'inject_guardrails')",
      "Make relationships explicit using domain nouns (e.g., 'from_behavior_folder')"
    ],
    "not_allowed": [
      "Generic technical terms: execute, process, handle, perform, manage, service",
      "Synonyms of domain terms unless they appear in domain model",
      "New abstractions not in domain model",
      "Framework/library terminology over domain terms",
      "Marketing/buzzword names instead of domain names"
    ]
  },
  "scanner": "agile_bot.bots.base_bot.src.scanners.ubiquitous_language_scanner.UbiquitousLanguageScanner"
}
