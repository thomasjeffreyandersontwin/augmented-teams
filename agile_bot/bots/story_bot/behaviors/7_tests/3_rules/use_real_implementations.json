{
  "description": "Use real implementations by default. Only mock when explicitly asked or for uncontrollable external dependencies (network APIs, external services). Create real files in temporary test workspace using pytest tmp_path fixture. Don't mock file operations - use real temp files instead.",
  "examples": [
    {
      "do": {
        "description": "Real implementation with temporary test files",
        "content": [
          "def test_agent_loads_config_from_file(self, tmp_path):",
          "    \"\"\"Agent loads configuration from real file.\"\"\"",
          "    # Given: Create REAL file in temp workspace",
          "    config_path = tmp_path / 'agents' / 'base' / 'agent.json'",
          "    config_path.parent.mkdir(parents=True, exist_ok=True)",
          "    config_path.write_text('{\"name\": \"story_bot\"}')",
          "    ",
          "    # When: Agent loads from REAL file",
          "    agent = Agent('story_bot', tmp_path)",
          "    agent.load_config(config_path)",
          "    ",
          "    # Then: Config loaded from REAL file I/O",
          "    assert agent.name == 'story_bot'",
          "    # No mocking! Real file operations!"
        ]
      },
      "dont": {
        "description": "Mocking file operations when real files work",
        "content": [
          "def test_agent_loads_config(self):",
          "    # DON'T: Mock file operations when temp files work",
          "    with patch('pathlib.Path.exists', return_value=True):",
          "        with patch('pathlib.Path.read_text', return_value='{\"name\": \"bot\"}'):",
          "            agent = Agent('bot', Path('/fake'))",
          "            agent.load_config(Path('fake.json'))",
          "    # WRONG: Use real temp files instead!"
        ]
      }
    },
    {
      "do": {
        "description": "Mock only truly external dependencies",
        "content": [
          "def test_agent_fetches_remote_config(self):",
          "    \"\"\"Agent fetches configuration from remote API.\"\"\"",
          "    # Given: Mock EXTERNAL network call (can't control)",
          "    with patch('requests.get') as mock_get:",
          "        mock_get.return_value.json.return_value = {'name': 'bot'}",
          "        ",
          "        # When: Agent fetches from API",
          "        agent = Agent.from_remote_config('http://api.example.com/config')",
          "        ",
          "        # Then: Config loaded",
          "        assert agent.name == 'bot'",
          "    # OK to mock: External service we don't control",
          "",
          "def test_agent_sends_metrics(self):",
          "    \"\"\"Agent sends metrics to monitoring service.\"\"\"",
          "    # Given: Mock EXTERNAL metrics service",
          "    with patch('monitoring.send_metric') as mock_send:",
          "        agent = Agent('bot', Path('/tmp'))",
          "        ",
          "        # When: Agent performs action that sends metrics",
          "        agent.initialize()",
          "        ",
          "        # Then: Metrics sent",
          "        mock_send.assert_called_once()",
          "    # OK to mock: External monitoring service"
        ]
      },
      "dont": {
        "description": "Mock internal business logic or testable I/O",
        "content": [
          "def test_agent_initialization(self):",
          "    # DON'T: Mock the class under test",
          "    agent = Mock(spec=Agent)  # WRONG - defeats purpose!",
          "    agent.initialize()",
          "    ",
          "    # DON'T: Mock internal business logic",
          "    with patch.object(Agent, 'validate_config') as mock_validate:",
          "        agent = Agent('bot', Path('/tmp'))",
          "        agent.initialize()",
          "        # WRONG - test the validation logic, don't mock it!",
          "    ",
          "    # DON'T: Mock file operations when you can use real files",
          "    with patch('json.loads') as mock_json:",
          "        # WRONG - use real temp files and real json.loads!"
        ]
      }
    },
    {
      "do": {
        "description": "Use pytest fixtures for real test data",
        "content": [
          "@pytest.fixture",
          "def config_file(tmp_path):",
          "    \"\"\"Fixture: Real configuration file.\"\"\"",
          "    config_path = tmp_path / 'config.json'",
          "    config_path.write_text('{\"name\": \"story_bot\"}')",
          "    return config_path",
          "",
          "@pytest.fixture",
          "def workspace_with_config(tmp_path):",
          "    \"\"\"Fixture: Real workspace with config.\"\"\"",
          "    workspace = tmp_path / 'workspace'",
          "    workspace.mkdir()",
          "    config_dir = workspace / 'agents' / 'base'",
          "    config_dir.mkdir(parents=True)",
          "    (config_dir / 'agent.json').write_text('{\"name\": \"bot\"}')",
          "    return workspace",
          "",
          "class TestAgent:",
          "    def test_loads_from_workspace(self, workspace_with_config):",
          "        # Use REAL workspace fixture",
          "        agent = Agent('bot', workspace_with_config)",
          "        agent.initialize()",
          "        assert agent.is_initialized"
        ]
      },
      "dont": {
        "description": "Mock fixtures instead of creating real data",
        "content": [
          "@pytest.fixture",
          "def config_file():",
          "    \"\"\"DON'T: Mock fixture instead of real file.\"\"\"",
          "    mock_file = Mock(spec=Path)",
          "    mock_file.exists.return_value = True",
          "    mock_file.read_text.return_value = '{\"name\": \"bot\"}'",
          "    return mock_file  # WRONG - create real temp file!"
        ]
      }
    }
  ],
  "scanner": "agile_bot.bots.base_bot.src.scanners.real_implementations_scanner.RealImplementationsScanner"
}
