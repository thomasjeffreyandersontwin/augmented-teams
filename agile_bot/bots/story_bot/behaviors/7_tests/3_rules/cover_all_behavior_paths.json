{
  "description": "Cover all behavior paths: normal (happy path), edge cases, and failure scenarios. Each distinct behavior needs its own focused test. Tests must be independent and can run in any order. From BDD Rule 3 (Comprehensive and Brief Coverage).",
  "examples": [
    {
      "do": {
        "description": "Test normal, edge, and failure paths",
        "content": [
          "class TestAgentConfigurationLoading:",
          "    \"\"\"Agent configuration loading behavior.\"\"\"",
          "    ",
          "    # NORMAL PATH: Happy path scenario",
          "    def test_loads_valid_configuration_from_file(self, tmp_path):",
          "        \"\"\"Agent loads valid configuration from file.\"\"\"",
          "        # Given: Valid config file exists",
          "        config_file = tmp_path / 'config.json'",
          "        config_file.write_text('{\"name\": \"story_bot\", \"version\": \"1.0\"}')",
          "        ",
          "        # When: Agent loads config",
          "        agent = Agent()",
          "        config = agent.load_config(config_file)",
          "        ",
          "        # Then: Config loaded successfully",
          "        assert config['name'] == 'story_bot'",
          "        assert config['version'] == '1.0'",
          "    ",
          "    # EDGE CASE: Empty but valid configuration",
          "    def test_loads_empty_configuration_file(self, tmp_path):",
          "        \"\"\"Agent loads empty configuration file.\"\"\"",
          "        # Given: Empty but valid JSON",
          "        config_file = tmp_path / 'config.json'",
          "        config_file.write_text('{}')",
          "        ",
          "        # When: Agent loads empty config",
          "        agent = Agent()",
          "        config = agent.load_config(config_file)",
          "        ",
          "        # Then: Returns empty dict",
          "        assert config == {}",
          "    ",
          "    # EDGE CASE: Very large configuration",
          "    def test_loads_large_configuration_file(self, tmp_path):",
          "        \"\"\"Agent loads large configuration with many fields.\"\"\"",
          "        # Given: Config with 100+ fields",
          "        large_config = {f'field_{i}': f'value_{i}' for i in range(100)}",
          "        config_file = tmp_path / 'config.json'",
          "        config_file.write_text(json.dumps(large_config))",
          "        ",
          "        # When: Agent loads large config",
          "        agent = Agent()",
          "        config = agent.load_config(config_file)",
          "        ",
          "        # Then: All fields loaded",
          "        assert len(config) == 100",
          "        assert config['field_0'] == 'value_0'",
          "    ",
          "    # FAILURE PATH: File doesn't exist",
          "    def test_raises_error_when_config_file_missing(self):",
          "        \"\"\"Agent raises FileNotFoundError when config file missing.\"\"\"",
          "        # Given: Config file doesn't exist",
          "        missing_file = Path('nonexistent/config.json')",
          "        ",
          "        # When/Then: Loading raises FileNotFoundError",
          "        agent = Agent()",
          "        with pytest.raises(FileNotFoundError, match='config.json'):",
          "            agent.load_config(missing_file)",
          "    ",
          "    # FAILURE PATH: Invalid JSON",
          "    def test_raises_error_when_config_file_invalid_json(self, tmp_path):",
          "        \"\"\"Agent raises ValueError when config contains invalid JSON.\"\"\"",
          "        # Given: File with invalid JSON",
          "        config_file = tmp_path / 'config.json'",
          "        config_file.write_text('not valid json {')",
          "        ",
          "        # When/Then: Loading raises ValueError",
          "        agent = Agent()",
          "        with pytest.raises(ValueError, match='Invalid JSON'):",
          "            agent.load_config(config_file)",
          "    ",
          "    # FAILURE PATH: File exists but empty",
          "    def test_raises_error_when_config_file_empty(self, tmp_path):",
          "        \"\"\"Agent raises ValueError when config file is empty.\"\"\"",
          "        # Given: Empty file (not even empty JSON)",
          "        config_file = tmp_path / 'config.json'",
          "        config_file.write_text('')",
          "        ",
          "        # When/Then: Loading raises ValueError",
          "        agent = Agent()",
          "        with pytest.raises(ValueError, match='Empty configuration'):",
          "            agent.load_config(config_file)"
        ]
      },
      "dont": {
        "description": "Only test happy path or mix multiple paths in one test",
        "content": [
          "# DON'T: Only test happy path",
          "def test_loads_config(self, tmp_path):",
          "    config_file = tmp_path / 'config.json'",
          "    config_file.write_text('{\"name\": \"bot\"}')",
          "    agent = Agent()",
          "    config = agent.load_config(config_file)",
          "    assert config['name'] == 'bot'",
          "    # WRONG: What about missing file? Invalid JSON? Empty file?",
          "",
          "# DON'T: Mix multiple paths in one test",
          "def test_config_loading_all_scenarios(self, tmp_path):",
          "    # Test 1: Valid config",
          "    config_file = tmp_path / 'config.json'",
          "    config_file.write_text('{\"name\": \"bot\"}')",
          "    config = agent.load_config(config_file)",
          "    assert config['name'] == 'bot'",
          "    ",
          "    # Test 2: Missing file",
          "    with pytest.raises(FileNotFoundError):",
          "        agent.load_config(Path('missing.json'))",
          "    ",
          "    # Test 3: Invalid JSON",
          "    bad_file = tmp_path / 'bad.json'",
          "    bad_file.write_text('bad json')",
          "    with pytest.raises(ValueError):",
          "        agent.load_config(bad_file)",
          "    # WRONG: Multiple scenarios in one test!",
          "    # If first fails, others don't run!",
          "    # Hard to understand which scenario failed!"
        ]
      }
    },
    {
      "do": {
        "description": "Independent tests that can run in any order",
        "content": [
          "class TestCharacterCreation:",
          "    \"\"\"Each test is completely independent.\"\"\"",
          "    ",
          "    def test_character_has_default_stats_when_created(self):",
          "        \"\"\"Character has default stats when created.\"\"\"",
          "        # Own setup",
          "        character = Character(name='Hero')",
          "        ",
          "        # Own assertions",
          "        assert character.strength == 10",
          "        assert character.health == 100",
          "    ",
          "    def test_character_accepts_custom_stats_when_provided(self):",
          "        \"\"\"Character accepts custom stats when provided.\"\"\"",
          "        # Own setup (doesn't depend on previous test)",
          "        character = Character(name='Hero', strength=15, health=120)",
          "        ",
          "        # Own assertions",
          "        assert character.strength == 15",
          "        assert character.health == 120",
          "    ",
          "    def test_character_validates_stat_ranges_when_created(self):",
          "        \"\"\"Character validates stat ranges when created.\"\"\"",
          "        # Own setup (independent)",
          "        with pytest.raises(ValueError, match='Strength must be 1-20'):",
          "            Character(name='Hero', strength=25)",
          "    ",
          "    # These tests can run in ANY ORDER",
          "    # Each test creates its own Character",
          "    # No shared state between tests"
        ]
      },
      "dont": {
        "description": "Tests that depend on execution order",
        "content": [
          "class TestCharacterCreation:",
          "    # DON'T: Tests depend on order",
          "    ",
          "    def test_1_create_character(self):",
          "        self.character = Character('Hero')  # ❌ Shared state",
          "        assert self.character.name == 'Hero'",
          "    ",
          "    def test_2_set_stats(self):",
          "        # ❌ WRONG: Depends on test_1 running first!",
          "        self.character.strength = 15",
          "        assert self.character.strength == 15",
          "    ",
          "    def test_3_validate_stats(self):",
          "        # ❌ WRONG: Depends on test_2 running first!",
          "        assert self.character.strength == 15",
          "    ",
          "    # PROBLEMS:",
          "    # - Tests must run in specific order (1, 2, 3)",
          "    # - If test_1 fails, test_2 and test_3 can't run",
          "    # - Can't run single test in isolation",
          "    # - Shared state (self.character) causes coupling"
        ]
      }
    }
  ],
  "scanner": "agile_bot.bots.base_bot.src.scanners.cover_all_paths_scanner.CoverAllPathsScanner"
}
