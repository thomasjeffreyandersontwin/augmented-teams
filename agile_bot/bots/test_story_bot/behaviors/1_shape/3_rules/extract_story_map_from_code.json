{
  "description": "CRITICAL: When creating story maps from code, analyze the outermost layer showing end-to-end journey. Locate acceptance tests, human code engagement points (CLI/UI), MCP server definitions, WSDL, API contracts. Analyze operations and domain for major/minor concepts. Create epics/sub-epics based on higher-order goals. Look at distinct behaviors and typical execution order to lay out story journey.",
  "examples": [
    {
      "do": {
        "description": "Find outermost layer and entry points",
        "content": [
          "Start with the OUTERMOST LAYER showing end-to-end journey",
          "Locate all HUMAN CODE ENGAGEMENT points:",
          "  - CLI commands and entry points (main(), command handlers)",
          "  - UI entry points (web routes, event handlers, button clicks)",
          "  - MCP server tool definitions (tool names, parameters, descriptions)",
          "  - API contracts (REST endpoints, GraphQL queries, WSDL operations)",
          "  - WebSocket handlers, message queues, event listeners",
          "",
          "Locate ACCEPTANCE TESTS:",
          "  - End-to-end tests that show complete user journeys",
          "  - Integration tests that show system-to-system flows",
          "  - Test scenarios that describe 'when X, then Y' behaviors",
          "  - BDD/Gherkin tests with Given-When-Then structure",
          "",
          "Example Entry Points to Find:",
          "- CLI: 'python -m story_io.story_io_cli render-outline --story-graph file.json'",
          "- MCP: Tool 'render_outline' with parameters 'story_graph_path', 'output_path'",
          "- API: POST /api/story-graph/render with body {storyGraph, outputFormat}",
          "- UI: Button 'Render Outline' that triggers render operation",
          "- Test: 'test_render_outline_from_json' that shows complete flow"
        ]
      },
      "dont": {
        "description": "Don't start with internal implementation details",
        "content": [
          "Don't start with internal classes or helper functions",
          "Don't start with data structures or domain models",
          "Don't start with utility functions or low-level operations",
          "",
          "Wrong Starting Points:",
          "- Internal class: 'StoryIODiagram.load_from_json()' (implementation detail)",
          "- Helper function: 'parse_story_graph()' (internal mechanism)",
          "- Data structure: 'Epic' class definition (domain model, not entry point)",
          "",
          "These are important but come AFTER identifying the journey"
        ]
      }
    },
    {
      "do": {
        "description": "Analyze operations and domain for major/minor concepts",
        "content": [
          "Analyze OPERATIONS from entry points:",
          "  - What operations are exposed? (render, sync, search, edit, save)",
          "  - What are the operation names? (render-outline, sync-increments, search-stories)",
          "  - What parameters do they take? (story_graph_path, output_path, query)",
          "  - What do they return? (DrawIO file, JSON report, search results)",
          "",
          "Analyze DOMAIN CONCEPTS:",
          "  - MAJOR CONCEPTS: High-level domain entities (StoryGraph, Diagram, Epic, Sub-Epic, Story)",
          "  - MINOR CONCEPTS: Supporting entities (Position, Boundary, User, Increment)",
          "  - OPERATIONS: Actions on concepts (Load, Read, Edit, Render, Synchronize, Search, Save)",
          "  - RELATIONSHIPS: How concepts relate (Epic contains Sub-Epics, Sub-Epic contains Stories)",
          "",
          "Example Analysis (Story-IO Domain):",
          "- Operations: render-outline, render-increments, sync-outline, sync-increments, search, add-user, merge",
          "- Major Concepts: StoryGraph (main entity), Diagram (visual representation), Epic/Sub-Epic/Story (hierarchy)",
          "- Minor Concepts: Position (2D coordinate), Boundary (rectangular area), User (story actor), Increment (priority grouping)",
          "- Relationships: StoryGraph contains Epics, Epic contains Sub-Epics, Sub-Epic contains Stories",
          "",
          "Example Analysis (Payment Domain):",
          "- Operations: process-payment, refund-payment",
          "- Major Concepts: Payment (main entity), Transaction (financial transaction), Card (payment method), Refund (reversal)",
          "- Minor Concepts: Amount (monetary value), Currency (USD, EUR), Status (pending, approved, declined), PaymentMethod (card, bank transfer)",
          "- Relationships: Payment contains Transaction, Payment uses Card, Payment can have Refund, Transaction has Status"
        ]
      },
      "dont": {
        "description": "Don't confuse implementation details with domain concepts",
        "content": [
          "Don't treat implementation classes as domain concepts",
          "Don't treat utility functions as operations",
          "Don't treat data structures as domain entities",
          "",
          "Wrong Analysis:",
          "- Implementation class: 'StoryIORenderer' (implementation detail, not domain concept)",
          "- Utility function: 'calculate_position()' (implementation detail, not operation)",
          "- Data structure: 'dict' or 'list' (implementation detail, not domain concept)",
          "",
          "Focus on WHAT the system does (domain), not HOW it does it (implementation)"
        ]
      }
    },
    {
      "do": {
        "description": "Create epics/sub-epics based on higher-order goals",
        "content": [
          "Group operations into EPICS based on HIGHER-ORDER GOALS:",
          "  - What is the user/system trying to accomplish?",
          "  - What are the major capabilities?",
          "  - What are the lifecycle stages?",
          "",
          "Example Epic Creation from Operations (Story-IO Domain):",
          "- Operations: render-outline, render-increments, render-exploration",
          "- Higher-Order Goal: 'Render StoryGraph' (user wants to visualize story map)",
          "- Epic: 'Render StoryGraph'",
          "",
          "- Operations: sync-outline, sync-increments, generate-sync-report, merge",
          "- Higher-Order Goal: 'Synchronize StoryGraph' (user wants to sync between formats)",
          "- Epic: 'Synchronize StoryGraph'",
          "",
          "Example Epic Creation from Operations (Payment Domain):",
          "- Operations: process-payment, process_payment, POST /api/payments/process",
          "- Higher-Order Goal: 'Process Payment' (user wants to process a payment transaction)",
          "- Epic: 'Process Payment'",
          "",
          "- Operations: refund-payment, refund_payment, POST /api/payments/refund",
          "- Higher-Order Goal: 'Refund Payment' (user wants to reverse a payment)",
          "- Epic: 'Refund Payment'",
          "",
          "Group operations into SUB-EPICS based on DISTINCT BEHAVIORS:",
          "  - What are the different ways to accomplish the epic goal?",
          "  - What are the different types or modes?",
          "  - What are the different contexts or scenarios?",
          "",
          "Example Sub-Epic Creation (Story-IO Domain):",
          "- Epic: 'Render StoryGraph'",
          "- Distinct Behaviors: Render outline (basic), Render increments (with priorities), Render exploration (with acceptance criteria)",
          "- Sub-Epics: 'Render Outline', 'Render Increments', 'Render Exploration'",
          "",
          "- Epic: 'Synchronize StoryGraph'",
          "- Distinct Behaviors: Sync outline structure, Sync increments, Generate comparison report, Merge graphs",
          "- Sub-Epics: 'Synchronize Outline', 'Synchronize Increments', 'Generate Sync Report', 'Merge StoryGraphs'",
          "",
          "Example Sub-Epic Creation (Payment Domain):",
          "- Epic: 'Process Payment'",
          "- Distinct Behaviors: Validate payment (required), Authorize payment (required), Process with card (common), Process with bank transfer (alternative), Process with wallet (alternative), Confirm payment (required)",
          "- Sub-Epics: 'Validate Payment', 'Authorize Payment', 'Process Card Payment', 'Process Bank Transfer', 'Process Wallet Payment', 'Confirm Payment'",
          "",
          "- Epic: 'Refund Payment'",
          "- Distinct Behaviors: Validate refund eligibility, Process refund, Confirm refund",
          "- Sub-Epics: 'Validate Refund', 'Process Refund', 'Confirm Refund'"
        ]
      },
      "dont": {
        "description": "Don't create epics/sub-epics from implementation structure",
        "content": [
          "Don't create epics based on class structure (StoryIODiagram, DrawIORenderer, PaymentProcessor, etc.)",
          "Don't create sub-epics based on method names (load_json, parse_xml, charge_card, etc.)",
          "Don't create epics/sub-epics from technical layers (data layer, service layer, etc.)",
          "",
          "Wrong Epic Creation:",
          "- Based on class: 'StoryIODiagram Operations' (implementation structure)",
          "- Based on method: 'JSON Loading' (technical mechanism)",
          "- Based on layer: 'Data Access Layer' (technical architecture)",
          "",
          "Focus on USER/SYSTEM GOALS, not technical structure"
        ]
      }
    },
    {
      "do": {
        "description": "Look at distinct behaviors and typical execution order",
        "content": [
          "Analyze DISTINCT BEHAVIORS from acceptance tests and code flow:",
          "  - What are the different scenarios?",
          "  - What are the different paths through the code?",
          "  - What are the different user actions?",
          "",
          "Example Behavior Analysis (Story-IO Domain):",
          "- Test: 'test_render_outline_from_json' shows: Load JSON → Parse → Generate XML → Calculate Positions → Apply Styles → Save",
          "- Distinct Behaviors: Load, Parse, Generate, Calculate, Apply, Save",
          "- These become STORIES in the journey",
          "",
          "Example Behavior Analysis (Payment Domain):",
          "- Test: 'test_process_payment_success' shows: Invoke → Validate → Authorize → Process → Confirm",
          "- Distinct Behaviors: Invoke (entry point), Validate (check input), Authorize (check funds/fraud), Process (execute transaction), Confirm (complete and notify)",
          "- These become STORIES in the journey",
          "",
          "Determine TYPICAL EXECUTION ORDER from code flow:",
          "  - Trace through acceptance tests: what happens first, second, third?",
          "  - Trace through CLI commands: what's the flow?",
          "  - Trace through MCP tool calls: what's the sequence?",
          "  - Look at error handling: what are alternative paths?",
          "",
          "Example Execution Order Analysis (Story-IO Domain):",
          "- CLI: 'render-outline --story-graph file.json --output file.drawio'",
          "- Code Flow: Parse args → Load story graph → Create diagram → Render outline → Save file",
          "- Typical Order: 1. Parse arguments, 2. Load story graph, 3. Render outline, 4. Save file",
          "- Stories: 'Parses Command Arguments' → 'Loads StoryGraph from JSON' → 'Renders Outline to DrawIO' → 'Saves DrawIO File'",
          "",
          "Example Execution Order Analysis (Payment Domain):",
          "- CLI: 'process-payment --payment-id 123 --amount 50.00'",
          "- Code Flow: Parse args → Validate payment → Authorize payment → Process payment → Confirm payment",
          "- Typical Order: 1. User invokes process payment, 2. System validates payment details, 3. System authorizes payment, 4. System processes payment, 5. System confirms payment",
          "- Stories: 'User invokes process payment command' → 'System validates payment details' → 'System authorizes payment with payment processor' → 'System processes payment transaction' → 'System confirms payment and sends notification'",
          "",
          "Create STORY JOURNEY from execution order:",
          "  - Start with entry point (CLI invocation, UI click, MCP tool call)",
          "  - Follow the code flow through operations",
          "  - Include error handling and alternative paths",
          "  - End with completion (save, return result, display)",
          "",
          "Example Story Journey (Story-IO Domain):",
          "- Entry: 'User invokes render-outline command from CLI'",
          "- Flow: 'CLI parses arguments' → 'CLI loads story graph' → 'CLI invokes render' → 'System renders outline' → 'System saves file'",
          "- Error: 'If file not found, CLI displays error message'",
          "- Completion: 'CLI returns success message'",
          "",
          "Example Story Journey (Payment Domain):",
          "- Entry: 'User invokes process payment command' (WHEN: user wants to charge customer, WHY: to complete purchase, OUTCOME: CLI/MCP/API receives request)",
          "- Flow: 'System validates payment details' (WHEN: after request received, WHY: to ensure payment can be processed, OUTCOME: details validated) → 'System authorizes payment' (WHEN: after validation, WHY: to check funds/fraud, OUTCOME: payment authorized) → 'System processes payment' (WHEN: after authorization, WHY: to execute transaction, OUTCOME: payment processed) → 'System confirms payment' (WHEN: after processing, WHY: to notify user, OUTCOME: payment confirmed)",
          "- Error: 'If validation fails, System displays validation error' (WHEN: validation fails, WHY: to inform user, OUTCOME: error shown, process stops)",
          "- Completion: 'System returns transaction ID' (WHEN: after confirmation, WHY: to provide reference, OUTCOME: transaction ID returned)"
        ]
      },
      "dont": {
        "description": "Don't create stories from code structure or method calls",
        "content": [
          "Don't create stories from every method call in code",
          "Don't create stories from internal function calls",
          "Don't create stories from data structure operations",
          "",
          "Wrong Story Creation:",
          "- From method: 'StoryIODiagram.__init__()' (internal initialization)",
          "- From function: 'parse_json()' (internal parsing)",
          "- From operation: 'dict.get()' (data access, not behavior)",
          "- From method: 'PaymentProcessor.charge_card()' (internal implementation)",
          "",
          "Focus on USER/SYSTEM VISIBLE BEHAVIORS, not internal implementation"
        ]
      }
    },
    {
      "do": {
        "description": "Lay out story journey from end-to-end flow",
        "content": [
          "Create STORY JOURNEY that shows complete end-to-end flow:",
          "  - Start: How does user/system initiate? (CLI command, UI click, API call)",
          "  - Middle: What happens step by step? (parse, load, process, transform)",
          "  - End: How does it complete? (save, return, display, notify)",
          "",
          "Include CONTEXT for each story:",
          "  - WHEN does it happen? (trigger, condition, user action)",
          "  - WHY does it happen? (purpose, user need, system requirement)",
          "  - WHAT is the outcome? (result, state change, user experience)",
          "  - ACTOR: Who performs the action? (User, System, CLI, MCP, API, etc.)",
          "",
          "Example Complete Story Journey (Story-IO Domain):",
          "(E) Render StoryGraph",
          "  and (E) Render Outline",
          "    and (S) User --> invokes render-outline command from CLI",
          "    and (S) CLI --> parses command arguments",
          "    and (S) CLI --> loads story graph from JSON file",
          "    and (S) System --> renders outline to DrawIO format",
          "    and (S) System --> saves DrawIO file",
          "",
          "Example Complete Story Journey (Payment Domain):",
          "(E) Process Payment",
          "  and (E) Process Card Payment",
          "    and (S) User --> invokes process payment command",
          "    and (S) System --> validates payment details",
          "    and (S) System --> authorizes payment with payment processor",
          "    and (S) System --> processes payment transaction",
          "    and (S) System --> confirms payment and sends notification",
          "",
          "Include ERROR HANDLING and ALTERNATIVE PATHS:",
          "  - What happens when file not found?",
          "  - What happens when parsing fails?",
          "  - What happens when validation fails?",
          "  - What happens when authorization fails?",
          "",
          "Example Error Handling (Story-IO Domain):",
          "  and (S) CLI --> displays error message if story graph file not found",
          "",
          "Example Error Handling (Payment Domain):",
          "  and (S) System --> displays validation error if validation fails",
          "  and (S) System --> displays authorization declined message if authorization fails"
        ]
      },
      "dont": {
        "description": "Don't create isolated stories without journey context",
        "content": [
          "Don't create stories that are just operations without context",
          "Don't create stories that don't connect to a journey",
          "Don't create stories without when/why/outcome/actor",
          "",
          "Wrong Story Creation:",
          "- (S) System --> loads StoryGraph (no context: when? why? what happens next?)",
          "- (S) System --> parses JSON (no context: when? why? what's the outcome?)",
          "- (S) System --> saves file (no context: when? why? what triggers this?)",
          "- (S) System --> processes payment (no context: when? why? what's the outcome?)",
          "",
          "Every story must be part of a JOURNEY with CONTEXT (when/why/outcome/actor)"
        ]
      }
    }
  ]
}
