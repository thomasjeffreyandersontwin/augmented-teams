{
  "description": "PRODUCTION CODE RULE: Keep functions under 20 lines. Each function should be one level of abstraction. Extract complex logic into named helper functions. Use guard clauses to reduce nesting. Keep nesting under 2-3 levels. Tests for small functions are easier to write and understand.",
  "examples": [
    {
      "do": {
        "description": "Small focused functions under 20 lines",
        "content": [
          "# Production Code - Small functions, one level of abstraction",
          "class Agent:",
          "    def initialize_from_config_file(self, config_path: Path):",
          "        \"\"\"Initialize agent from configuration file.\"\"\"",
          "        self._validate_config_file_exists(config_path)",
          "        config = self._load_config(config_path)",
          "        self._validate_config_structure(config)",
          "        self._apply_config(config)",
          "    ",
          "    def _validate_config_file_exists(self, config_path: Path):",
          "        \"\"\"Validate configuration file exists.\"\"\"",
          "        if not config_path.exists():",
          "            raise FileNotFoundError(f'Config not found: {config_path}')",
          "    ",
          "    def _load_config(self, config_path: Path) -> dict:",
          "        \"\"\"Load configuration from file.\"\"\"",
          "        try:",
          "            return json.loads(config_path.read_text())",
          "        except json.JSONDecodeError as e:",
          "            raise ValueError(f'Invalid JSON: {e}')",
          "    ",
          "    def _validate_config_structure(self, config: dict):",
          "        \"\"\"Validate configuration has required fields.\"\"\"",
          "        required = ['name', 'workspace_root']",
          "        missing = [f for f in required if f not in config]",
          "        if missing:",
          "            raise ValueError(f'Missing fields: {missing}')",
          "",
          "# Tests are simple - one function, one test",
          "def test_validate_config_file_raises_when_file_missing(self):",
          "    agent = Agent()",
          "    with pytest.raises(FileNotFoundError, match='Config not found'):",
          "        agent._validate_config_file_exists(Path('missing.json'))"
        ]
      },
      "dont": {
        "description": "Large monolithic functions over 20 lines",
        "content": [
          "# DON'T: Large function mixing abstraction levels",
          "class Agent:",
          "    def initialize_from_config_file(self, config_path: Path):",
          "        # WRONG - 40+ lines, multiple abstraction levels",
          "        if not config_path.exists():",
          "            logger.error(f'File not found: {config_path}')",
          "            raise FileNotFoundError('Config not found')",
          "        ",
          "        try:",
          "            content = config_path.read_text()",
          "        except IOError as e:",
          "            logger.error(f'Failed to read: {e}')",
          "            raise",
          "        ",
          "        try:",
          "            config = json.loads(content)",
          "        except json.JSONDecodeError as e:",
          "            logger.error(f'Invalid JSON: {e}')",
          "            raise ValueError('Invalid JSON')",
          "        ",
          "        if 'name' not in config:",
          "            logger.error('Missing name field')",
          "            raise ValueError('Missing name')",
          "        ",
          "        if 'workspace_root' not in config:",
          "            logger.error('Missing workspace_root')",
          "            raise ValueError('Missing workspace_root')",
          "        ",
          "        self.name = config['name']",
          "        self.workspace_root = Path(config['workspace_root'])",
          "        ",
          "        if not self.workspace_root.exists():",
          "            logger.warning('Creating workspace')",
          "            self.workspace_root.mkdir(parents=True)",
          "        ",
          "        # ... more code ...",
          "        # TOO LONG! Hard to test! Extract into smaller functions!",
          "",
          "# Test is complex and fragile",
          "def test_initialize_from_config_file(self, tmp_path, mock_logger):",
          "    # WRONG - test must handle all cases at once",
          "    # Multiple assertions, hard to maintain"
        ]
      }
    },
    {
      "do": {
        "description": "Use guard clauses to reduce nesting",
        "content": [
          "# Production Code - Guard clauses, early returns",
          "class ConfigValidator:",
          "    def validate_agent_config(self, config: dict) -> ValidationResult:",
          "        \"\"\"Validate agent configuration structure.\"\"\"",
          "        # Guard clauses - check and return early",
          "        if not config:",
          "            return ValidationResult.error('Config is empty')",
          "        ",
          "        if 'name' not in config:",
          "            return ValidationResult.error('Missing name')",
          "        ",
          "        if not isinstance(config['name'], str):",
          "            return ValidationResult.error('Name must be string')",
          "        ",
          "        if len(config['name']) == 0:",
          "            return ValidationResult.error('Name cannot be empty')",
          "        ",
          "        # Happy path at end, no nesting",
          "        return ValidationResult.success()",
          "",
          "# Tests are simple - one guard clause per test",
          "def test_validate_returns_error_when_config_empty(self):",
          "    validator = ConfigValidator()",
          "    result = validator.validate_agent_config({})",
          "    assert not result.is_valid",
          "    assert 'empty' in result.error.lower()"
        ]
      },
      "dont": {
        "description": "Deep nesting instead of guard clauses",
        "content": [
          "# DON'T: Deep nesting",
          "class ConfigValidator:",
          "    def validate_agent_config(self, config: dict) -> ValidationResult:",
          "        # WRONG - nested if statements",
          "        if config:",
          "            if 'name' in config:",
          "                if isinstance(config['name'], str):",
          "                    if len(config['name']) > 0:",
          "                        if 'workspace_root' in config:",
          "                            if isinstance(config['workspace_root'], str):",
          "                                return ValidationResult.success()",
          "                            else:",
          "                                return ValidationResult.error('workspace_root type')",
          "                        else:",
          "                            return ValidationResult.error('Missing workspace_root')",
          "                    else:",
          "                        return ValidationResult.error('Empty name')",
          "                else:",
          "                    return ValidationResult.error('Name type')",
          "            else:",
          "                return ValidationResult.error('Missing name')",
          "        else:",
          "            return ValidationResult.error('Empty config')",
          "        # WRONG - 6 levels deep! Unreadable! Use guard clauses!"
        ]
      }
    }
  ]
}


