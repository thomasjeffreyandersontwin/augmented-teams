{
  "description": "PRODUCTION CODE RULE: Each function/method should do ONE thing and do it well. No hidden side effects. Name reveals complete behavior. Keep functions under 20 lines. Extract multiple concerns into separate functions. Tests should verify single responsibility - if test needs multiple unrelated assertions, function probably does too much.",
  "examples": [
    {
      "do": {
        "description": "Single responsibility functions",
        "content": [
          "# Production Code - Each function does ONE thing",
          "class Agent:",
          "    def load_config(self, config_path: Path) -> dict:",
          "        \"\"\"Load configuration from file.\"\"\"",
          "        return json.loads(config_path.read_text())",
          "    ",
          "    def validate_config(self, config: dict) -> bool:",
          "        \"\"\"Validate configuration structure.\"\"\"",
          "        required = ['name', 'workspace_root']",
          "        return all(key in config for key in required)",
          "    ",
          "    def initialize_from_config(self, config_path: Path):",
          "        \"\"\"Initialize agent from configuration file.\"\"\"",
          "        config = self.load_config(config_path)",
          "        if not self.validate_config(config):",
          "            raise ValueError('Invalid config')",
          "        self._apply_config(config)",
          "",
          "# Test verifies single responsibility",
          "def test_load_config_reads_json_from_file(self, tmp_path):",
          "    config_file = tmp_path / 'config.json'",
          "    config_file.write_text('{\"name\": \"bot\"}')",
          "    ",
          "    agent = Agent()",
          "    config = agent.load_config(config_file)",
          "    ",
          "    assert config == {'name': 'bot'}"
        ]
      },
      "dont": {
        "description": "Functions doing multiple things",
        "content": [
          "# DON'T: Function does multiple unrelated things",
          "class Agent:",
          "    def setup(self, config_path: Path):",
          "        # WRONG - loads, validates, initializes, AND logs",
          "        config = json.loads(config_path.read_text())",
          "        if 'name' not in config:",
          "            raise ValueError('Invalid')",
          "        self.name = config['name']",
          "        self.workspace = Path(config['workspace'])",
          "        logger.info(f'Agent {self.name} initialized')  # Side effect!",
          "        self._send_metrics()  # Hidden side effect!",
          "        return config  # Mixed responsibility",
          "",
          "# Test reveals the problem - too many concerns",
          "def test_setup(self, tmp_path, mock_logger, mock_metrics):",
          "    # WRONG - test needs to verify too many unrelated things",
          "    config_file = tmp_path / 'config.json'",
          "    config_file.write_text('{\"name\": \"bot\", \"workspace\": \"/tmp\"}')",
          "    ",
          "    agent = Agent()",
          "    result = agent.setup(config_file)",
          "    ",
          "    assert agent.name == 'bot'  # Config loading",
          "    assert agent.workspace == Path('/tmp')  # Config parsing",
          "    mock_logger.info.assert_called()  # Logging",
          "    mock_metrics.assert_called()  # Metrics",
          "    assert result == {'name': 'bot', 'workspace': '/tmp'}  # Return value",
          "    # TOO MANY RESPONSIBILITIES!"
        ]
      }
    },
    {
      "do": {
        "description": "Separate business logic from side effects",
        "content": [
          "# Production Code - Pure business logic",
          "class ConfigValidator:",
          "    def validate(self, config: dict) -> ValidationResult:",
          "        \"\"\"Pure validation logic - no side effects.\"\"\"",
          "        errors = []",
          "        if 'name' not in config:",
          "            errors.append('Missing name')",
          "        if 'workspace_root' not in config:",
          "            errors.append('Missing workspace_root')",
          "        return ValidationResult(is_valid=len(errors) == 0, errors=errors)",
          "",
          "# Side effects in separate functions",
          "class Agent:",
          "    def initialize_with_logging(self, config: dict):",
          "        \"\"\"Initialize agent and log the action.\"\"\"",
          "        result = self._initialize(config)  # Pure logic",
          "        self._log_initialization(config)  # Side effect",
          "        return result",
          "",
          "# Tests are simple - test logic separately from side effects",
          "def test_validate_returns_errors_for_missing_fields(self):",
          "    validator = ConfigValidator()",
          "    result = validator.validate({'name': 'bot'})",
          "    ",
          "    assert not result.is_valid",
          "    assert 'Missing workspace_root' in result.errors"
        ]
      },
      "dont": {
        "description": "Mix business logic with side effects",
        "content": [
          "# DON'T: Mix logic and side effects",
          "class Agent:",
          "    def validate_and_log(self, config: dict) -> bool:",
          "        # WRONG - validation mixed with logging",
          "        logger.info('Validating config')  # Side effect",
          "        is_valid = 'name' in config",
          "        if is_valid:",
          "            logger.info('Config valid')  # Side effect",
          "            self._send_metrics('valid_config')  # Side effect",
          "        else:",
          "            logger.error('Config invalid')  # Side effect",
          "        return is_valid",
          "",
          "# Test is forced to mock side effects",
          "def test_validate(self, mock_logger, mock_metrics):",
          "    # WRONG - can't test logic without mocking side effects",
          "    agent = Agent()",
          "    result = agent.validate_and_log({'name': 'bot'})",
          "    # Test is fragile and coupled to logging implementation"
        ]
      }
    }
  ]
}


