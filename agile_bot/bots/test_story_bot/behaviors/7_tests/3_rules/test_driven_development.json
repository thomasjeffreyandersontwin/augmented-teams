{
  "description": "Follow Test-Driven Development (TDD) with RED-GREEN-REFACTOR cycle. Write failing test FIRST that describes desired behavior. Write minimal production code to pass test. Refactor both test and production code while keeping tests green. Tests drive API design and production code structure.",
  "examples": [
    {
      "do": {
        "description": "RED-GREEN-REFACTOR cycle",
        "content": [
          "# PHASE 1: RED - Write failing test first",
          "def test_agent_loads_config_from_file(self, tmp_path):",
          "    \"\"\"Agent loads configuration from JSON file.\"\"\"",
          "    # Given: Config file exists",
          "    config_file = tmp_path / 'config.json'",
          "    config_file.write_text('{\"name\": \"story_bot\"}')",
          "    ",
          "    # When: Agent loads config",
          "    agent = Agent()",
          "    config = agent.load_config(config_file)  # Method doesn't exist yet!",
          "    ",
          "    # Then: Config is loaded",
          "    assert config['name'] == 'story_bot'",
          "    # RUN TEST - FAILS with AttributeError: 'Agent' has no 'load_config'",
          "",
          "# PHASE 2: GREEN - Write minimal code to pass",
          "class Agent:",
          "    def load_config(self, config_path: Path) -> dict:",
          "        \"\"\"Load configuration from file.\"\"\"",
          "        return json.loads(config_path.read_text())",
          "    # RUN TEST - PASSES!",
          "",
          "# PHASE 3: REFACTOR - Improve while keeping tests green",
          "class Agent:",
          "    def load_config(self, config_path: Path) -> dict:",
          "        \"\"\"Load configuration from JSON file.\"\"\"",
          "        self._validate_file_exists(config_path)",
          "        return self._parse_json(config_path)",
          "    ",
          "    def _validate_file_exists(self, path: Path):",
          "        if not path.exists():",
          "            raise FileNotFoundError(f'Config not found: {path}')",
          "    ",
          "    def _parse_json(self, path: Path) -> dict:",
          "        try:",
          "            return json.loads(path.read_text())",
          "        except json.JSONDecodeError as e:",
          "            raise ValueError(f'Invalid JSON: {e}')",
          "    # RUN TEST - STILL PASSES! Code is cleaner."
        ]
      },
      "dont": {
        "description": "Write production code before tests",
        "content": [
          "# DON'T: Write production code first",
          "class Agent:",
          "    def load_config(self, config_path: Path) -> dict:",
          "        \"\"\"Load configuration.\"\"\"",
          "        # WRONG - writing code without test!",
          "        if not config_path.exists():",
          "            raise FileNotFoundError()",
          "        content = config_path.read_text()",
          "        return json.loads(content)",
          "    # Then write test later... BAD!",
          "",
          "# DON'T: Skip refactoring step",
          "class Agent:",
          "    def load_config(self, config_path: Path) -> dict:",
          "        # WRONG - test passes but code is messy",
          "        if not config_path.exists(): raise FileNotFoundError()",
          "        c = config_path.read_text()",
          "        try: d = json.loads(c)",
          "        except: raise ValueError()",
          "        return d",
          "    # Test passes but code is bad! Need refactoring step!"
        ]
      }
    },
    {
      "do": {
        "description": "Tests drive API design",
        "content": [
          "# RED: Write test that describes desired API",
          "def test_agent_factory_creates_configured_agent(self, tmp_path):",
          "    \"\"\"Factory creates agent with configuration.\"\"\"",
          "    # Given: Configuration exists",
          "    config = {'name': 'story_bot', 'workspace': str(tmp_path)}",
          "    ",
          "    # When: Factory creates agent with config",
          "    # Design the API we WANT through the test",
          "    factory = AgentFactory(workspace_root=tmp_path)",
          "    agent = factory.create_agent_with_config(config)",
          "    ",
          "    # Then: Agent is configured",
          "    assert agent.name == 'story_bot'",
          "    assert agent.workspace_root == tmp_path",
          "    # This test DESIGNS the API - clean, explicit dependencies",
          "",
          "# GREEN: Implement the API designed by test",
          "class AgentFactory:",
          "    def __init__(self, workspace_root: Path):",
          "        self._workspace_root = workspace_root",
          "    ",
          "    def create_agent_with_config(self, config: dict) -> Agent:",
          "        return Agent(",
          "            name=config['name'],",
          "            workspace_root=Path(config['workspace'])",
          "        )",
          "    # Implementation follows the design from test"
        ]
      },
      "dont": {
        "description": "Tests that adapt to bad API design",
        "content": [
          "# DON'T: Write test that accepts bad design",
          "def test_agent_creation(self):",
          "    # WRONG - test accepts global singleton pattern",
          "    agent = Agent.get_instance('story_bot')",
          "    agent.set_workspace('/tmp')  # Mutable state!",
          "    agent.load_config()  # Where does config come from?",
          "    # Test doesn't drive good design - it enables bad design!",
          "",
          "# DON'T: Implement API without thinking about tests",
          "class Agent:",
          "    _instance = None",
          "    ",
          "    @classmethod",
          "    def get_instance(cls, name=None):",
          "        # WRONG - singleton, hidden state, hard to test",
          "        if cls._instance is None:",
          "            cls._instance = Agent()",
          "        if name:",
          "            cls._instance.name = name",
          "        return cls._instance",
          "    # If you write test first, you'd never design this API!"
        ]
      }
    },
    {
      "do": {
        "description": "Write multiple tests as you add features",
        "content": [
          "# RED #1: First test - basic loading",
          "def test_load_config_reads_json_from_file(self, tmp_path):",
          "    config_file = tmp_path / 'config.json'",
          "    config_file.write_text('{\"name\": \"bot\"}')",
          "    agent = Agent()",
          "    config = agent.load_config(config_file)",
          "    assert config == {'name': 'bot'}",
          "",
          "# GREEN #1: Implement basic loading",
          "class Agent:",
          "    def load_config(self, path: Path) -> dict:",
          "        return json.loads(path.read_text())",
          "",
          "# RED #2: Second test - error handling",
          "def test_load_config_raises_when_file_missing(self):",
          "    agent = Agent()",
          "    with pytest.raises(FileNotFoundError):",
          "        agent.load_config(Path('missing.json'))",
          "",
          "# GREEN #2: Add error handling",
          "class Agent:",
          "    def load_config(self, path: Path) -> dict:",
          "        if not path.exists():",
          "            raise FileNotFoundError(f'Config not found: {path}')",
          "        return json.loads(path.read_text())",
          "",
          "# RED #3: Third test - invalid JSON",
          "def test_load_config_raises_when_json_invalid(self, tmp_path):",
          "    config_file = tmp_path / 'bad.json'",
          "    config_file.write_text('not json')",
          "    agent = Agent()",
          "    with pytest.raises(ValueError, match='Invalid JSON'):",
          "        agent.load_config(config_file)",
          "",
          "# GREEN #3: Handle invalid JSON",
          "class Agent:",
          "    def load_config(self, path: Path) -> dict:",
          "        if not path.exists():",
          "            raise FileNotFoundError(f'Config not found: {path}')",
          "        try:",
          "            return json.loads(path.read_text())",
          "        except json.JSONDecodeError as e:",
          "            raise ValueError(f'Invalid JSON: {e}')",
          "",
          "# REFACTOR: Now refactor with all tests passing",
          "# Each test builds on previous, tests stay green throughout"
        ]
      },
      "dont": {
        "description": "Try to handle all cases in one test",
        "content": [
          "# DON'T: One giant test for everything",
          "def test_load_config_everything(self, tmp_path):",
          "    # WRONG - testing too many scenarios at once",
          "    # Test 1: File missing",
          "    with pytest.raises(FileNotFoundError):",
          "        Agent().load_config(Path('missing.json'))",
          "    ",
          "    # Test 2: Invalid JSON",
          "    bad_file = tmp_path / 'bad.json'",
          "    bad_file.write_text('not json')",
          "    with pytest.raises(ValueError):",
          "        Agent().load_config(bad_file)",
          "    ",
          "    # Test 3: Valid config",
          "    good_file = tmp_path / 'good.json'",
          "    good_file.write_text('{\"name\": \"bot\"}')",
          "    config = Agent().load_config(good_file)",
          "    assert config == {'name': 'bot'}",
          "    ",
          "    # WRONG - too many scenarios! Hard to understand failure!",
          "    # Split into separate tests, implement incrementally!"
        ]
      }
    }
  ]
}


