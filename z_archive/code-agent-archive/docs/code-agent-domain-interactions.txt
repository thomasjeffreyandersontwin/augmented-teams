FUNCTIONAL PURPOSE: Make AI behavior management self-maintaining through structured validation, deployment, and consistency checking

This document describes business scenarios showing how code-agent domain concepts interact to fulfill behavior management workflows.

===================================================================================================
CROSS-DOMAIN INTERACTIONS
===================================================================================================

STRUCTURE ↔ DEPLOYMENT:
- Deployment requires valid Structure (validated before sync)
- Structure Validation identifies syncable files by Pattern Matching
- Repair creates missing files that Deployment will sync

VALIDATION ↔ REPAIR:
- Validation identifies structure issues
- Repair addresses issues automatically
- Repair output validated before completion

INDEXING ↔ CONFIGURATION DISCOVERY:
- Indexing uses Configuration Discovery to find deployed behaviors
- Configuration Discovery filters by deployment status
- Indexes record discovery results with timestamps

CONSISTENCY ANALYSIS ↔ SEMANTIC ANALYSIS:
- Consistency Analysis uses Semantic Analysis for overlap detection
- Semantic Analysis compares behavior content using OpenAI Function Calling
- Analysis results surfaced for human review

===================================================================================================
SCENARIO 1: VALIDATE BEHAVIOR STRUCTURE
===================================================================================================

TRIGGER: User invokes structure validation command

ACTORS:
- Structure
- Configuration Discovery
- Pattern Matching
- Content Analysis
- Relationships

FLOW:

1. **User** invokes validation command
   → Passes control to **Command**
   
2. **Command** invokes **Runner** (Code)
   → **Code** (Configuration Discovery) locates Features with deployed behaviors
   → **Code** (Structure) prepares validation scope
   → Returns Feature directories to Command
   
3. **Code** (Structure) scans each Feature directory
   → **Code** (Pattern Matching) validates file naming conventions
   → **Code** categorizes files: Rules, Commands, Runners, MCPs
   → **Code** skips excluded files (behavior.json, index files, documentation)

4. **Code** (Pattern Matching) checks each file against naming pattern
   → Identifies violations: invalid patterns, verb suffixes on rules
   → Records issues with file path and violation type

5. **Code** (Relationships) validates relationships
   → For each Rule: Checks for matching Command files in same directory
   → For each Command: Validates Rule reference and Runner reference sections present
   → Checks for deprecated sections (AI Usage, Code Usage, Implementation)
   → Records missing relationships and deprecated patterns

6. **Code** (Content Analysis) parses file contents
   → Rules: Verifies "When/then" format (after frontmatter)
   → Rules: Checks for "Executing Commands" section
   → Commands: Checks for "Rule", "Runner", and "Steps" sections
   → Records documentation issues and missing sections

7. **Code** handles Specialized Behaviors
   → For Features with isSpecialized flag in behavior.json
   → Exempts reference files and specialized rules from Pattern Matching check
   → Validates base rules and specialized rules separately
   
8. **Runner** returns validation results to **Command**
   → **Command** presents report to **User**

9. **User** reviews validation report and decides next steps
   → Identifies critical violations requiring immediate attention
   → Prioritizes issues by severity and impact
   → Decides between automated repair or manual intervention
   → Passes feedback to **AI Agent** if clarification needed

10. **AI Agent** assists with issue resolution planning
    → Reviews validation violations and suggests remediation approach
    → Recommends using automated Repair for structure issues
    → Proposes manual fixes for complex content quality issues
    → Helps prioritize fixes based on impact

BUSINESS RULES:
- Naming pattern: <feature>-<behavior-name>-<type>.<ext>
- Rules must not have verb suffixes
- Commands may have optional verb suffixes
- Each Rule requires at least one matching Command in same directory
- Commands must reference their Rule and Runner (if applicable)
- Rules must start with "When" condition (after frontmatter)
- Rules must list executing commands
- Commands must include Steps section (not deprecated AI Usage/Code Usage)
- Specialized behaviors follow different naming patterns (declared in behavior.json)
- Documentation directories always excluded
- Index and runner files excluded from validation

RESULT: Validation report listing structure issues by Feature and file, with suggested fixes

===================================================================================================
SCENARIO 2: REPAIR BEHAVIOR STRUCTURE
===================================================================================================

TRIGGER: User invokes structure repair command after validation identifies issues

ACTORS:
- Repair
- Structure
- Pattern Matching
- Content Analysis

FLOW:

1. **User** invokes repair command
   → Passes control to **Command**
   
2. **Command** invokes **Runner** (Code)
   → **Code** (Structure) runs Validation first
   → **Code** collects issues requiring fixes
   → **Code** (Repair) processes fix candidates

3. **Code** (Repair) creates missing Command files
   → For Rules without matching Commands
   → Generates Command file in same directory
   → Applies Pattern Matching: <feature>-<behavior-name>-cmd.md
   → Scaffolds standard Command structure with sections

4. **Code** (Repair) adds missing sections
   → Content Analysis identifies missing sections
   → Adds required documentation headers
   → Rules: Adds "Executing Commands" section if missing
   → Commands: Adds "Rule", "Runner", "Steps" sections if missing

5. **Code** (Repair) removes deprecated sections
   → Removes "AI Usage" and "Code Usage" sections
   → Replaces with "Steps" section if not present
   → Removes "Implementation" section references

6. **Code** (Structure) re-runs Validation
   → Validates repaired files
   → Confirms fixes resolved issues
   
7. **Runner** returns repair results to **Command**
   → **Command** presents report to **User**
   → Reports remaining manual interventions needed

8. **User** reviews repair results and provides feedback
   → Identifies issues requiring manual intervention
   → Provides guidance on content quality improvements
   → Approves automated fixes or requests adjustments
   → Passes feedback to **AI Agent**

9. **AI Agent** assists with manual fixes
   → Reviews User feedback and remaining issues
   → Proposes content improvements for quality issues
   → Suggests structural adjustments beyond automated repairs
   → Implements approved changes with User confirmation

BUSINESS RULES:
- Automatic fixes only for structure issues (missing files, missing sections)
- Content quality issues require manual intervention
- Repairs follow same naming and structure conventions as validation
- All repairs validated before completion
- Specialized behaviors not auto-repaired (require manual handling)

RESULT: Repaired behavior files with structure compliance restored

===================================================================================================
SCENARIO 3: CREATE NEW BEHAVIOR
===================================================================================================

TRIGGER: User invokes behavior creation command with feature and behavior name

ACTORS:
- Creation
- Pattern Matching
- File System Operations

FLOW:

1. **User** invokes creation command with feature and behavior name
   → Passes control to **Command**
   
2. **Command** invokes **Runner** (Code)
   → **Code** (Creation) validates naming conventions
   → **Code** checks if Feature directory exists

3. **Code** (Creation) prepares directory
   → Creates Feature directory if needed
   → Creates behavior.json configuration file
   → Sets deployment status to false (draft by default)

4. **Code** (Creation) scaffolds Rule file
   → Generates Rule file
   → Applies Pattern Matching: <feature>-<behavior-name>-rule.mdc
   → Includes frontmatter with description and globs
   → Scaffolds "When/then" structure
   → Adds "Executing Commands" section placeholder
   → Adds "Tools" section placeholder if applicable

5. **Code** (Creation) scaffolds Command file
   → Generates Command file
   → Applies Pattern Matching: <feature>-<behavior-name>-cmd.md
   → Scaffolds required sections: Rule, Runner, MCP Servers, Steps
   → Includes usage examples and purpose statement
   → Links to Rule file

6. **Code** (Creation) scaffolds Runner file (optional)
   → If behavior requires automation
   → Generates Runner file: <feature>-runner.py
   → Includes Runner Guard to prevent direct execution
   → Includes main entry point with argument parsing
   → Scaffolds common utility functions

7. **Code** (Creation) links Relationships
   → Command references Rule file
   → Rule references Command file
   → Runner referenced in Command (if created)
   → Consistent naming prefix ensures discoverability via Pattern Matching
   
8. **Runner** returns creation results to **Command**
   → **Command** presents scaffolded files to **User**

9. **User** reviews scaffolded behavior files
   → Examines Rule file for correct When/then structure
   → Reviews Command steps for completeness
   → Verifies Runner scaffolding (if applicable)
   → Provides customization requirements to **AI Agent**

10. **AI Agent** assists with behavior customization
    → Helps refine Rule triggering conditions and guidelines
    → Suggests appropriate Steps for Command workflow
    → Proposes Runner functions based on automation needs
    → Customizes scaffolded content based on User feedback

BUSINESS RULES:
- New behaviors start as draft (deployed: false)
- All scaffolded files follow Pattern Matching conventions
- Rule-Command Relationships created automatically
- Runner files stay in Feature directory (never synced)
- Runner Guard required in all runners
- Consistent prefixes enable Pattern Matching-based discovery

RESULT: Complete behavior scaffold with Rule, Command, optional Runner, and configuration

===================================================================================================
SCENARIO 4: DEPLOY BEHAVIORS TO ACTIVE USE
===================================================================================================

TRIGGER: User invokes deployment sync command after updating behavior files

ACTORS:
- Deployment
- Configuration Discovery
- Sync Logic
- File System Operations
- Watcher Restart

FLOW:

1. **User** marks behaviors as deployed in behavior.json
   → **User** invokes sync command (all features or specific feature)
   → Passes control to **Command**

2. **Command** invokes **Runner** (Code)
   → **Code** (Deployment) prepares sync operation
   → **Code** (Configuration Discovery) scans for behavior.json files
   → **Code** filters Features by deployed status (deployed: true)
   → Returns list of Feature directories to sync

3. **Code** (Sync Logic) prepares target routing
   → Rules destination: .cursor/rules/
   → Commands destination: .cursor/commands/
   → MCP configs destination: .cursor/mcp/
   → Tasks destination: .vscode/tasks.json

4. **Code** (File System Operations) enumerates and filters files
   → For each Feature directory
   → Scans all files recursively
   → Applies Exclusion rules: documentation directories, behavior.json, runner files, index files
   → Checks for draft/experimental markers in file headers
   → Filters syncable files by extension

5. **Code** (Sync Logic) routes by extension
   → .mdc files → .cursor/rules/
   → .md files → .cursor/commands/
   → .json MCP files → .cursor/mcp/
   → .json task files → merged into .vscode/tasks.json
   → .py files → NOT synced (stay in Feature directory)

6. **Code** (File System Operations) checks timestamps
   → Compares source and destination modification times
   → Syncs only if source newer than destination
   → Force flag overrides timestamp check

7. **Code** (Sync Logic) merges MCP configurations
   → For existing MCP configs at destination
   → Loads both source and destination JSON
   → Merges configurations (source properties override)
   → Writes merged result

8. **Code** (File System Operations) synchronizes files
   → Copies files to deployment locations
   → Preserves modification timestamps
   → Reports sync status: synced, merged, skipped

9. **Code** (Watcher Restart) detects and restarts watchers
   → Checks synced Python files for *_watch() functions
   → Identifies active watcher processes
   → Restarts watchers to pick up code changes
   
10. **Runner** returns sync results to **Command**
    → **Command** presents sync report to **User**

BUSINESS RULES:
- Only Features with deployed: true are synced
- Runner files never synced (stay in Feature directory per Exclusion rules)
- Draft and experimental behaviors excluded per Exclusion rules
- Source must be newer than destination (unless forced)
- MCP configs merged by Sync Logic, not overwritten
- Task configs merged into single root file by Sync Logic
- Documentation directories excluded per Exclusion rules
- Watcher Restart automatically triggered after Python file sync
- Index files excluded per Exclusion rules

RESULT: Behaviors synchronized from development locations to active .cursor/ deployment, watchers restarted

===================================================================================================
SCENARIO 5: MAINTAIN BEHAVIOR INDEXES
===================================================================================================

TRIGGER: Behavior files added, updated, or deleted

ACTORS:
- Indexing
- Configuration Discovery
- File System Operations
- Index Structure
- Discovery Process

FLOW:

1. **User** invokes index update command
   → Passes control to **Command**
   
2. **Command** invokes **Runner** (Code)
   → **Code** (Indexing) prepares Discovery Process
   → **Code** determines scope (all features or specific feature)

3. **Code** (Configuration Discovery) discovers Features
   → Locates Features with deployed behaviors
   → Scans for behavior.json files with deployed: true
   → Returns list of Feature directories

4. **Code** (Discovery Process) discovers files
   → Scans each Feature directory
   → **Code** (File System Operations) uses iterdir() for direct scanning
   → Filters by extension: .mdc, .md, .py, .json
   → Applies exclusion patterns: behavior.json, consolidated runners, index files, documentation

5. **Code** (Discovery Process) collects metadata
   → For each discovered file
   → Extracts feature name from parent directory
   → Records file name, type (extension), full path
   → **Code** (File System Operations) captures modification timestamp for freshness tracking

6. **Code** (Index Structure) assembles index
   → Creates Entry Properties for each file
   → Entry Properties: feature, file name, type, path, modified timestamp
   → Groups entries by Feature
   → Calculates total behavior count

7. **Code** (Index Structure) updates Global Index
   → Writes Global Index to .cursor/behavior-index.json
   → Global Index properties: last updated timestamp, total behaviors, features count, behaviors array
   → Format: JSON with human-readable structure

8. **Code** (Index Structure) updates Local index (if applicable)
   → Updates feature-local index: behaviors/<feature>/behavior-index.json
   → Contains only entries for that Feature
   
9. **Runner** returns index results to **Command**
   → **Command** presents index summary to **User**

BUSINESS RULES:
- Only deployed behaviors indexed (deployed: true per Configuration Discovery)
- Consolidated runners excluded (feature-level *-runner.py files per Discovery Process)
- Index files themselves excluded from Discovery Process
- Documentation directories excluded per Discovery Process
- Timestamps track file freshness via File System Operations
- Global Index aggregates all Features
- Local indexes scoped to single Feature
- AI agents must consult Index Structure to discover available behaviors
- Stale indexes prompt consistency check suggestion via Discovery Process

RESULT: Updated behavior indexes enabling discovery of available rules, commands, runners, and MCP tools

===================================================================================================
SCENARIO 6: ANALYZE BEHAVIOR CONSISTENCY
===================================================================================================

TRIGGER: Behaviors changed, suggesting potential overlaps or contradictions

ACTORS:
- Consistency Analysis
- Configuration Discovery
- Semantic Analysis
- OpenAI Function Calling
- Analysis Schema

FLOW:

1. **User** invokes consistency analysis command
   → Passes control to **Command**
   
2. **Command** invokes **Runner** (Code)
   → **Code** (Consistency Analysis) loads OPENAI_API_KEY from .env
   → **Code** prepares analysis scope (all features or specific feature)

3. **Code** (Configuration Discovery) discovers deployed behaviors
   → Locates Features with deployed behaviors
   → Collects all Rule and Command files from deployed Features
   → Excludes draft and experimental behaviors

4. **Code** (File System Operations) loads behavior content
   → For each Rule and Command file
   → Reads file contents
   → Extracts core behavior definition and guidance
   → Prepares content for semantic comparison

5. **Code** (Analysis Schema) defines function calling structure
   → Schema properties: overlaps array, contradictions array, summary
   → Overlap structure: behavior1, behavior2, similarity, difference, recommendation
   → Contradiction structure: behavior1, behavior2, context, contradiction, recommendation
   → Passes schema and content to AI

6. **Runner** invokes **OpenAI Function Calling** (AI-powered semantic analysis)
   → Uses OPENAI_API_KEY from .env file
   → Submits behavior contents with Analysis Schema
   → **AI** compares behaviors for semantic similarities and conflicts
   → Returns structured results to **Runner**

7. **Code** (Semantic Analysis) processes AI results
   → Identifies Analysis Types: overlaps (similar purpose, different approach)
   → Records similarity description and key differences
   → Suggests consolidation or clarification

8. **Code** (Semantic Analysis) identifies contradictions
   → Analysis Types: opposite guidance in same context
   → Records context where contradiction occurs
   → Describes nature of contradiction
   → Recommends resolution approach

9. **Code** (Semantic Analysis) identifies inconsistencies
   → Analysis Types: naming, tone, or scope mismatch
   → Notes patterns of inconsistency
   → Suggests standardization approaches

10. **Code** (Consistency Analysis) generates report
    → Formats structured results from Analysis Schema
    → Organizes by Analysis Types: overlaps, contradictions, inconsistencies
    → Includes summary of overall consistency health
    
11. **Runner** returns analysis results to **Command**
    → **Command** presents report to **User**

12. **User** reviews consistency analysis report
    → Examines overlaps for potential consolidation opportunities
    → Reviews contradictions for conflicts requiring resolution
    → Evaluates inconsistencies for standardization needs
    → Prioritizes issues by severity and impact
    → Provides resolution guidance to **AI Agent**

13. **AI Agent** assists with consistency issue resolution
    → For overlaps: Proposes consolidation strategy or clarification approach
    → For contradictions: Suggests which guidance should take precedence
    → For inconsistencies: Recommends standardization patterns
    → Helps implement approved resolutions with User confirmation
    → Updates affected behavior files based on User decisions

BUSINESS RULES:
- Analysis is advisory only (no automatic changes)
- Analysis Types defined:
  * Overlaps: Similar purpose, different approach
  * Contradictions: Opposite guidance, same context
  * Inconsistencies: Naming, tone, or scope mismatch
- Stylistic differences not treated as issues
- Intentional divergence respected (feature-specific exceptions)
- Results require human review before action
- OpenAI Function Calling loads OPENAI_API_KEY from .env file (behaviors/.env or root .env)
- Semantic Analysis uses structured output via Analysis Schema

RESULT: Consistency analysis report identifying overlaps, contradictions, and inconsistencies for human review

===================================================================================================
SCENARIO 7: VALIDATE SPECIALIZED BEHAVIORS
===================================================================================================

TRIGGER: User invokes specialization validation for hierarchical behavior patterns

ACTORS:
- Specialized Behaviors
- Structure
- Hierarchical Pattern
- Validation

FLOW:

1. **User** invokes specialization validation command for specific Feature
   → Passes control to **Command**
   
2. **Command** invokes **Runner** (Code)
   → **Code** (Specialized Behaviors) loads Feature configuration
   → **Code** checks for isSpecialized flag in behavior.json

3. **Code** (Structure) runs base structure validation
   → Runs standard Validation
   → Validates base naming patterns and Relationships
   → Identifies structure issues in common components

4. **Code** (Specialized Behaviors) checks hierarchical configuration
   → Loads specialization section from behavior.json
   → Identifies Hierarchical Pattern components:
     - Base rule file (common behavior definition)
     - Specialized rules (framework/language variations)
     - Reference files (examples)

5. **Code** (Validation) validates base rule
   → Checks base rule follows standard conventions
   → Verifies common behavior definition
   → Checks "Executing Commands" references

6. **Code** (Validation) validates specialized rules
   → For each specialized rule (Jest, Mamba, etc.)
   → Checks framework-specific extensions
   → Verifies reference to base rule
   → Ensures framework-specific guidance doesn't contradict base

7. **Code** (File System Operations) verifies reference files
   → Checks reference files exist
   → Validates reference files provide framework-specific examples
   → Confirms examples align with specialized rule guidance

8. **Code** (Hierarchical Pattern) checks pattern consistency
   → Checks DRY principles
   → Base rule contains common guidance
   → Specialized rules extend without duplication
   → Reference files demonstrate patterns
   
9. **Runner** returns validation results to **Command**
   → **Command** presents report to **User**

10. **User** reviews specialized behavior validation report
    → Examines base rule for completeness of common guidance
    → Reviews specialized rules for proper extensions
    → Verifies reference files provide appropriate examples
    → Identifies violations or inconsistencies
    → Requests **AI Agent** assistance for complex issues

11. **AI Agent** assists with hierarchical pattern fixes
    → Helps refactor base rule to extract common patterns
    → Suggests proper specialization boundaries
    → Proposes improvements to reference file examples
    → Ensures DRY principles maintained across hierarchy
    → Implements approved changes with User confirmation

BUSINESS RULES:
- Specialized Behaviors declared with isSpecialized: true in behavior.json
- Hierarchical Pattern structure:
  * Base rule: Common, framework-agnostic guidance
  * Specialized rules: Framework-specific extensions
  * Reference files: Examples, not active behaviors
- Specialized files exempt from standard Pattern Matching validation
- Specialization section in behavior.json declares: baseRule, specializedRules, referenceFiles
- Each specialized rule should reference base rule
- No contradictions between base and Specialized Behaviors guidance
- Examples in reference files must match Specialized Behaviors guidance
- Hierarchical Pattern enforces DRY principles

RESULT: Validation report confirming Hierarchical Pattern integrity for Specialized Behaviors

===================================================================================================
SCENARIO 8: DISCOVER CONFIGURATION AND FEATURE STATUS
===================================================================================================

TRIGGER: System needs to identify which Features are deployed and ready for use

ACTORS:
- Configuration Discovery
- File System Operations

FLOW:

1. **Code** (Configuration Discovery) initiates scan
   → Receives root directory (defaults to behaviors/)
   → Prepares to scan for behavior configurations

2. **Code** (File System Operations) scans directories
   → Scans for all behavior.json files
   → Uses recursive directory iteration
   → Returns list of configuration file paths

3. **Code** (Configuration Discovery) parses configurations
   → For each behavior.json found
   → Reads and parses JSON configuration
   → Extracts: deployed flag, feature name, description, specialization info

4. **Code** (Configuration Discovery) filters by deployment status
   → Filters configurations by deployed status
   → Returns only Features with deployed: true
   → Excludes draft and experimental Features

5. **Code** (Configuration Discovery) extracts feature names
   → For each deployed Feature
   → Extracts feature name from configuration
   → Defaults to directory name if not specified
   → Returns Feature directory path

6. **Code** (Configuration Discovery) assembles metadata
   → Assembles Feature information: name, path, configuration
   → Includes specialization metadata if applicable
   → Returns structured list for consuming processes (Sync, Index, Validation)

BUSINESS RULES:
- behavior.json marks a Feature directory
- deployed: true activates Feature for sync and indexing
- deployed: false keeps Feature in draft/development mode
- Feature name defaults to directory name if not specified
- Specialization configuration optional (isSpecialized, specialization section)
- Configuration Discovery used by Sync, Index, and Validation processes
- Direct directory iteration used (not glob patterns)

RESULT: List of deployed Features with configuration metadata for downstream processes

===================================================================================================
PATTERN-BASED SCENARIOS
===================================================================================================

SCENARIO 9: SUGGEST NEW BEHAVIOR FROM REPETITIVE PATTERNS
===================================================================================================

TRIGGER: AI detects repetitive task patterns in conversation history

ACTORS:
- Pattern-Based Suggestion
- Pattern Detector
- Conversation Analysis
- Behavior Creation

FLOW:

1. **AI Agent** (in conversation) monitors patterns
   → **AI Agent** (Pattern Detector) observes conversation patterns
   → **AI Agent** (Conversation Analysis) monitors for repetition
   → Identifies repetitive task sequences
   → Counts frequency of similar requests

2. **AI Agent** identifies automation opportunity
   → **AI Agent** (Conversation Analysis) evaluates pattern significance
   → Determines if pattern warrants reusable behavior
   → Assesses automation feasibility

3. **AI Agent** generates suggestion
   → **AI Agent** (Pattern-Based Suggestion) proposes new behavior
   → Describes task pattern and frequency to **User**
   → Outlines proposed behavior structure

4. **User** reviews suggestion and approves/rejects
   → If approved, **User** invokes creation command
   → Passes control to **Command**
   
5. **Command** invokes **Runner** (Code)
   → **Code** (Creation) generates new behavior files
   → Based on identified pattern
   → Includes Rule, Command, and optional Runner
   
6. **Runner** returns creation results to **Command**
   → **Command** presents scaffolded files to **User**

BUSINESS RULES:
- Pattern Detector requires multiple occurrences to trigger suggestion
- Pattern-Based Suggestion describes pattern, not automatic creation
- User must approve before Creation executes
- Suggested behaviors start as draft (deployed: false)
- Pattern significance evaluated by Conversation Analysis

RESULT: Pattern-Based Suggestion to create reusable behavior based on repetitive conversation patterns

===================================================================================================
KEY DESIGN PRINCIPLES
===================================================================================================

1. SELF-MAINTAINING SYSTEM
   - Validation identifies issues automatically
   - Repair fixes common issues without human intervention
   - Indexing keeps behavior discovery current
   - Consistency analysis surfaces potential conflicts

2. CLEAR SEPARATION OF CONCERNS
   - Structure: What behaviors consist of (Rule, Command, Runner, Relationships, Naming)
   - Validation: Checking compliance with Structure rules
   - Repair: Fixing structure issues automatically
   - Deployment: Moving behaviors from development to active use via Sync Logic
   - Indexing: Maintaining discoverability via Discovery Process and Index Structure
   - Consistency Analysis: Checking for semantic conflicts via Semantic Analysis

3. CONFIGURATION-DRIVEN BEHAVIOR
   - behavior.json controls deployment status (via Configuration Discovery)
   - Deployed flag gates Deployment and Indexing
   - isSpecialized flag modifies Validation rules for Hierarchical Pattern
   - Feature-level configuration keeps behaviors grouped

4. AUTOMATION WITH GUARDRAILS
   - Runner Guard enforces command-based invocation (require_command_invocation)
   - Repair limited to Structure issues
   - Consistency Analysis advisory only
   - Human review required for Semantic Analysis conflicts

5. PATTERN-BASED DISCOVERY
   - Pattern Matching conventions enable automated Discovery Process
   - Consistent prefixes link related files via Relationships
   - Extension-based routing via Sync Logic for Deployment
   - Index Structure provides searchable catalog

6. FRAMEWORK FLEXIBILITY
   - Hierarchical Pattern: Base rule defines common patterns
   - Specialized Behaviors extend for specific contexts (framework/language)
   - Validation respects Hierarchical Pattern structure
   - Reference files provide framework-specific examples

