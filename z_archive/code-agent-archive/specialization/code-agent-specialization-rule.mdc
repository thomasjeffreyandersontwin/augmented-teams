---
description: Specialized behavior patterns for framework/language variations
globs:
  - "**/*-rule.mdc"
  - "**/*-reference.md"
---

**When** a behavior needs framework-specific, language-specific, or context-specific variations,
**then** use specialized rule patterns to maintain DRY principles while supporting framework-specific implementations.

This pattern extends the base code-agent-behavior structure for behaviors that require variations across different contexts (frameworks, languages, platforms, etc.).

**Executing Commands:**
* `\code-agent-specialization` — Validate hierarchical behavior patterns for specialized behaviors

---

## Specialized Rule Pattern

**Base Rule** → **Specialized Rules** → **Reference Materials**

This three-tier pattern allows:
- Universal principles in base rules
- Framework/context-specific examples in specialized rules
- Comprehensive examples in reference materials

### 1. Base Rule (Framework-Agnostic)

**Purpose:** Define universal principles applicable across all contexts.

**Structure:**
```markdown
---
description: Framework-agnostic <behavior> practices
globs: ["<all-applicable-file-patterns>"]
alwaysApply: false
---

**When** <trigger condition>,
**then** <expected behavior>.

<Universal principles that apply regardless of framework>

## 1. Principle Category
**Do:** <universal guidance>
**Don't:** <universal anti-patterns>

## Framework-Specific Rules
For framework-specific examples and patterns:
* **Framework1**: See `<base>-<framework1>-rule.mdc`
* **Framework2**: See `<base>-<framework2>-rule.mdc`

For comprehensive examples and edge cases:
* **Framework1 Reference**: See `<base>-<framework1>-reference.md`
* **Framework2 Reference**: See `<base>-<framework2>-reference.md`
```

**Always:**
* Use broad glob patterns covering ALL variations
* Focus on principles, not implementation details
* Reference specialized rules at the end
* Keep examples minimal (if any) - prefer principles over examples
* Use `alwaysApply: false` (let specialized rules control application)
* Define conceptual examples that specialized rules will implement (e.g., "validate user input" not specific syntax)
* Keep principle categories consistent (these must match across all specialized rules)
* Use numbered sections (1, 2, 3) for easy cross-referencing

**Never:**
* Include framework-specific syntax
* Duplicate content that belongs in specialized rules
* Omit references to specialized rules
* Change principle numbering between versions

### 2. Specialized Rules (Framework-Specific)

**Purpose:** Apply base principles with concrete framework examples.

**Structure:**
```markdown
---
description: <Behavior> practices for <Framework/Language>
globs: ["<framework-specific-file-patterns>"]
alwaysApply: false
---

**When** <same trigger as base>,
**then** <same behavior as base> with <Framework>-specific patterns.

See `<base>-rule.mdc` for complete principles. This file provides <Framework>-specific examples.

For comprehensive examples and edge cases, see `<base>-<framework>-reference.md`.

---

## 1. Principle Category (matching base)

<Restate principle from base in one sentence>

**✅ DO:**
```<language>
<concrete framework example showing good practice>  // DO: <Which rule this demonstrates>
```

**❌ DON'T:**
```<language>
<concrete framework example showing anti-pattern>  // DON'T: <Which anti-pattern this shows>
```

<Repeat for each principle from base rule>

---

## Common <Framework> Patterns

<Framework-specific utilities, conventions, best practices>
```

**Always:**
* Reference base rule at top: "See `<base>-rule.mdc` for complete principles"
* Reference detailed materials: "For comprehensive examples, see `<framework>-reference.md`"
* Use same principle structure as base rule (same numbering, same categories)
* Use framework-specific glob patterns
* Provide concrete DO/DON'T examples in framework syntax
* Keep descriptions concise (one sentence principle restatement)
* Add end-of-line comments to examples showing which rule is being demonstrated
* Combine rules and examples in same section (keep context minimal)
* Ensure DO/DON'T examples are conceptually identical across all specialized rules for same principle
* Match example concepts to base rule (if base discusses "validation", specialized examples should too)
* Keep examples short (3-10 lines) - longer examples go in reference materials

**Never:**
* Duplicate full principle text from base (just restate briefly)
* Omit base rule reference
* Change principle numbering or categories from base rule
* Include hundreds of examples (use reference materials instead)
* Use different conceptual examples for same principle across frameworks
* Omit end-of-line comments explaining what rule is being demonstrated
* Separate rules from examples (keep them together for context)

### 3. Reference Materials (Comprehensive Examples)

**Purpose:** Provide extensive examples, edge cases, and detailed guidance that would clutter rules.

**Structure:**
```markdown
# <Framework> <Behavior> Reference

This document provides comprehensive examples for `<base>-<framework>-rule.mdc`.

## Table of Contents
1. [Principle Category](#principle-category)
   1.1. [Sub-principle](#sub-principle)
   1.2. [Another Sub-principle](#another-sub-principle)

## 1. Principle Category

### 1.1 Sub-principle

**Good Examples:**
<Multiple detailed examples>

**Bad Examples:**
<Multiple detailed anti-patterns>

**Edge Cases:**
<Tricky scenarios, gotchas, etc.>

<Continue for all principles with extensive detail>
```

**Always:**
* Use `.md` extension (NOT `.mdc` - these are not Cursor rules)
* Include table of contents for navigation
* Provide multiple examples per principle
* Include edge cases and gotchas
* Mirror structure of specialized rule
* Be comprehensive (this is the place for depth)

**Never:**
* Use `.mdc` extension (would auto-load as rule)
* Omit table of contents
* Replace specialized rules (these augment, not replace)

---

## File Organization

Keep all related files together in the feature directory:

```
behaviors/<behavior>/
  ├── <behavior>-rule.mdc                    # Base rule
  ├── <behavior>-<framework1>-rule.mdc       # Specialized rule 1
  ├── <behavior>-<framework1>-reference.md   # Reference material 1
  ├── <behavior>-<framework2>-rule.mdc       # Specialized rule 2
  ├── <behavior>-<framework2>-reference.md   # Reference material 2
  └── code-agent-behavior.json               # Feature deployment config
```

## Feature Configuration

Declare specialized structure explicitly in `code-agent-behavior.json`:

```json
{
  "deployed": true,
  "feature": "<behavior>",
  "description": "<Brief description>",
  "isSpecialized": true,
  "specialization": {
    "baseRule": "<behavior>-rule.mdc",
    "specializedRules": [
      "<behavior>-<framework1>-rule.mdc",
      "<behavior>-<framework2>-rule.mdc"
    ],
    "referenceFiles": [
      "<behavior>-<framework1>-reference.md",
      "<behavior>-<framework2>-reference.md"
    ]
  }
}
```

**Always:**
* Set `isSpecialized: true` for behaviors using this pattern
* List all expected files in the specialization section
* Include base rule, specialized rules, and reference files
* Keep file names consistent with actual files

**Never:**
* Omit the `isSpecialized` flag
* List files that don't exist
* Forget to update JSON when adding new specialized rules

This explicit declaration:
- Prevents misclassification of rule types
- Enables validation to detect missing files
- Documents the expected structure
- Makes specialization intent clear

---

## Validation

Specialized behaviors require additional validation beyond base structure checks:

### Base Validation (Automatic)
The standard `behavior-structure` command validates:
- File naming conventions
- Rule/command relationships
- Governance sections

### Specialized Validation (Feature-Specific)
Features using specialization patterns should add validation for:
- `isSpecialized` flag is set in config
- All declared files in specialization section exist
- Base rule exists and is properly referenced
- Specialized rules reference base correctly
- Reference materials are linked from specialized rules
- Glob patterns match actual files
- Principle categories match across base and specialized rules

**Implementation Pattern:**
```python
# In behaviors/<behavior>/<behavior>-validate-cmd.py

def validate_specialization_behavior(feature_dir):
    """Validate specialization rule pattern for <behavior>."""
    from pathlib import Path
    import json
    import sys
    
    # 1. Run base validation first
    sys.path.insert(0, str(Path("commands")))
    from code_agent_behavior_structure_cmd import behavior_structure
    
    base_result = behavior_structure("validate", feature_dir.name)
    issues = []
    
    # 2. Load and validate feature configuration
    config_file = feature_dir / "code-agent-behavior.json"
    if not config_file.exists():
        issues.append("Missing code-agent-behavior.json")
        return {"base": base_result, "specialized": issues}
    
    try:
        config = json.loads(config_file.read_text())
    except json.JSONDecodeError as e:
        issues.append(f"Invalid JSON in config: {e}")
        return {"base": base_result, "specialized": issues}
    
    # 3. Check if specialization pattern is declared
    if not config.get("isSpecialized"):
        # Not a specialized behavior, skip specialization checks
        return {"base": base_result, "specialized": []}
    
    specialization = config.get("specialization", {})
    
    # 4. Validate all declared files exist
    base_rule_name = specialization.get("baseRule")
    if base_rule_name:
        base_rule = feature_dir / base_rule_name
        if not base_rule.exists():
            issues.append(f"Missing declared base rule: {base_rule_name}")
    else:
        issues.append("Specialized behavior missing 'specialization.baseRule' in config")
    
    specialized_rules = specialization.get("specializedRules", [])
    for rule_name in specialized_rules:
        rule_file = feature_dir / rule_name
        if not rule_file.exists():
            issues.append(f"Missing declared specialized rule: {rule_name}")
        else:
            # Check that specialized rule references base
            content = rule_file.read_text()
            if base_rule_name and base_rule_name not in content:
                issues.append(f"{rule_name} doesn't reference base rule {base_rule_name}")
    
    reference_files = specialization.get("referenceFiles", [])
    for ref_name in reference_files:
        ref_file = feature_dir / ref_name
        if not ref_file.exists():
            issues.append(f"Missing declared reference file: {ref_name}")
        else:
            # Check that corresponding specialized rule links to reference
            # Extract framework from reference name (e.g., "bdd-jest-reference.md" -> "jest")
            framework = ref_name.replace(f"{feature_dir.name}-", "").replace("-reference.md", "")
            specialized_rule_name = f"{feature_dir.name}-{framework}-rule.mdc"
            
            if specialized_rule_name in specialized_rules:
                specialized_rule = feature_dir / specialized_rule_name
                if specialized_rule.exists():
                    content = specialized_rule.read_text()
                    if ref_name not in content:
                        issues.append(f"{specialized_rule_name} doesn't reference {ref_name}")
    
    return {"base": base_result, "specialized": issues}
```

---

## Commands

### Executing Commands:
* `\behavior-structure validate <feature>` — Validates base structure (naming, relationships, governance)
* `\specialization-validate <feature>` — Validates hierarchical pattern (base references, linking, consistency)
* `\<behavior>-validate` — Feature-specific validation (optional, extends generic validation)

### Implementation:
* `behavior_structure()` in `behaviors/code-agent/code-agent-runner.py` — Base validation (naming, relationships, governance)
* `validate_hierarchical_behavior()` in `behaviors/code-agent/code-agent-runner.py` — **Inherits** base validation, **extends** with hierarchical checks
* `<behavior>_validate()` — Feature-specific validation (optional, extends generic hierarchical validation)

**All behavior management commands follow this inheritance pattern:**

| Command | Base Behavior | Specialization Extension |
|---------|---------------|------------------------|
| **validate** | `behavior_structure()` validates naming, relationships, governance | `validate_specialization_behavior()` adds specialization config, cross-references, structural alignment |
| **sync** | `behavior_sync()` syncs all files to `.cursor/` | Specialization-aware: tracks base rule, specialized rules, reference files separately in index |
| **index** | `behavior_index()` indexes all behaviors | Specialization-aware: marks `isSpecialized`, groups by base/specialized/reference |
| **consistency** | `behavior_consistency()` checks for conflicts | Specialization-aware: validates principle alignment across base and specialized rules |
| **fix** | `behavior_structure("fix")` fixes naming, relationships | Specialization-aware: fixes broken cross-references, missing specialization declarations |

### AI Usage:
* AI should recognize specialization patterns automatically via `isSpecialized` flag
* When user references specialized rule, AI should know to check base rule
* AI can suggest which specialized rule applies based on file context (glob patterns)
* AI should suggest running `\specialization-validate` after modifying specialized behaviors
* AI should apply specialization awareness to all behavior management commands

### Code Usage:
* Base validation runs automatically via `behavior-structure validate`
* Generic specialization validation runs via `validate_specialization_behavior()`
* Feature-specific validation can extend generic validation for custom checks
* All commands (sync, index, consistency, fix) inherit base logic and extend for specialization patterns
* Both can be integrated into CI/CD pipelines and pre-commit hooks

---

## Example: BDD Behavior

### Files:
```
behaviors/bdd-behavior/
  ├── bdd-behavior-rule.mdc              # Base: framework-agnostic principles
  ├── bdd-jest-behavior-rule.mdc         # Specialized: Jest examples
  ├── bdd-jest-behavior-reference.md     # Reference: comprehensive Jest examples
  ├── bdd-mamba-behavior-rule.mdc        # Specialized: Mamba examples
  ├── bdd-mamba-behavior-reference.md    # Reference: comprehensive Mamba examples
  └── code-agent-behavior.json           # Deployment config
```

### Configuration:
```json
{
  "deployed": true,
  "feature": "bdd-behavior",
  "description": "BDD testing practices and standards for Jest and Mamba",
  "isSpecialized": true,
  "specialization": {
    "baseRule": "bdd-behavior-rule.mdc",
    "specializedRules": [
      "bdd-jest-behavior-rule.mdc",
      "bdd-mamba-behavior-rule.mdc"
    ],
    "referenceFiles": [
      "bdd-jest-behavior-reference.md",
      "bdd-mamba-behavior-reference.md"
    ]
  }
}
```

### Glob Pattern Strategy:
- **Base rule**: All test file patterns `["**/*.test.js", "**/*.spec.py", ...]`
- **Jest rule**: Only Jest patterns `["**/*.test.js", "**/*.spec.js", "**/*.test.tsx"]`
- **Mamba rule**: Only Python patterns `["**/*_test.py", "**/test_*.py"]`

This allows Cursor to:
1. Load appropriate specialized rule based on file type
2. User can reference base rule for universal principles
3. Reference materials available but not auto-loaded

---

## Extending to Other Patterns

This hierarchical pattern works for:

- **Framework variations**: React vs Vue vs Angular components
- **Language variations**: TypeScript vs JavaScript patterns
- **Platform variations**: Browser vs Node vs Edge workers
- **Environment variations**: Development vs Production configurations
- **Testing variations**: Unit vs Integration vs E2E tests

**Always:**
* Keep base rule focused on universal principles
* Create specialized rules for each major variation
* Provide reference materials for complex examples
* Validate hierarchical relationships
* Document the pattern in feature's README or docs
* Ensure conceptual alignment: same principle = same concept across all specialized versions
* Keep example complexity consistent: if Jest example has 5 lines, Mamba should too
* Maintain parallel structure: section 2.1 in base = section 2.1 in all specialized rules

**Never:**
* Create specialized rules for minor variations (use examples in base instead)
* Mix multiple variation types in one specialized rule (e.g., don't combine framework + platform)
* Forget to update base rule when adding new specialized rules
* Use completely different conceptual examples for same principle across frameworks
* Skip end-of-line comments in specialized rule examples
* Make specialized examples dramatically different in complexity or scope

## Cross-File Consistency Requirements

When maintaining hierarchical behaviors, ensure:

**Principle Alignment:**
* Same principle number = same concept across all files
* Base rule defines principle, specialized rules demonstrate it
* If base rule says "validate input", all specialized rules show input validation

**Example Alignment:**
* DO examples across all specialized rules demonstrate the same concept
* DON'T examples across all specialized rules show the same anti-pattern
* Example complexity should be similar (±3 lines)
* Comments clearly indicate which specific sub-rule is being demonstrated

**Structural Alignment:**
* Same section numbers in base and all specialized rules
* Same section headers (or equivalent phrasing)
* Same order of principles
* Same categorization of sub-principles

* Same order of principles
* Same categorization of sub-principles
