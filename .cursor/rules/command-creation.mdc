---
alwaysApply: true
description: Guidelines for building code functions to support commands and automate repetitive tasks
---

## Build Code Functions to Support Commands

Commands will often identify repetitive patterns or parameterized workflows. Build executable "command functions" in code to automate and support those workflows in real time.

### Core Principle

**Build code functions to support commands in real time** - Commands will often reveal what is repetitive and what requires parameterization. Build code functions to support those commands and add them to the commands folder.

### Analysis Process

1. **Identify repetitive patterns** - Commands will often reveal:
   - Tasks that are repeated frequently (ex: running tests in debug mode)
   - Workflows that require multiple steps (ex: logging into Foundry, opening character sheet, executing attack)
   - Operations that benefit from parameterization (ex: running specific test patterns, targeting specific characters)

2. **Determine what needs parameterization** - Analyze which aspects should be:
   - **Command-line arguments** - User-provided inputs that vary (ex: test pattern, character name)
   - **Configuration** - Settings that might need adjustment but are less frequently changed
   - **Environment detection** - Auto-detected values (ex: current working directory, existing browser instances)

3. **Design the function interface** - Create functions with:
   - Clear parameter names matching domain terminology
   - Sensible defaults for optional parameters
   - Helpful error messages for missing required inputs
   - Clear return values or side effects

### Implementation Guidelines

#### Function Placement

- **Global commands folder** - Place utility functions used across multiple domains in `commands/` at repo root (ex: `commands/mamba-debug.py`, `commands/playwright-debug.mjs`)
- **Domain-specific folder** - Place functions specific to a feature/domain in that domain's root folder (ex: `features/api/commands/api-test.py`)

#### Function Structure

Functions should:
- Use Python modules (`.py` files)
- Use `if __name__ == '__main__':` pattern for main execution
- Handle command-line arguments via `sys.argv` or `argparse`
- Provide clear console output for success/failure states
- Include error handling with helpful messages

### Workflow Patterns

Commands can be created through two different workflows depending on how the need is identified:

#### Workflow 1: Command-First Creation

**Scenario:** User needs to document or use a command before automation exists

1. **Build command documentation** - User creates `.cursor/commands/[name].md` file describing the command usage, parameters, examples, and integration context
2. **Use the documented command** - Use references the command in a chat or it is used as the result of a rule
3. **AI builds function** - AI creates the corresponding `commands/[name].py` function based on the documentation
4. **Request feedback** - AI prompts user for feedback on the implementation

**Example:** Command doc `mamba-debug.md` is created first, then when actually needed, AI builds `commands/mamba-debug.py`

#### Workflow 2: Pattern-Driven Creation

**Scenario:** AI detects repetitive work patterns during development

1. **Identify repetitive work** - AI notices repeated manual steps (ex: repeatedly running `python -m mamba --pattern "..."`)
2. **AI suggests command** - AI proposes creating a command function to automate the pattern and asks user for approval
3. **User approves with feedback** - User confirms and provides context, requirements, or modifications
4. **AI builds command file** - AI creates `.cursor/commands/[name].md` with usage, function definition, examples, and integration context
5. **AI builds command function** - AI creates `commands/[name].py` implementing the function based on the documentation
6. **AI prompts for feedback** - AI requests feedback on the implementation to refine if needed

**Example:** AI detects users frequently debugging tests with patterns, suggests `mamba-debug` command, user approves, AI creates both `.md` and `.py` files

### When to Build Commands

**Build commands when:**
- Commands reveal a workflow that's executed 3+ times
- Manual steps are error-prone or time-consuming
- Function would accept useful parameters
- Documentation would clarify usage patterns

**Don't build commands when:**
- One-off operations that won't repeat
- Simple aliases that don't add value
- Operations that require significant domain context each time

### Integration with Rules

- **Rule files** - Reference commands in rule documentation (ex: "Use `dev-mamba-test` command when debugging tests")
- **Command files** - Reference back to rules that motivated the command (ex: "This command supports patterns from `testing-approach.mdc`")
- **Workflow documentation** - Show how commands and rules create complete workflows

### Maintenance

- **Update commands when workflows evolve** - If workflows change, update corresponding commands
- **Consolidate similar commands** - If multiple commands do similar things, consider merging or creating shared utilities
- **Remove unused commands** - Archive or remove commands that are no longer used
