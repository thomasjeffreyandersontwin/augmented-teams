{
  "discovery": {
    "decisions_made": {
      "story_enumeration_approach": "System /back office - Deep dive into system internals and back-office components. Include detailed component interactions, data flows, and system-to-system communication. Show user ‚Üí component ‚Üí component interactions with full coverage.",
      "story_granularity": "System inner behavior and inner workings - Needed when elaboration of new complex architecture across unknown libraries and components is useful to elaborate. Focus on component level interactions."
    },
    "assumptions_made": {
      "component_coverage": "Must show full coverage of stories that demonstrate user going through a component and then component going to another component. Each story must show component-to-component interactions explicitly.",
      "foundry_integration": "Foundry VTT integration requires component-level detail due to proprietary nature and integration complexity with Mutants & Masterminds system"
    }
  },
  "arrange": {
    "decisions_made": {},
    "assumptions_made": {}
  },
  "exploration": {
    "decisions_made": {
      "acceptance_criteria_granularity": "Inner System - Focus on technical interaction points, system-to-system communication, and internal system behavior. CRITICAL: Be MORE granular wherever there is an explicit business rule being activated that changes state or is an important decision. Capture detailed acceptance criteria to be very explicit about which piece is doing what and when. If stories get too big/clunky, break them down later, but for now focus on getting complete stories done.",
      "acceptance_criteria_count": "Stop when criteria capture a full back-and-forth (user-system-user). Ensures atomic and testable slices. However, be detailed about business rules, state changes, and important decisions even if it increases AC count. Stories are already small, so detailed ACs are acceptable.",
      "acceptance_criteria_consolidation": "Same logic, different data ‚Üí Consolidate (even if data differs significantly). It is OK if acceptance criteria get more abstract or even if stories get more abstract, because this is about having reusable strategies and action strategies that can be intertwined. Focus on reusability - if the logic is very similar, use the same acceptance criteria regardless of data differences."
    },
    "assumptions_made": {
      "business_rule_detail": "Wherever there is an explicit business rule being activated that changes state or is an important decision, capture detailed acceptance criteria to be very explicit about which component is doing what and when",
      "story_size_flexibility": "Stories are already small. If they get too big/clunky with detailed ACs, break them down later. For now, focus on getting complete stories done with full detail",
      "reusability_focus": "Strategies and action strategies need to be reusable and intertwined. Acceptance criteria and stories can be more abstract to support reusability. Consolidate when logic is similar, even if data differs",
      "component_explicitness": "Be very explicit about which component is doing what and when, especially for business rules, state changes, and important decisions"
    }
  },
  "specification": {
    "decisions_made": {
      "specification_approach": "System-Centric - Defines system-to-system interactions with clear request/response templates, emphasizes reusable outlines and consolidates overlapping logic. Focus on Mob Manager wrapping/intercepting Foundry VTT systems.",
      "background_usage": "Yes - 3+ scenarios share Given steps. Multiple stories share setup (mob exists, combat tracker active, tokens on canvas).",
      "scenario_outline_usage": "Yes - formulas/calculations need multiple data points OR domain has named entities from source. Data variations matter (number of tokens, attack types, target types)."
    },
    "assumptions_made": {
      "one_story_at_a_time": "We are specifying all 6 Increment 1 stories together as they form a cohesive technical POC",
      "testable_ac": "Acceptance criteria must be testable, unambiguous, and executable",
      "gherkin_syntax": "Gherkin syntax (Given/When/Then) is preferred",
      "scenario_coverage": "Scenarios must cover happy path, edge cases, and error cases based on acceptance criteria",
      "story_documents": "Scenarios go in story documents (üìù *.md files), NOT feature documents",
      "given_state_language": "Given statements must use state-oriented language (not action-oriented)",
      "background_rules": "Background contains only Given/And steps (no When/Then)"
    }
  }
}