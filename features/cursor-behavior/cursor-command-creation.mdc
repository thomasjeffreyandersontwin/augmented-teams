---
alwaysApply: true
description: Guidelines for building code functions to support commands and automate repetitive tasks
---

## Build Code Functions to Support Commands

Commands will often identify repetitive patterns or parameterized workflows. Build executable "command functions" in code to automate and support those workflows in real time.

### Core Principle

**Build code functions to support commands in real time** - Commands will often reveal what is repetitive and what requires parameterization. Build code functions to support those commands and add them to the commands folder.

### Analysis Process

1. **Identify repetitive patterns** - Commands will often reveal:
   - Tasks that are repeated frequently (ex: running tests in debug mode)
   - Workflows that require multiple steps (ex: logging into Foundry, opening character sheet, executing attack)
   - Operations that benefit from parameterization (ex: running specific test patterns, targeting specific characters)

2. **Determine what needs parameterization** - Analyze which aspects should be:
   - **Command-line arguments** - User-provided inputs that vary (ex: test pattern, character name)
   - **Configuration** - Settings that might need adjustment but are less frequently changed
   - **Environment detection** - Auto-detected values (ex: current working directory, existing browser instances)

3. **Design the function interface** - Create functions with:
   - Clear parameter names matching domain terminology
   - Sensible defaults for optional parameters
   - Helpful error messages for missing required inputs
   - Clear return values or side effects

### Implementation Guidelines

#### Function Placement

- **Author at source** - Place command functions in `features/<feature>/cursor/<name>_cmd.py` (matches command doc pattern)
- **Synced to commands/** - Functions are automatically synced to `commands/<name>_cmd.py` via `@cursor-update-env`
- **Feature-local** - All command functions are authored in their feature's `cursor/` folder and synced for execution

#### Function Structure

Functions should:
- Use Python modules (`.py` files)
- Use `if __name__ == '__main__':` pattern for main execution
- Handle command-line arguments via `sys.argv` or `argparse`
- Provide clear console output for success/failure states
- Include error handling with helpful messages

### Workflow Patterns

Commands can be created through two different workflows depending on how the need is identified:

#### Workflow 1: Command-First Creation

**Scenario:** User needs to document or use a command before automation exists

1. **Create command documentation** - Use `@cursor-create-command` to scaffold `features/<feature>/cursor/<name>-cmd.md` describing the command usage, parameters, examples, and integration context
2. **Sync to environment** - Run `python commands/cursor-update-env_cmd.py --feature <feature>` to sync command doc to `.cursor/commands/`
3. **Use the documented command** - Command is now available via `@<name>` in Cursor chat
4. **AI builds function** - AI creates the corresponding `features/<feature>/cursor/<name>_cmd.py` function based on the documentation
5. **Sync function** - Run sync again to push function to `commands/`
6. **Request feedback** - AI prompts user for feedback on the implementation

**Example:** Command doc `tdd-mamba-debug-cmd.md` is created in `features/test-driven-development/cursor/`, synced, then when needed, AI builds `tdd-mamba-debug_cmd.py`

#### Workflow 2: Pattern-Driven Creation

**Scenario:** AI detects repetitive work patterns during development

1. **Identify repetitive work** - AI notices repeated manual steps (ex: repeatedly running `python -m mamba --pattern "..."`)
2. **AI suggests command** - AI proposes creating a command function to automate the pattern and asks user for approval, including which feature it belongs to
3. **User approves with feedback** - User confirms feature location and provides context, requirements, or modifications
4. **AI creates command scaffold** - AI uses `@cursor-create-command` to create `features/<feature>/cursor/<name>-cmd.md` with usage, function definition, examples, and integration context
5. **AI builds command function** - AI creates `features/<feature>/cursor/<name>_cmd.py` implementing the function based on the documentation
6. **AI syncs to environment** - AI runs sync command to deploy to `.cursor/commands/` and `commands/`
7. **AI prompts for feedback** - AI requests feedback on the implementation to refine if needed

**Example:** AI detects users frequently debugging tests with patterns, suggests `mamba-debug` command in `test-driven-development` feature, user approves, AI creates both `-cmd.md` and `_cmd.py` files in the feature's cursor folder

### When to Build Commands

**Build commands when:**
- Commands reveal a workflow that's executed 3+ times
- Manual steps are error-prone or time-consuming
- Function would accept useful parameters
- Documentation would clarify usage patterns

**Don't build commands when:**
- One-off operations that won't repeat
- Simple aliases that don't add value
- Operations that require significant domain context each time

### Integration with Rules

- **Rule files** - Reference commands in rule documentation (ex: "Use `@tdd-mamba-debug` command when debugging tests")
- **Command files** - Reference back to rules that motivated the command (ex: "This command supports patterns from `tdd-approach.mdc`")
- **Workflow documentation** - Show how commands and rules create complete workflows
- **Cross-references** - Follow `cursor-behavior-governance.mdc` for reference patterns between rules, commands, and MCP tools

### Maintenance

- **Update commands when workflows evolve** - If workflows change, update corresponding commands
- **Consolidate similar commands** - If multiple commands do similar things, consider merging or creating shared utilities
- **Remove unused commands** - Archive or remove commands that are no longer used
