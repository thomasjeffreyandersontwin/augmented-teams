# Containerization Architecture Documentation

This file contains the complete architecture documentation for the containerization feature.

## TABLE OF CONTENTS
// 1. CONTAINERIZATION ARCHITECTURE
//   1.1 Feature-First Cloud Architecture
//     1.1.1 Azure Container App deployment model
//     1.1.2 Feature-owned infrastructure pattern
//   1.2 Global Orchestration
//     1.2.1 Repository dispatch coordination
//     1.2.2 CI/CD workflow management
//   1.3 Container Templates
//     1.3.1 Dockerfile standards
//     1.3.2 Azure Container App configurations
//     1.3.3 Feature deployment workflows

# ðŸ§­ Augmented Teams GPT â€” Feature-First Cloud Architecture Overview

## ðŸŽ¯ Purpose

This architecture defines how Augmented Teams GPT is deployed to Azure using a feature-owned infrastructure model.
Each feature owns its own container, configuration, and deployment workflow, while a lightweight global orchestrator coordinates releases.

The goal is to ensure:

- **True modularity** â€” each feature can evolve, deploy, and scale independently
- **Seamless automation** â€” GitHub Actions handle builds and deployments
- **Full Azure alignment** â€” each service runs as its own Azure Container App
- **Composable orchestration** â€” the global layer coordinates, not controls

## ðŸ§± Design Principles

### Feature-Owned Infrastructure

Each feature defines its own:

- Source code
- Dockerfile (generated)
- `.azure/containerapp.yaml` (generated)
- GitHub Actions workflows (versioned in feature domain)
- Independent scaling and secrets

## ðŸŽ¯ Strategy

### GitHub Actions Versioning Strategy

**Feature Domain (Versioned):**
- Workflows stored in `features/[feature-name]/config/`
- Example: `features/git-integration/config/deploy-github-action.yml`
- Maintained in feature domain with version control

**Global Deployment (Runtime):**
- Copied to `.github/workflows/` during build
- Renamed with feature prefix: `[feature-name]-deploy.yml`
- Example: `.github/workflows/git-integration-deploy.yml`
- Prevents naming conflicts

**Build Process:**
- Workflows automatically copied from feature domains
- Feature prefix ensures no conflicts
- Version control lives in feature domain

### Common Coordination, Not Control

- **Global orchestrator** triggers feature deploys via `repository_dispatch`
- **Feature workflows** handle their own build, test, and deploy
- **No central control** - features are independent
- **Simplified coordination** - just dispatch to feature workflows

### Separation of Concerns
- **Common** â†’ CI/CD orchestration and shared settings
- **Feature** â†’ Logic, container, and deployment config
- **No cross-feature dependencies**

### Composable Cloud

Each feature runs as separate Azure Container App, collectively forming "Augmented Teams GPT" system.

### Common Feature Template

All features MUST follow the standardized template based on the proven git integration pattern:

**Required Files per Feature:**

### 1. Define the Service

| File | Purpose | Action |
|------|---------|-------|
| `main.py` | Main application entry point | deploy to target env |
| `config/gpt-action.yml` | GPT Action OpenAPI schema | **uploaded to ChatGPT prefixed as `[feature-name]-gpt-action.yml`** |
| `test.py` | Calls TestRunner for CODE/SERVICE/CONTAINER modes | run python test.py [CODE\|SERVICE\|CONTAINER] |

### 2. Configure the Service

| File | Purpose | Action |
|------|---------|-------|
| `config/feature-config.yaml` | feature specific configuration  | read all provisioning, build, and deployment config specific to the feature |
| `config/Dockerfile` | Container definition (generated by inject-config.py) | used by docker build to create container image |
| `config/.azure/containerapp.yaml` | Azure Container App config (generated by inject-config.py) | used by Azure deployment to deploy container app |

### 3. Build, Provision, Deploy the Service

| File | Purpose | Action |
|------|---------|-------|
| `config/deploy-github-action.yml` | GitHub Actions deployment workflow | **moved to `.github/workflows/` prefixed as `[feature-name]-deploy.yml`** |
| `config/provision-service.py` | Calls Provisioner.create(mode) to provision feature | run python provision-service.py [SERVICE\|CONTAINER] |
| `config/start-service.py` | Calls Provisioner.start(mode) based on mode arg | run python start-service.py [SERVICE\|CONTAINER] |


**Shared Classes (from containerization feature):**

| File | Purpose | Key Actions |
|------|---------|-------------|
| `provisioner.py` | Provision and start services with checks | â€¢ Creates CODE/SERVICE/CONTAINER provisioners<br>â€¢ Checks if provisioning needed<br>â€¢ Installs dependencies<br>â€¢ Checks if service running<br>â€¢ Returns dev/prod URL from config |
| `test.py` | Run tests in CODE/SERVICE/CONTAINER modes | â€¢ Uses provisioner to provision & start<br>â€¢ Gets test URL from provisioner<br>â€¢ Runs code tests or HTTP tests<br>â€¢ Auto-discovers routes |
| `inject-config.py` | Generate config from feature-config.yaml | â€¢ Reads feature-config.yaml<br>â€¢ Generates config/Dockerfile (with pip install from build.requirements)<br>â€¢ Generates .azure/containerapp.yaml |

**Usage:**
```python
# Provision a feature
python features/containerization/provisioner.py SERVICE features/git-integration

# Test a feature  
python features/containerization/test.py features/git-integration SERVICE
```

**Flow:**

1. **Test initialization:**
   - `test.py` imports `provisioner.py` from containerization feature
   - Calculates `containerization_path = feature_path.parent / "containerization"` (peer feature directory) 
   - Creates provisioner using `Provisioner.create(mode, feature_path, containerization_path)`

2. **Provision phase:**
   - Calls `provisioner.provision()` which:
     - Checks if provisioning needed (skips if up to date)
     - Reads `config/feature-config.yaml` via `provisioner._get_config()`
     - Installs dependencies via pip from build.requirements in config

3. **Start phase:**
   - Calls `provisioner.start()` which:
     - Reads `config/feature-config.yaml` via `provisioner._get_config()` for URL
     - Checks if service running (HTTP check on environment.url)
     - Imports `main.py` to start service (SERVICE mode)
     - Uses environment.development.url (SERVICE) or environment.production.url (CONTAINER)

4. **Test execution:**
   - `test.py` gets URL from `provisioner.get_test_url()` which reads config
   - `test.py` imports `main.py` to discover routes
   - Auto-discovers routes from `main.py` using introspection (scans FastAPI app.routes)

**Configuration generation (when dependencies change):**
- Run `inject-config.py` to generate:
  - `config/Dockerfile` (from build.requirements in feature-config.yaml)
  - `config/.azure/containerapp.yaml` (from all config sections)
- These are generated files, not modified directly

**Creating a New Feature:**
```bash
# Copy template
cp -r features/containerization/template-feature features/[your-feature-name]

# Update config/feature-config.yaml with your values
# Replace [FEATURE_NAME] placeholders

# Generate Dockerfile and Azure config
python features/containerization/inject-config.py features/[your-feature-name]

# Provision and test
python features/[your-feature-name]/config/provision-service.py SERVICE
python features/[your-feature-name]/test.py SERVICE
```


## ðŸ“‚ Directory Structure

```
repo/
â”œâ”€ features/
â”‚  â”œâ”€ git-integration/              # Example feature
â”‚  â”‚  â”œâ”€ main.py                    # Main application entry point
â”‚  â”‚  â”œâ”€ test.py                    # Calls TestRunner from containerization
â”‚  â”‚  â”œâ”€ config/
â”‚  â”‚  â”‚  â”œâ”€ feature-config.yaml      # Feature configuration (single source of truth)
â”‚  â”‚  â”‚  â”œâ”€ Dockerfile              # generated by inject-config.py
â”‚  â”‚  â”‚  â”œâ”€ .azure/
â”‚  â”‚  â”‚  â”‚  â””â”€ containerapp.yaml   # generated by inject-config.py
â”‚  â”‚  â”‚  â”œâ”€ provision-service.py    # Calls Provisioner.create()
â”‚  â”‚  â”‚  â”œâ”€ deploy-github-action.yml # Versioned workflow
â”‚  â”‚  â”‚  â””â”€ gpt-action.yml          # GPT Action schema
â”‚  â”‚  â””â”€ README.md
â”‚  â””â”€ containerization/             # Shared containerization logic
â”‚     â”œâ”€ inject-config.py           # Generates Dockerfile & Azure config
â”‚     â”œâ”€ provisioner.py             # Provisioner classes
â”‚     â”œâ”€ test.py                    # TestRunner class
â”‚     â”œâ”€ template-feature/          # Template for new features
â”‚     â”‚  â”œâ”€ main.py
â”‚     â”‚  â”œâ”€ test.py
â”‚     â”‚  â”œâ”€ README.md
â”‚     â”‚  â””â”€ config/
â”‚     â”‚     â”œâ”€ feature-config.yaml      # Single source of truth (with placeholders)
â”‚     â”‚     â”œâ”€ provision-service.py      # Calls Provisioner.create()
â”‚     â”‚     â”œâ”€ gpt-action.yml            # GPT Action schema template
â”‚     â”‚     â””â”€ deploy-github-action.yml  # Deployment workflow template
â”‚     â””â”€ architecture.md            # This file
â””â”€ .github/
   â””â”€ workflows/
      â”œâ”€ git-integration-deploy.yml  # Copied from feature
      â””â”€ common-deploy.yml          # Orchestrates all features
```


## âœ… Benefits Summary

| Benefit | Description |
|---------|-------------|
| Feature autonomy | Each feature has its own CI/CD and cloud deployment |
| Minimal coupling | Common orchestration doesn't break feature workflows |
| Scalability | Each container scales independently in Azure |
| Auditability | Infra changes live alongside feature code |
| Flexibility | Features can be deployed independently or all together |

## ðŸŽ¯ TL;DR â€” One-Sentence Summary

Build an Azure-based, feature-first cloud architecture where each feature owns its own container, deployment config, and GitHub workflow under `/features/<feature>`, while a top-level `common-deploy.yml` orchestrates all feature deploys using `repository_dispatch`.
