# Containerization Architecture Documentation

This file contains the complete architecture documentation for the containerization feature.

## TABLE OF CONTENTS
// 1. CONTAINERIZATION ARCHITECTURE
//   1.1 Feature-First Cloud Architecture
//     1.1.1 Azure Container App deployment model
//     1.1.2 Feature-owned infrastructure pattern
//   1.2 Global Orchestration
//     1.2.1 Repository dispatch coordination
//     1.2.2 CI/CD workflow management
//   1.3 Container Templates
//     1.3.1 Dockerfile standards
//     1.3.2 Azure Container App configurations
//     1.3.3 Feature deployment workflows

# ðŸ§­ Augmented Teams GPT â€” Feature-First Cloud Architecture Overview

## ðŸŽ¯ Purpose

This architecture defines how Augmented Teams GPT is deployed to Azure using a feature-owned infrastructure model.
Each feature owns its own container, configuration, and deployment workflow, while a lightweight global orchestrator coordinates releases.

The goal is to ensure:

- **True modularity** â€” each feature can evolve, deploy, and scale independently
- **Seamless automation** â€” GitHub Actions handle builds and deployments
- **Full Azure alignment** â€” each service runs as its own Azure Container App
- **Composable orchestration** â€” the global layer coordinates, not controls

## ðŸŽ¯ Design Principles

### Feature-Owned Infrastructure

Each feature defines its own:

- Source code
- Configuration settings
- GitHub Actions workflows
- Dockerfile (generated)
- Azure settings (generated)

### Testing Strategy

**Two-Tier Testing Approach:**

1. **test.py - Plain Python Unit Tests**
   - Imports functions directly from `main.py`
   - Tests business logic without any service layer
   - Fast execution, no dependencies
   - Example: `def test_hello_world(): assert hello("World") == "Hello World!"`

2. **service-test.py - HTTP Integration Tests**
   - Tests via HTTP against running service
   - Covers the full stack: main.py â†’ service.py â†’ HTTP
   - Three modes:
     - SERVICE: Tests against local FastAPI service
     - CONTAINER: Tests against local Docker container
     - AZURE: Tests against production Azure Container Apps
   - Uses `service_test_base.py` for common infrastructure

**No Runtime Proxying**
- Old approach used complex `TestRunner` with runtime proxying
- New approach: direct function calls (test.py) + HTTP calls (service-test.py)
- Simpler, easier to debug, no magic

**Automated Generation**
- `generate-service-test.py` parses `test.py` to create `service-test.py`
- Infers HTTP endpoints and parameters from test.py
- Uses GPT with function calling for assertion generation

### GitHub Actions Versioning Strategy

**Feature Domain (Versioned):**
- Workflows stored in `features/[feature-name]/config/`
- Example: `features/git-integration/config/deploy-github-action.yml`
- Maintained in feature domain with version control

**Global Deployment (Runtime):**
- Copied to `.github/workflows/` during build
- Renamed with feature prefix: `[feature-name]-deploy.yml`
- Example: `.github/workflows/git-integration-deploy.yml`
- Prevents naming conflicts

**Build Process:**
- Workflows automatically copied from feature domains
- Feature prefix ensures no conflicts
- Version control lives in feature domain

### Common Coordination, Not Control

- **Global orchestrator** triggers feature deploys via `repository_dispatch`
- **Feature workflows** handle their own build, test, and deploy
- **No central control** - features are independent
- **Simplified coordination** - just dispatch to feature workflows

### Separation of Concerns
- **Common** â†’ CI/CD orchestration and shared settings
- **Feature** â†’ Logic, container, and deployment config
- **No cross-feature dependencies**

### Composable Cloud

Each feature runs as separate Azure Container App, collectively forming "Augmented Teams GPT" system.

### Common Feature Template

All features MUST follow the standardized template based on the proven git integration pattern:

**Required Files per Feature:**

### 1. Define the Service

| File | Purpose | Action |
|------|---------|-------|
| `main.py` | Core business logic (plain Python functions) | No service dependencies |
| `service.py` | FastAPI service that wraps main.py functions | HTTP API layer |
| `test.py` | Plain Python unit tests (calls main.py directly) | run python test.py |
| `service-test.py` | HTTP integration tests (calls service via HTTP) | run python service-test.py [SERVICE\|CONTAINER\|AZURE] |
| `config/gpt-action.yml` | GPT Action OpenAPI schema | **uploaded to ChatGPT prefixed as `[feature-name]-gpt-action.yml`** |

### 2. Configure the Service

| File | Purpose | Action |
|------|---------|-------|
| `config/feature-config.yaml` | feature specific configuration  | read all provisioning, build, and deployment config specific to the feature |
| `config/Dockerfile` | Container definition (generated by inject-config.py) | used by docker build to create container image |
| `config/.azure/containerapp.yaml` | Azure Container App config (generated by inject-config.py) | used by Azure deployment to deploy container app |

### 3. Build, Provision, Deploy the Service

| File | Purpose | Action |
|------|---------|-------|
| `config/deploy-github-action.yml` | GitHub Actions deployment workflow | **moved to `.github/workflows/` prefixed as `[feature-name]-deploy.yml`** |
| `config/provision-service.py` | Calls Provisioner.create(mode) to provision feature | run python provision-service.py [SERVICE\|CONTAINER\|AZURE] |


**Shared Classes (from containerization feature):**

| File | Purpose | Key Actions |
|------|---------|-------------|
| `provisioner.py` | Provision and start services with checks | â€¢ Creates CODE/SERVICE/CONTAINER/AZURE provisioners<br>â€¢ CODE: Plain Python, no service<br>â€¢ SERVICE: Local FastAPI service<br>â€¢ CONTAINER: Docker container locally<br>â€¢ AZURE: Deploys to Azure Container Apps<br>â€¢ Installs dependencies from build.requirements<br>â€¢ Returns dev/prod URL from config |
| `service_test_base.py` | Common test infrastructure | â€¢ Loads URLs from feature-config.yaml by mode<br>â€¢ Provides get_base_url() for service tests<br>â€¢ Provides run_service_tests() runner<br>â€¢ Handles provisioning/starting for SERVICE/CONTAINER<br>â€¢ Skips provisioning for AZURE (already deployed) |
| `inject-config.py` | Generate config from feature-config.yaml | â€¢ Reads feature-config.yaml<br>â€¢ Generates config/Dockerfile (with pip install from build.requirements)<br>â€¢ Generates .azure/containerapp.yaml |
| `generate-service-test.py` | Generate service-test.py from test.py | â€¢ Parses test.py functions<br>â€¢ Infers HTTP endpoints and parameters<br>â€¢ Generates service-test.py with HTTP calls<br>â€¢ Includes GPT helper for assertion generation |

**Usage:**
```bash
# Provision and deploy to Azure
python features/containerization/test-feature/config/provision-service.py AZURE

# Run plain Python unit tests (direct function calls)
python features/containerization/test-feature/test.py

# Run HTTP integration tests (SERVICE/CONTAINER/AZURE modes)
python features/containerization/test-feature/service-test.py SERVICE
python features/containerization/test-feature/service-test.py CONTAINER  
python features/containerization/test-feature/service-test.py AZURE
```

**Flow:**

1. **Test.py (Plain Python unit tests):**
   - Imports functions directly from `main.py`
   - Tests business logic without service layer
   - Example: `from main import hello; assert hello("World") == "Hello World!"`

2. **Service-test.py (HTTP integration tests):**
   - Uses `service_test_base.py` for common infrastructure
   - Calls `get_base_url(feature_path)` which reads `feature-config.yaml`
   - URL selection based on mode:
     - SERVICE mode â†’ `environment.development.url` (http://localhost:8000)
     - CONTAINER mode â†’ `environment.production.url` (https://...)
     - AZURE mode â†’ `environment.production.url` (Azure Container Apps URL)
   - Provisioning handled by `service_test_base.run_service_tests()`:
     - SERVICE: Provisions locally, starts FastAPI service
     - CONTAINER: Provisions locally, starts Docker container
     - AZURE: Skips provisioning (already deployed to Azure)

3. **Azure deployment (AZURE mode):**
   - Uses Azure CLI (`az` command) to deploy to Azure Container Apps
   - Requires ACR password in `ACR_PASSWORD` environment variable
   - Validates CPU/memory against Azure Container Apps tiers
   - **Valid CPU/Memory combinations:**
     | CPU | Memory |
     |-----|--------|
     | 0.25 | 0.5Gi |
     | 0.5 | 1.0Gi |
     | 0.75 | 1.5Gi |
     | 1.0 | 2.0Gi |
   - Minimum tier: 0.25 CPU, 0.5Gi memory
   - Default used: 0.25 CPU, 0.5Gi memory

**Configuration generation (when dependencies change):**
- Run `inject-config.py` to generate:
  - `config/Dockerfile` (from build.requirements in feature-config.yaml)
  - `config/.azure/containerapp.yaml` (from all config sections)
- These are generated files, not modified directly

**Creating a New Feature:**
```bash
# Copy template
cp -r features/containerization/test-feature features/[your-feature-name]

# Update config/feature-config.yaml with your values
# - Set feature name, description, version
# - Update azure.container_registry to your ACR
# - Configure build.requirements with your dependencies
# - Set environment URLs (development and production)

# Update main.py with your business logic functions
# Update service.py with your FastAPI routes
# Update test.py with your unit tests
# Update service-test.py with your HTTP integration tests

# Generate Dockerfile and Azure config
python features/containerization/inject-config.py features/[your-feature-name]

# Test locally
python features/[your-feature-name]/test.py
python features/[your-feature-name]/service-test.py SERVICE

# Test in container
python features/[your-feature-name]/service-test.py CONTAINER

# Deploy to Azure
$env:ACR_PASSWORD="your-password"; python features/[your-feature-name]/config/provision-service.py AZURE

# Test against production
python features/[your-feature-name]/service-test.py AZURE
```


## ðŸ“‚ Directory Structure

```
repo/
â”œâ”€ features/
â”‚  â”œâ”€ test-feature/                 # Example feature (completed)
â”‚  â”‚  â”œâ”€ main.py                    # Core business logic
â”‚  â”‚  â”œâ”€ service.py                 # FastAPI service
â”‚  â”‚  â”œâ”€ test.py                    # Plain Python unit tests
â”‚  â”‚  â”œâ”€ service-test.py            # HTTP integration tests
â”‚  â”‚  â”œâ”€ config/
â”‚  â”‚  â”‚  â”œâ”€ feature-config.yaml      # Single source of truth
â”‚  â”‚  â”‚  â”œâ”€ Dockerfile              # generated by inject-config.py
â”‚  â”‚  â”‚  â”œâ”€ provision-service.py    # Calls Provisioner.create()
â”‚  â”‚  â”‚  â””â”€ .azure/
â”‚  â”‚  â”‚     â””â”€ containerapp.yaml     # generated by inject-config.py
â”‚  â”‚  â””â”€ README.md
â”‚  â””â”€ containerization/             # Shared containerization logic
â”‚     â”œâ”€ provisioner.py             # CODE/SERVICE/CONTAINER/AZURE provisioners
â”‚     â”œâ”€ service_test_base.py        # Common test infrastructure
â”‚     â”œâ”€ inject-config.py           # Generates Dockerfile & Azure config
â”‚     â”œâ”€ generate-service-test.py    # Generates service-test.py from test.py
â”‚     â”œâ”€ test-feature/              # Example feature reference
â”‚     â””â”€ architecture.md            # This file
â””â”€ .github/
   â””â”€ workflows/
      â”œâ”€ test-feature-deploy.yml    # Copied from feature
      â””â”€ [other-feature]-deploy.yml
```


## âœ… Benefits Summary

| Benefit | Description |
|---------|-------------|
| Feature autonomy | Each feature has its own CI/CD and cloud deployment |
| Minimal coupling | Common orchestration doesn't break feature workflows |
| Scalability | Each container scales independently in Azure |
| Auditability | Infra changes live alongside feature code |
| Flexibility | Features can be deployed independently or all together |

## ðŸŽ¯ TL;DR â€” One-Sentence Summary

Build an Azure-based, feature-first cloud architecture where each feature owns its own container, deployment config, and GitHub workflow under `/features/<feature>`, while a top-level `common-deploy.yml` orchestrates all feature deploys using `repository_dispatch`.
