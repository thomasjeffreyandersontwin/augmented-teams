# Containerization Architecture Documentation

This file contains the complete architecture documentation for the containerization feature.

## TABLE OF CONTENTS
// 1. CONTAINERIZATION ARCHITECTURE
//   1.1 Feature-First Cloud Architecture
//     1.1.1 Azure Container App deployment model
//     1.1.2 Feature-owned infrastructure pattern
//   1.2 Global Orchestration
//     1.2.1 Repository dispatch coordination
//     1.2.2 CI/CD workflow management
//   1.3 Container Templates
//     1.3.1 Dockerfile standards
//     1.3.2 Azure Container App configurations
//     1.3.3 Feature deployment workflows

# ðŸ§­ Augmented Teams GPT â€” Feature-First Cloud Architecture Overview

## ðŸŽ¯ Purpose

This architecture defines how Augmented Teams GPT is deployed to Azure using a feature-owned infrastructure model.
Each feature owns its own container, configuration, and deployment workflow, while a lightweight global orchestrator coordinates releases.

The goal is to ensure:

- **True modularity** â€” each feature can evolve, deploy, and scale independently
- **Seamless automation** â€” GitHub Actions handle builds and deployments
- **Full Azure alignment** â€” each service runs as its own Azure Container App
- **Composable orchestration** â€” the global layer coordinates, not controls

## ðŸŽ¯ Design Principles

### Feature-Owned Infrastructure

Each feature defines its own:

- Source code
- Configuration settings
- GitHub Actions workflows
- Dockerfile (generated)
- Azure settings (generated)

### Testing Strategy

**Two-Tier Testing Approach:**

1. **test.py - Plain Python Unit Tests**
   - Imports functions directly from `main.py`
   - Tests business logic without any service layer
   - Fast execution, no dependencies
   - Example: `def test_hello_world(): assert hello("World") == "Hello World!"`

2. **service-test.py - HTTP Integration Tests**
   - Tests via HTTP against running service
   - Covers the full stack: main.py â†’ service.py â†’ HTTP
   - Three modes:
     - SERVICE: Tests against local FastAPI service
     - CONTAINER: Tests against local Docker container
     - AZURE: Tests against production Azure Container Apps
   - Uses `service_test_base.py` for common infrastructure


3. **Automated Generation**
- `generate-service-test.py` parses `test.py` to create `service-test.py`
- Infers HTTP endpoints and parameters from test.py
- Uses GPT with function calling for assertion generation

### GitHub Actions Deployment Strategy

**Single Central Workflow:**
- One workflow handles ALL feature deployments: `.github/workflows/feature-deploy.yml`
- Detects changed features from git history
- Runs `provision-service.py` for each changed feature
- No per-feature workflow duplication

**How It Works:**
1. User pushes changes to `behaviors/[feature-name]/*`
2. `feature-deploy.yml` workflow triggers automatically
3. Detects changed features by analyzing git diff
4. For each feature, calls `behaviors/[feature-name]/config/provision-service.py AZURE --always`
5. Provision script handles: Dockerfile generation, Docker build, Docker push to ACR, Azure deployment

### Common Coordination, Not Control

- **Single central workflow** (feature-deploy.yml) detects and deploys changed features
- **Per-feature deployment script** - each feature has provision-service.py script
- **Git-based detection** - analyzes git diff to find changed features


### Separation of Concerns
- **Common** â†’ CI/CD orchestration and shared settings
- **Feature** â†’ Logic, container, and deployment config
- **No cross-feature dependencies**

### Composable Cloud

Each feature runs as separate Azure Container App, collectively forming "Augmented Teams GPT" system.

### Common Feature Template

All features MUST follow the standardized template based on the proven git integration pattern:

**Required Files per Feature:**

### 1. Define the Service

| File | Purpose | Action |
|------|---------|-------|
| `main.py` | Core business logic (plain Python functions) | No service dependencies |
| `service.py` | FastAPI service that wraps main.py functions | HTTP API layer |
| `test.py` | Plain Python unit tests (calls main.py directly) | run python test.py |
| `service-test.py` | HTTP integration tests (calls service via HTTP) | run python service-test.py [SERVICE\|CONTAINER\|AZURE] |
| `gpt-action.yml` | GPT Action OpenAPI schema | **uploaded to ChatGPT prefixed as `[feature-name]-gpt-action.yml`** |

### 2. Configure the Service

| File | Purpose | Action |
|------|---------|-------|
| `config/feature-config.yaml` | feature specific configuration  | read all provisioning, build, and deployment config specific to the feature |
| `config/Dockerfile` | Container definition (generated by inject-config.py) | used by docker build to create container image |
| `config/.azure/containerapp.yaml` | Azure Container App config (generated by inject-config.py) | used by Azure deployment to deploy container app |

### 3. Build, Provision, Deploy the Service

| File | Purpose | Action |
|------|---------|-------|
| `config/provision-service.py` | Calls Provisioner.create(mode) to provision feature | run python provision-service.py [SERVICE\|CONTAINER\|AZURE] |


**Shared Classes (from containerization feature):**

| File | Purpose | Key Actions |
|------|---------|-------------|
| `provisioner.py` | Provision and start services with checks | â€¢ Creates CODE/SERVICE/CONTAINER/AZURE provisioners<br>â€¢ CODE: Plain Python, no service<br>â€¢ SERVICE: Local FastAPI service<br>â€¢ CONTAINER: Docker container locally<br>â€¢ AZURE: Deploys to Azure Container Apps<br>â€¢ Installs dependencies from build.requirements<br>â€¢ Returns dev/prod URL from config |
| `service_test_base.py` | Common test infrastructure | â€¢ Loads URLs from feature-config.yaml by mode<br>â€¢ Provides get_base_url() for service tests<br>â€¢ Provides run_service_tests() runner<br>â€¢ Handles provisioning/starting for SERVICE/CONTAINER<br>â€¢ Skips provisioning for AZURE (already deployed) |
| `inject-config.py` | Generate config from feature-config.yaml | â€¢ Reads feature-config.yaml<br>â€¢ Generates config/Dockerfile (with pip install from build.requirements)<br>â€¢ Generates .azure/containerapp.yaml |
| `generate-service-test.py` | Generate service-test.py from test.py | â€¢ Parses test.py functions<br>â€¢ Infers HTTP endpoints and parameters<br>â€¢ Generates service-test.py with HTTP calls<br>â€¢ Includes GPT helper for assertion generation |

**Usage:**
```bash
# Provision and deploy to Azure
python behaviors/test-feature/config/provision-service.py AZURE

# Run plain Python unit tests (direct function calls)
python behaviors/test-feature/test.py

# Run HTTP integration tests (SERVICE/CONTAINER/AZURE modes)
python behaviors/test-feature/service-test.py SERVICE
python behaviors/test-feature/service-test.py CONTAINER  
python behaviors/test-feature/service-test.py AZURE
```

**Development and Deployment Flow:**

1. **Make changes** to `main.py` or `service.py`
2. **Write tests** in `test.py` (plain Python)
3. **Generate service and service-test.py** using GPT functions (TODO - automated generation from main and test.py)
4. **Test locally in 3 modes:**
   - `python test.py` - CODE mode (plain Python)
   - `python service-test.py SERVICE` - SERVICE mode (local FastAPI service)
   - `python service-test.py CONTAINER` - CONTAINER mode (local Docker)
5. **Deploy to Azure - TWO OPTIONS:**
   
   **Option A: Automatic via GitHub Actions:**
   - Commit and push changes to `behaviors/[feature-name]/*`
   - `.github/workflows/feature-deploy.yml` triggers
   - Sets up environment: Docker, Python, Azure CLI (cached for speed)
   - Detects changed features via git diff
   - For each feature: runs `config/provision-service.py AZURE --always`
   
   **Option B: Manual deployment:**
   - Run `config/provision-service.py AZURE --always`

**Provision-service.py AZURE mode steps:**
1. Run `inject-config.py` to generate Dockerfile and Azure config
   - Generates `config/Dockerfile` from build.requirements in feature-config.yaml
   - Generates `config/.azure/containerapp.yaml` from all config sections
   - These are generated files, not modified directly
2. Build Docker image from Dockerfile
3. Push to Azure Container Registry (ACR)
4. Deploy to Azure Container Apps using `az containerapp`
5. Wait for deployment to be ready
6. Run tests against production URL

**Creating a New Feature:**
```bash
# Copy template
cp -r behaviors/test-feature behaviors/[your-feature-name]

# Update config/feature-config.yaml with your values
# - Set feature name, description, version
# - Update azure.container_registry to your ACR
# - Configure build.requirements with your dependencies
# - Set environment URLs (development and production)

# Update main.py with your business logic functions
# Update service.py with your FastAPI routes
# Update test.py with your unit tests
# Update service-test.py with your HTTP integration tests

# Generate Dockerfile and Azure config
python behaviors/containerization/inject-config.py behaviors/[your-feature-name]

# Test locally
python behaviors/[your-feature-name]/test.py
python behaviors/[your-feature-name]/service-test.py SERVICE

# Test in container
python behaviors/[your-feature-name]/service-test.py CONTAINER

# Deploy to Azure
$env:ACR_PASSWORD="your-password"; python behaviors/[your-feature-name]/config/provision-service.py AZURE

# Test against production
python behaviors/[your-feature-name]/service-test.py AZURE
```


## ðŸ“‚ Directory Structure

```
repo/
â”œâ”€ behaviors/
â”‚  â”œâ”€ test-feature/                 # Example feature (completed)
â”‚  â”‚  â”œâ”€ main.py                    # Core business logic
â”‚  â”‚  â”œâ”€ service.py                 # FastAPI service
â”‚  â”‚  â”œâ”€ test.py                    # Plain Python unit tests
â”‚  â”‚  â”œâ”€ service-test.py            # HTTP integration tests
â”‚  â”‚  â”œâ”€ config/
â”‚  â”‚  â”‚  â”œâ”€ feature-config.yaml      # Single source of truth
â”‚  â”‚  â”‚  â”œâ”€ Dockerfile              # generated by inject-config.py
â”‚  â”‚  â”‚  â”œâ”€ provision-service.py    # Calls Provisioner.create()
â”‚  â”‚  â”‚  â””â”€ .azure/
â”‚  â”‚  â”‚     â””â”€ containerapp.yaml     # generated by inject-config.py  
â”‚  â”‚  â””â”€ README.md
â”‚  â””â”€ containerization/             # Shared containerization logic
â”‚     â”œâ”€ provisioner.py             # CODE/SERVICE/CONTAINER/AZURE provisioners
â”‚     â”œâ”€ service_test_base.py        # Common test infrastructure
â”‚     â”œâ”€ inject-config.py           # Generates Dockerfile & Azure config
â”‚     â”œâ”€ generate-service-test.py    # Generates service-test.py from test.py
â”‚     â””â”€ architecture.md            # This file
â””â”€ .github/
   â””â”€ workflows/
      â””â”€ feature-deploy.yml          # Single workflow for all feature deployments
```


## âœ… Benefits Summary

| Benefit | Description |
|---------|-------------|
| Feature autonomy | Each feature has its own CI/CD and cloud deployment |
| Minimal coupling | Common orchestration doesn't break feature workflows |
| Scalability | Each container scales independently in Azure |
| Auditability | Infra changes live alongside feature code |
| Flexibility | Features can be deployed independently or all together |

## ðŸŽ¯ TL;DR â€” One-Sentence Summary

Build an Azure-based, feature-first cloud architecture where each feature owns its own container, deployment config, and GitHub workflow under `/behaviors/<feature>`, while a top-level `common-deploy.yml` orchestrates all feature deploys using `repository_dispatch`.
