{
  "verbose_mode": false,
  "behaviors": {
    "code": {
      "order": 1,
      "guardrails": {
        "required_context": {
          "clarification_instructions": "CRITICAL: For the code behavior, you MUST ask the user these questions and wait for their explicit answers. DO NOT infer, assume, or proceed without user responses.\n\n**MANDATORY WORKFLOW - THIS STEP CAN NEVER BE SKIPPED:**\n1. Present each required question to the user clearly and explicitly in the chat window\n2. Wait for the user to answer each question\n3. **MANDATORY PRESENTATION STEP - NEVER SKIP:** After receiving answers, you MUST present in the chat window:\n   - **Questions Asked:** List each question you asked the user\n   - **Answers Provided:** Show the exact answers the user provided for each question\n   - **Gap Analysis:** A focused analysis highlighting where questions were NOT properly answered or need more detail\n   - **Request for Corrections:** Explicitly ask the user to review and provide corrections or additional detail\n4. Be PESSIMISTIC and CONSERVATIVE - if an answer seems incomplete, vague, or could be interpreted multiple ways, you MUST ask for clarification\n5. There is NEVER too much detail at this stage - it is EXTREMELY IMPORTANT to stop and get complete answers\n6. **MANDATORY STORAGE STEP:** After user confirms all answers are complete, you MUST call `agent_store_clarification()` MCP tool with:\n   - `key_questions_answered`: dict mapping question keys to answer strings\n   - `evidence_provided`: dict mapping evidence types to evidence content\n   - Example: key_questions_answered={'target_file': 'path/to/file.py', 'language': 'python', 'main_functions': ['calculate_total', 'process_order']}\n7. DO NOT proceed to planning until:\n   - You have presented questions and answers in the chat window\n   - The user has reviewed and confirmed or corrected the answers\n   - ALL questions have complete, unambiguous answers confirmed by the user\n   - You have successfully stored the clarification data using `agent_store_clarification()`\n\n**CRITICAL REMINDER:** The presentation of questions and answers in the chat window is MANDATORY and CANNOT BE SKIPPED. This allows the user to see what was asked, how it was answered, and provide corrections. For analyze behavior specifically, incomplete clarification will lead to poor code design. Stop and get complete answers.\n\n**CONTEXT AWARENESS:** If code already exists at the target location, analyze it to infer answers where possible. If no code exists, ask all questions to understand requirements for generating clean code.",
          "key_questions": [
            "What programming language specialization should be used? (python, javascript, or both)",
            "What is the target file or module name and location?",
            "What are the main functions, features, or capabilities that need to be implemented?",
            "What are the major domain objects, entities, or data structures involved?",
            "What programming paradigm should be used: functional programming, object-oriented programming, or a hybrid approach?",
            "How should the code be organized into layers or modules? (e.g., domain layer, service layer, presentation layer, data access layer)",
            "What are the key responsibilities and behaviors of each major component?",
            "What dependencies exist between components, modules, or external systems?",
            "Are there any existing code patterns, architectural styles, or design patterns to follow?",
            "What inputs are available from previous phases? (Check for: story documents, domain maps, BDD test files, existing code structure)",
            "What are the integration points with existing code or external systems?",
            "What error handling and validation requirements exist?",
            "What are the performance, scalability, or resource constraints?",
            "Are there any language-specific idioms, patterns, or conventions that must be respected?"
          ],
          "evidence": [
            "User stories or story documents (from story writing phase)",
            "Domain maps or domain model documents (from DDD documentation)",
            "BDD test files or test specifications (from BDD or TDD tests)",
            "Existing source code files",
            "API specifications or interface definitions",
            "Architecture diagrams, design documents / diagrams, or Archiecture templates ",
            "Code style guides or conventions",
            "Project documentation",
            "Previous code reviews or feedback",
            "Team coding standards",
            "Language-specific style guides (PEP 8, Airbnb JS, etc.)"
          ]
        },
        "planning": {
          "decision_instructions": "Present the following assumptions and decision making criteria to the user and ask for their opinion on key decisions. Ask them to review the assumptions and select their preferred criteria/options for each decision point.",
          "decision_making_criteria": [
            {
              "description": "Architecture and layering",
              "question": "How should the code be organized into layers or architectural components?",
              "outcome": "Determines code structure, separation of concerns, and module organization",
              "options": [
                "Layered architecture - Domain, Service, Presentation, Data layers",
                "Hexagonal/Ports and Adapters - Core domain with adapters for external concerns",
                "Clean Architecture - Entities, Use Cases, Interface Adapters, Frameworks",
                "Domain-Driven Design - Services, Aggregates, Context Boundaries, Entities, Value objects, Repositories, Factories, Events, Rules, UI",
                "Simple module structure - Functions and classes organized by feature",
                "MVC/MVP/MVVM - Model-View separation patterns",
                "Microservices structure - Independent services with clear boundaries",
                "Monolithic structure - Single module with clear internal organization",
                "Business Logic Only- pure business logic classes focused on modeling both properties and behavior"
              ]
            },
            {
              "description": "Dependency management",
              "question": "How should dependencies be managed and injected?",
              "outcome": "Determines how components depend on each other and external systems",
              "options": [
                "Constructor injection - All dependencies passed through constructors",
                "Dependency injection container - Use DI framework for dependency management",
                "Factory pattern - Use factories to create dependencies",
                "Service locator - Central registry for dependencies",
                "Minimal dependencies - Keep dependencies explicit and minimal",
                "Interface-based - Depend on interfaces/abstractions, not concrete types"
              ]
            },
            {
              "description": "Error handling strategy",
              "question": "What error handling and exception strategy should be used?",
              "outcome": "Determines how errors are handled and propagated",
              "options": [
                "Exception-based - Use exceptions for error conditions",
                "Result/Either types - Return success/failure results explicitly",
                "Error codes - Return error codes with results",
                "Fail-fast - Throw exceptions immediately on errors",
                "Graceful degradation - Handle errors gracefully with fallbacks",
                "Language-specific patterns - Use language idioms (Python exceptions, JS promises, etc.)"
              ]
            },
            {
              "description": "Programming paradigm",
              "question": "What programming paradigm should be used?",
              "outcome": "Determines whether code follows functional, object-oriented, or hybrid patterns",
              "options": [
                "Functional programming - Pure functions, immutability, higher-order functions, no side effects",
                "Object-oriented programming - Classes, objects, inheritance, polymorphism, encapsulation",
                "Hybrid approach - Combine functional and OOP patterns as appropriate",
                "Procedural - Functions organized by feature, minimal object orientation",
                "Data-oriented - Focus on data structures and transformations",
                "Language-idiomatic - Follow the primary paradigm of the chosen language"
              ]
            },
            {
              "description": "Properties vs methods",
              "question": "When should properties be used versus methods?",
              "outcome": "Determines how to expose object state and behavior",
              "options": [
                "Properties for all cases - Use properties for both data access and computed values",
                "Properties only for data - Use properties for simple data access, methods for behavior/computation",
                "Methods preferred - Use methods for most access, properties only for simple field access",
                "Computed properties - Use properties for computed values that are cheap and have no side effects",
                "Language conventions - Follow language-specific conventions (Python @property, C# properties, etc.)",
                "No properties - Use methods exclusively, no property accessors"
              ]
            }
          ],
          "typical_assumptions": [
            "Focus on maintainability and readability over performance optimizations",
            "Single Responsibility Principle - Each function/class does one thing well",
            "Dependency Injection - Dependencies passed through constructors, not created internally",
            "Immutability preferred - Minimize mutable state where possible",
            "Explicit over implicit - Make dependencies and behavior explicit",
            "Testability - Code should be easy to test in isolation",
            "Respect language-specific idioms and patterns",
            "Consider code context when generating or validating",
            "Provide actionable suggestions for violations or improvements",
            "Balance between strict adherence and practical constraints",
            "When generating code, incorporate requirements from stories, domain maps, and BDD tests",
            "When validating code, infer structure and intent from existing code",
            "Properties vs methods decision determines how object state and behavior are exposed",
            "Programming paradigm decision (functional/OOP/hybrid) guides overall code structure and patterns"
          ],
          "recommended_human_activity": [
            "Review the AI-generated violations report to verify accuracy",
            "Confirm that violations are correctly identified and severity levels are appropriate",
            "Validate that suggestions are actionable and appropriate for the codebase",
            "Review the code quality score and recommendations"
          ]
        }
      },
      "content": {
        "structured_content": {
          "schema": "violations_report.json",
          "path": "docs/clean-code",
          "description": "Structured code design document (for generation) or violations report (for validation) with code analysis results",
          "instructions": "Build the structured code design using the violations_report.json schema file. The schema file defines the exact structure you must follow. Load and use the schema file to ensure your output matches the required format exactly. CRITICAL: In build_structure phase, create the structured JSON file (violations_report.json) with the clean code design or analysis. Your task here is to build the structured JSON content that will be validated in the next phase.\n\n**MANDATORY STEPS:**\n1. MANDATORY: Check if code already exists at the target location:\n   - If code exists: Load and analyze it to understand current structure, then identify violations and improvements\n   - If no code exists: Generate clean code design based on requirements\n\n2. MANDATORY: Load and review inputs from previous phases (as specified in planning decisions):\n   - User stories (from docs/stories/ directory) - Extract functional requirements\n   - Domain maps (from docs/domain/ directory) - Extract domain objects and relationships\n   - BDD test files (from test/ directory) - Extract expected behavior and interfaces\n   - Existing code structure - Understand current implementation\n\n3. MANDATORY: Review ALL planning decisions and assumptions. These decisions contain critical architectural and design constraints:\n   - Architecture/layering decisions determine code structure\n   - Dependency management decisions determine how dependencies are injected\n   - Error handling strategy determines exception/error patterns\n   - Programming paradigm decision (functional/OOP/hybrid) guides overall code structure and patterns\n   - Properties vs methods decision determines how object state and behavior are exposed\n   - Integration decisions determine which previous phase inputs to use\n\n4. Generate clean code structure following:\n   - Single Responsibility Principle for each function/class\n   - Dependency Injection patterns (dependencies in constructors)\n   - Proper layering and separation of concerns\n   - Programming paradigm patterns (functional, OOP, or hybrid as decided)\n   - Properties vs methods usage as decided\n   - Language-specific idioms and patterns\n   - Requirements from stories, domain maps, and BDD tests\n\n5. If analyzing existing code:\n   - Extract code structure (functions, classes, line counts, nesting depth, etc.)\n   - Run heuristics (static analysis) to identify obvious violations\n   - Perform deep semantic analysis to identify architectural and design violations\n   - Each violation MUST include: location (line, function/class name), severity (critical/important/suggested), principle violated, specific issue description, and actionable suggestion\n\n6. Create structured design document with:\n   - Proposed functions/classes and their responsibilities (or existing ones with violations)\n   - Domain objects and their relationships\n   - Layer organization and module structure\n   - Dependency relationships\n   - Error handling approach\n   - Integration points\n   - Violations (if analyzing existing code)\n\nPlanning decisions override default patterns - you MUST apply them directly to your code design."
        }
      },
      "trigger_words": {
        "description": "Behavior-level trigger words - specific to clean code analysis behavior",
        "patterns": [
          "analyze.*code.*quality",
          "check.*clean.*code",
          "review.*code.*violations",
          "validate.*code.*quality",
          "code.*review",
          "clean.*code.*analysis",
          "identify.*violations",
          "code.*quality.*check",
          "review.*for.*violations",
          "analyze.*code"
        ],
        "priority": 10
      },
      "rules": [
        {
          "description": "Single Responsibility: Functions do one thing with no hidden side effects.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Pure calculation with no side effects",
                  "content": "```python\ndef subtotal(items: list[Item]) -> float:\n    return sum(i.price * i.qty for i in items)  # DO: Pure calculation, no side effects\n\ndef checkout(user, cart, services):\n    sub = subtotal(cart.items)  # DO: Separate calculation from orchestration\n    services.logger.info('checkout', extra={'user_id': user.id})\n```"
                },
                "dont": {
                  "description": "Hidden side effects in calculation",
                  "content": "```python\ndef full_name(user):\n    print(\"User:\", user.id)  # DON'T: Hidden side effect in calculation\n    metrics.append(user.id)  # DON'T: State mutation in pure function\n    return f\"{user.first} {user.last}\"\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Pure calculation with no side effects",
                  "content": "```javascript\nexport function subtotal(items) {\n  return items.reduce((s, i) => s + i.price * i.qty, 0);  // DO: Pure calculation\n}\n\nexport async function checkout({ user, cart, services }) {\n  const sub = subtotal(cart.items);  // DO: Separate calculation from orchestration\n  services.logger.info('checkout', { userId: user.id });\n}\n```"
                },
                "dont": {
                  "description": "Hidden side effects in calculation",
                  "content": "```javascript\nfunction fullName(user) {\n  console.log('User:', user.id);  // DON'T: Hidden side effect\n  return `${user.first} ${user.last}`;\n}\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Small and Focused: Keep functions under 20 lines, extract complex logic.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Small, focused calculation",
                  "content": "```python\nTAX_RATE = 0.13\n\ndef total_with_tax(subtotal: float, tax_rate: float = TAX_RATE) -> float:\n    return round(subtotal * (1 + tax_rate), 2)  # DO: Small, focused calculation\n```"
                },
                "dont": {
                  "description": "Multiple responsibilities in one function",
                  "content": "```python\ndef checkout(user, cart):\n    subtotal = sum(i.price*i.qty for i in cart.items)\n    total = round(subtotal * 1.13, 2)  # DON'T: Mixed abstraction levels\n    db.invoices.insert({'user_id': user.id, 'total': total})  # DON'T: Multiple responsibilities\n    for it in cart.items:\n        db.products.decrement(it.sku, it.qty)\n    email.send(user.email, f\"Thanks for ${total}\")\n    print('checkout complete')\n    return total\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Small, focused calculation",
                  "content": "```javascript\nconst TAX_RATE = 0.13;\n\nexport function totalWithTax(subtotal, tax = TAX_RATE) {\n  return Math.round(subtotal * (1 + tax) * 100) / 100;  // DO: Small, focused\n}\n```"
                },
                "dont": {
                  "description": "Multiple responsibilities in one function",
                  "content": "```javascript\nasync function checkout(user, cart) {\n  let subtotal = 0;\n  for (const i of cart.items) subtotal += i.price * i.qty;  // DON'T: Mixed levels\n  const total = subtotal * 1.13;\n  await db.invoices.insert({ userId: user.id, total });  // DON'T: Multiple responsibilities\n  for (const it of cart.items) await db.products.decrement(it.sku, it.qty);\n  await email.send(user.email, `Thanks for $${total}`);\n  console.log('checkout complete');\n  return total;\n}\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Clear Parameters: Use parameter objects for complex signatures; avoid boolean flags.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Parameter object with defaults",
                  "content": "```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass ConnectionOptions:\n    host: str\n    port: int\n    timeout_ms: int = 2000  # DO: Parameter object with defaults\n\ndef connect(opts: ConnectionOptions):\n    ...  # DO: Single, clear parameter\n\ndef export_csv(data): return to_csv(data)  # DO: Separate functions\ndef export_json(data): return to_json(data)  # DO: Not flag-based\n```"
                },
                "dont": {
                  "description": "Boolean flag parameter",
                  "content": "```python\ndef export_report(data, is_csv: bool):  # DON'T: Boolean flag parameter\n    return to_csv(data) if is_csv else to_json(data)\n\ndef render(chart, dark, pretty, borders):  # DON'T: Too many parameters\n    ...\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Destructured object parameter with defaults",
                  "content": "```javascript\nexport function connect({ host, port, timeoutMs = 2000 }) {\n  // DO: Destructured object parameter with defaults\n}\n\nexport function exportCsv(data) { return toCsv(data); }  // DO: Separate functions\nexport function exportJson(data) { return toJson(data); }  // DO: Not flag-based\n```"
                },
                "dont": {
                  "description": "Boolean flag parameter",
                  "content": "```javascript\nfunction exportReport(data, isCsv) {  // DON'T: Boolean flag parameter\n  return isCsv ? toCsv(data) : toJson(data);\n}\n\nfunction render(chart, dark, pretty, borders) {  // DON'T: Too many parameters\n  // ...\n}\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Simple Control Flow: Use guard clauses to reduce nesting.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Early return guards",
                  "content": "```python\ndef price_for(user, plan):\n    if not user or not plan: return 0  # DO: Early return guards\n    if user.is_student: return plan.base * 0.5  # DO: Flat structure\n    return plan.base\n```"
                },
                "dont": {
                  "description": "Deep nesting",
                  "content": "```python\ndef price_for(user, plan):\n    if user is not None:  # DON'T: Deep nesting\n        if plan is not None:\n            if user.is_student:\n                return plan.base * 0.5\n            else:\n                return plan.base\n    return 0\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Early return guards",
                  "content": "```javascript\nfunction priceFor(user, plan) {\n  if (!user || !plan) return 0;  // DO: Early return guards\n  if (user.isStudent) return plan.base * 0.5;  // DO: Flat structure\n  return plan.base;\n}\n```"
                },
                "dont": {
                  "description": "Deep nesting",
                  "content": "```javascript\nfunction priceFor(user, plan) {\n  if (user) {  // DON'T: Deep nesting\n    if (plan) {\n      if (user.isStudent) return plan.base * 0.5;\n      return plan.base;\n    }\n  }\n  return 0;\n}\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Intention-Revealing Names: Names should clearly communicate purpose.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Clear, searchable constant",
                  "content": "```python\nMILLISECONDS_PER_DAY = 86_400_000  # DO: Clear, searchable constant\nelapsed_time_in_days = timer.elapsed_ms() / MILLISECONDS_PER_DAY  # DO: Intention-revealing\n```"
                },
                "dont": {
                  "description": "Meaningless name, magic number",
                  "content": "```python\nd = 86400000  # DON'T: Meaningless name, magic number\nelapsed = timer.elapsed_ms() / 86400000  # DON'T: No context\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Clear, searchable constant",
                  "content": "```javascript\nconst MILLISECONDS_PER_DAY = 86_400_000;  // DO: Clear, searchable constant\nconst elapsedTimeInDays = timer.elapsedMs / MILLISECONDS_PER_DAY;  // DO: Intention-revealing\n```"
                },
                "dont": {
                  "description": "Meaningless name, magic number",
                  "content": "```javascript\nconst d = 86400000;  // DON'T: Meaningless name, magic number\nconst elapsed = timer.elapsedMs / 86400000;  // DON'T: No context\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Consistency: Use one term per concept across codebase.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Consistent 'get' prefix",
                  "content": "```python\ndef get_user(user_id): ...  # DO: Consistent \"get\" prefix\ndef get_order(order_id): ...  # DO: Same term for retrieval\ndef get_product(sku): ...\n```"
                },
                "dont": {
                  "description": "Mixed terms for same concept",
                  "content": "```python\ndef get_user(user_id): ...  # DON'T: Mixed terms for same concept\ndef fetch_order(order_id): ...  # DON'T: Different term\ndef retrieve_product(sku): ...  # DON'T: Yet another term\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Consistent 'get' prefix",
                  "content": "```javascript\nfunction getUser(userId) { }  // DO: Consistent \"get\" prefix\nfunction getOrder(orderId) { }  // DO: Same term for retrieval\nfunction getProduct(sku) { }\n```"
                },
                "dont": {
                  "description": "Mixed terms for same concept",
                  "content": "```javascript\nfunction getUser(userId) { }  // DON'T: Mixed terms for same concept\nfunction fetchOrder(orderId) { }  // DON'T: Different term\nfunction retrieveProduct(sku) { }  // DON'T: Yet another term\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Meaningful Context: Replace magic numbers with named constants.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Named constant provides context",
                  "content": "```python\nADULT_AGE = 18\nTAX_RATE = 0.13\n\ndef is_adult(age: int) -> bool:\n    return age >= ADULT_AGE  # DO: Named constant provides context\n```"
                },
                "dont": {
                  "description": "Magic number without context",
                  "content": "```python\ndef is_adult(age):\n    return age >= 18  # DON'T: Magic number without context\n\nsleep(86400000)  # DON'T: Unexplained magic number\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Named constant provides context",
                  "content": "```javascript\nconst ADULT_AGE = 18;\nconst TAX_RATE = 0.13;\n\nfunction isAdult(age) {\n  return age >= ADULT_AGE;  // DO: Named constant provides context\n}\n```"
                },
                "dont": {
                  "description": "Magic number without context",
                  "content": "```javascript\nfunction isAdult(age) {\n  return age >= 18;  // DON'T: Magic number without context\n}\n\nconst total = subtotal * 1.13;  // DON'T: Unexplained magic number\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Eliminate Duplication (DRY): Extract repeated logic into reusable functions.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Reusable calculation",
                  "content": "```python\ndef calculate_subtotal(items):\n    return sum(i.price * i.qty for i in items)  # DO: Reusable calculation\n\nsubtotal_a = calculate_subtotal(items_a)  # DO: No duplication\nsubtotal_b = calculate_subtotal(items_b)\n```"
                },
                "dont": {
                  "description": "Duplicated logic",
                  "content": "```python\nsubtotal_a = 0  # DON'T: Duplicated logic\nfor i in items_a:\n    subtotal_a += i.price * i.qty\n\nsubtotal_b = 0  # DON'T: Same logic repeated\nfor i in items_b:\n    subtotal_b += i.price * i.qty\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Reusable calculation",
                  "content": "```javascript\nfunction calculateSubtotal(items) {\n  return items.reduce((sum, i) => sum + i.price * i.qty, 0);  // DO: Reusable\n}\n\nconst subtotalA = calculateSubtotal(itemsA);  // DO: No duplication\nconst subtotalB = calculateSubtotal(itemsB);\n```"
                },
                "dont": {
                  "description": "Duplicated logic",
                  "content": "```javascript\nlet subtotalA = 0;  // DON'T: Duplicated logic\nfor (const i of itemsA) subtotalA += i.price * i.qty;\n\nlet subtotalB = 0;  // DON'T: Same logic repeated\nfor (const i of itemsB) subtotalB += i.price * i.qty;\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Separation of Concerns: Keep pure logic separate from side effects.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Pure calculation",
                  "content": "```python\ndef full_name(user) -> str:\n    return f\"{user.first} {user.last}\"  # DO: Pure calculation\n\ndef greet(user, logger) -> str:\n    logger.debug(\"Greeting\", extra={\"user_id\": user.id})  # DO: Separate side effects\n    return f\"Hello, {full_name(user)}!\"\n```"
                },
                "dont": {
                  "description": "Side effect in calculation",
                  "content": "```python\ndef discount(total):\n    d = total * 0.1 if total > 100 else 0\n    logging.info(\"discount=%s\", d)  # DON'T: Side effect in calculation\n    return d\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Pure calculation",
                  "content": "```javascript\nfunction fullName(user) {\n  return `${user.first} ${user.last}`;  // DO: Pure calculation\n}\n\nfunction greet(user, { logger }) {\n  logger.debug({ userId: user.id, name: fullName(user) });  // DO: Separate side effects\n  return `Hello, ${fullName(user)}!`;\n}\n```"
                },
                "dont": {
                  "description": "Side effect in calculation",
                  "content": "```javascript\nfunction discount(total) {\n  const d = total * 0.1;\n  console.log('discount:', d);  // DON'T: Side effect in calculation\n  return d;\n}\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Proper Abstraction Levels: Step down one abstraction level at a time.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "High-level orchestration with medium-level functions",
                  "content": "```python\ndef checkout(user, cart, services):  # High-level orchestration\n    sub = subtotal(cart.items)  # Medium-level calculation\n    total = total_with_tax(sub)  # Medium-level calculation\n    invoice = save_invoice(user, total, cart.items)  # Medium-level persistence\n    return invoice, total\n```"
                },
                "dont": {
                  "description": "Mixed abstraction levels",
                  "content": "```python\ndef checkout(user, cart):\n    sub = sum(i.price * i.qty for i in cart.items)  # DON'T: Mixed levels\n    db.execute(\"INSERT INTO invoices...\")  # DON'T: Low-level detail in high-level function\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "High-level orchestration with medium-level functions",
                  "content": "```javascript\nexport async function checkout({ user, cart, taxRate, services }) {\n  const sub = subtotal(cart.items);  // Medium-level calculation\n  const total = totalWithTax(sub, taxRate);  // Medium-level calculation\n  const invoice = await saveInvoice(user, total, cart);  // Medium-level persistence\n  return { invoice, total };\n}\n```"
                },
                "dont": {
                  "description": "Mixed abstraction levels",
                  "content": "```javascript\nasync function checkout(user, cart) {\n  const sub = cart.items.reduce((s, i) => s + i.price * i.qty, 0);  // DON'T: Mixed levels\n  await db.execute(\"INSERT INTO invoices...\");  // DON'T: Low-level detail\n}\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Use Exceptions Properly: Prefer exceptions with informative messages over silent failures.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Domain-specific exception with informative message",
                  "content": "```python\nclass ParseError(ValueError):\n    pass  # DO: Domain-specific exception\n\ndef parse_json(payload: str) -> dict:\n    try:\n        return json.loads(payload)\n    except json.JSONDecodeError as e:\n        raise ParseError(\"Invalid JSON\") from e  # DO: Informative error with cause\n```"
                },
                "dont": {
                  "description": "Silent failure",
                  "content": "```python\ndef load(payload):\n    try:\n        return json.loads(payload)\n    except:  # DON'T: Bare except, swallow all errors\n        return None  # DON'T: Silent failure\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Domain-specific exception with informative message",
                  "content": "```javascript\nclass ParseError extends Error { }  // DO: Domain-specific exception\n\nfunction parseJson(payload) {\n  try {\n    return JSON.parse(payload);\n  } catch (e) {\n    throw new ParseError('Invalid JSON');  // DO: Informative error\n  }\n}\n```"
                },
                "dont": {
                  "description": "Silent failure",
                  "content": "```javascript\nfunction load(payload) {\n  try {\n    return JSON.parse(payload);\n  } catch (e) {  // DON'T: Silent failure\n    /* ignore */\n  }\n}\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Isolate Error Handling: Extract try/catch into dedicated functions.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Error handling isolated",
                  "content": "```python\ndef parse_request(raw_data):  # DO: Error handling isolated\n    try:\n        return _parse_json(raw_data)\n    except ParseError as e:\n        logger.error(\"Parse failed\", exc_info=e)\n        raise\n\ndef _parse_json(data):  # DO: Business logic separated\n    return json.loads(data)\n```"
                },
                "dont": {
                  "description": "Mixed error handling and logic",
                  "content": "```python\ndef process(data):\n    try:\n        result = json.loads(data)  # DON'T: Mixed error handling and logic\n        validated = validate(result)\n        transformed = transform(validated)\n        return transformed\n    except Exception:\n        handle_error()\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Error handling isolated",
                  "content": "```javascript\nasync function parseRequest(rawData) {  // DO: Error handling isolated\n  try {\n    return await _parseJson(rawData);\n  } catch (err) {\n    logger.error('Parse failed', err);\n    throw;\n  }\n}\n\nfunction _parseJson(data) {  // DO: Business logic separated\n  return JSON.parse(data);\n}\n```"
                },
                "dont": {
                  "description": "Mixed error handling and logic",
                  "content": "```javascript\nasync function process(data) {\n  try {\n    const result = JSON.parse(data);  // DON'T: Mixed error handling and logic\n    const validated = validate(result);\n    const transformed = transform(validated);\n    return transformed;\n  } catch (error) {\n    handleError(error);\n  }\n}\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Classify by Caller Needs: Create exception types based on how callers handle them.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Caller-centric exceptions",
                  "content": "```python\nclass ValidationError(Exception): pass  # DO: Caller-centric exceptions\nclass PaymentError(Exception): pass\n\ndef checkout(cart):\n    if not cart.valid:\n        raise ValidationError(\"Invalid cart\")  # DO: Clear caller action\n```"
                },
                "dont": {
                  "description": "Implementation-centric exceptions",
                  "content": "```python\nclass DatabaseError(Exception): pass  # DON'T: Implementation-centric\nclass NetworkError(Exception): pass  # DON'T: Forces caller to know internals\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Caller-centric exceptions",
                  "content": "```javascript\nclass ValidationError extends Error { }  // DO: Caller-centric exceptions\nclass PaymentError extends Error { }\n\nfunction checkout(cart) {\n  if (!cart.valid) {\n    throw new ValidationError('Invalid cart');  // DO: Clear caller action\n  }\n}\n```"
                },
                "dont": {
                  "description": "Implementation-centric exceptions",
                  "content": "```javascript\nclass DatabaseError extends Error { }  // DON'T: Implementation-centric\nclass NetworkError extends Error { }  // DON'T: Forces caller to know internals\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Minimize Mutable State: Prefer immutable data structures.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Immutable dataclass and config",
                  "content": "```python\nfrom types import MappingProxyType\nfrom dataclasses import dataclass\n\n@dataclass(frozen=True)  # DO: Immutable dataclass\nclass Item:\n    sku: str\n    price: float\n    qty: int\n\nSETTINGS = MappingProxyType({\"mode\": \"prod\"})  # DO: Immutable config\n```"
                },
                "dont": {
                  "description": "Mutable global state",
                  "content": "```python\nsettings = {\"mode\": \"prod\"}  # DON'T: Mutable global state\n\ndef set_mode(mode):\n    settings[\"mode\"] = mode  # DON'T: Global mutation\n\ncache = {}  # DON'T: Shared mutable cache\ndef get_user(user_id):\n    if user_id in cache:\n        return cache[user_id]\n    cache[user_id] = repo.fetch(user_id)  # DON'T: Hidden state mutation\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Immutable objects and arrays",
                  "content": "```javascript\nconst item = Object.freeze({ sku: 'ABC', price: 10 });  // DO: Immutable object\n\nconst settings = Object.freeze({ mode: 'prod' });  // DO: Immutable config\n\nconst newItems = [...items, newItem];  // DO: Create new array, don't mutate\n```"
                },
                "dont": {
                  "description": "Mutable global state",
                  "content": "```javascript\nlet currentUser = null;  // DON'T: Mutable global state\n\nexport function setUser(u) {\n  currentUser = u;  // DON'T: Global mutation\n}\n\nconst cache = {};  // DON'T: Shared mutable cache\nexport function getUser(userId) {\n  if (!cache[userId]) {\n    cache[userId] = repo.fetch(userId);  // DON'T: Hidden state mutation\n  }\n  return cache[userId];\n}\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Encapsulation: Hide implementation details, expose minimal interface.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Private implementation detail",
                  "content": "```python\nclass Inventory:\n    def __init__(self, repo):\n        self._repo = repo  # DO: Private implementation detail\n\n    def adjust_many(self, changes: list[tuple[str, int]]):\n        for sku, delta in changes:\n            self._adjust_one(sku, delta)  # DO: Encapsulated helper\n```"
                },
                "dont": {
                  "description": "Public implementation detail",
                  "content": "```python\nclass Inventory:\n    def __init__(self):\n        self.repo = Repository()  # DON'T: Public implementation detail\n        self.cache = {}  # DON'T: Exposed internal state\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Private field",
                  "content": "```javascript\nexport class Inventory {\n  #repo;  // DO: Private field\n\n  constructor(repo) {\n    this.#repo = repo;  // DO: Encapsulated dependency\n  }\n\n  async adjustMany(changes) {\n    for (const { sku, delta } of changes) {\n      await this.#adjustOne(sku, delta);  // DO: Private helper\n    }\n  }\n}\n```"
                },
                "dont": {
                  "description": "Public implementation detail",
                  "content": "```javascript\nexport class Inventory {\n  constructor() {\n    this.repo = new Repository();  // DON'T: Public implementation detail\n    this.cache = {};  // DON'T: Exposed internal state\n  }\n}\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Explicit Dependencies: Pass dependencies through constructors.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Constructor injection",
                  "content": "```python\nclass CheckoutService:\n    def __init__(self, invoice_repo, inventory, mailer):\n        self._invoice_repo = invoice_repo  # DO: Constructor injection\n        self._inventory = inventory\n        self._mailer = mailer\n```"
                },
                "dont": {
                  "description": "Hidden global dependency",
                  "content": "```python\nclass CheckoutService:\n    def __init__(self):\n        self.repo = global_invoice_repo  # DON'T: Hidden global dependency\n        self.inventory = Inventory()  # DON'T: Hidden construction\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Constructor injection",
                  "content": "```javascript\nexport class CheckoutService {\n  constructor(invoiceRepo, inventory, mailer) {\n    this.invoiceRepo = invoiceRepo;  // DO: Constructor injection\n    this.inventory = inventory;\n    this.mailer = mailer;\n  }\n}\n```"
                },
                "dont": {
                  "description": "Hidden global dependency",
                  "content": "```javascript\nexport class CheckoutService {\n  constructor() {\n    this.repo = globalInvoiceRepo;  // DON'T: Hidden global dependency\n    this.inventory = new Inventory();  // DON'T: Hidden construction\n  }\n}\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Classes Single Responsibility: Each class has one reason to change.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Focused classes",
                  "content": "```python\nclass InvoiceRepository:  # DO: Focused on invoice persistence\n    def save(self, invoice): ...\n    def find_by_id(self, invoice_id): ...\n\nclass InvoiceCalculator:  # DO: Focused on invoice calculations\n    def calculate_total(self, items): ...\n    def apply_discount(self, total, discount): ...\n```"
                },
                "dont": {
                  "description": "Multiple responsibilities",
                  "content": "```python\nclass Invoice:  # DON'T: Multiple responsibilities\n    def calculate_total(self): ...  # Calculation\n    def save_to_db(self): ...  # Persistence\n    def send_email(self): ...  # Notification\n    def format_pdf(self): ...  # Formatting\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Focused classes",
                  "content": "```javascript\nexport class InvoiceRepository {  // DO: Focused on persistence\n  async save(invoice) { }\n  async findById(invoiceId) { }\n}\n\nexport class InvoiceCalculator {  // DO: Focused on calculations\n  calculateTotal(items) { }\n  applyDiscount(total, discount) { }\n}\n```"
                },
                "dont": {
                  "description": "Multiple responsibilities",
                  "content": "```javascript\nexport class Invoice {  // DON'T: Multiple responsibilities\n  calculateTotal() { }  // Calculation\n  saveToDB() { }  // Persistence\n  sendEmail() { }  // Notification\n  formatPDF() { }  // Formatting\n}\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Classes Small and Compact: Keep classes under 200-300 lines.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Focused, small class",
                  "content": "```python\nclass DiscountCalculator:  # DO: Focused, small class\n    def calculate(self, total, user_type):\n        if user_type == \"student\":\n            return total * 0.5\n        return total\n```"
                },
                "dont": {
                  "description": "God object",
                  "content": "```python\nclass OrderProcessor:  # DON'T: God object with many responsibilities\n    # ... 500+ lines of mixed concerns\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Focused, small class",
                  "content": "```javascript\nexport class DiscountCalculator {  // DO: Focused, small class\n  calculate(total, userType) {\n    if (userType === 'student') return total * 0.5;\n    return total;\n  }\n}\n```"
                },
                "dont": {
                  "description": "God object",
                  "content": "```javascript\nexport class OrderProcessor {  // DON'T: God object\n  // ... 500+ lines of mixed concerns\n}\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Open/Closed Principle: Depend on abstractions, not concrete types.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Abstract interface",
                  "content": "```python\nfrom abc import ABC, abstractmethod\n\nclass PaymentProcessor(ABC):  # DO: Abstract interface\n    @abstractmethod\n    def process(self, amount): ...\n\nclass StripeProcessor(PaymentProcessor):  # DO: Concrete implementation\n    def process(self, amount):\n        # Stripe-specific logic\n```"
                },
                "dont": {
                  "description": "Hardcoded concrete type",
                  "content": "```python\nclass OrderService:\n    def __init__(self):\n        self.payment = StripePayment()  # DON'T: Hardcoded concrete type\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Abstract interface",
                  "content": "```javascript\n// DO: Abstract interface (via TypeScript or JSDoc)\nexport class PaymentProcessor {\n  process(amount) { throw new Error('Not implemented'); }\n}\n\nexport class StripeProcessor extends PaymentProcessor {  // DO: Concrete implementation\n  process(amount) {\n    // Stripe-specific logic\n  }\n}\n```"
                },
                "dont": {
                  "description": "Hardcoded concrete type",
                  "content": "```javascript\nexport class OrderService {\n  constructor() {\n    this.payment = new StripePayment();  // DON'T: Hardcoded concrete type\n  }\n}\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Prefer Code Over Comments: Express intent in code first.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Self-documenting function name",
                  "content": "```python\ndef is_eligible_for_discount(user):  # DO: Self-documenting function name\n    return user.age < 18 or user.is_student\n\nif is_eligible_for_discount(user):  # DO: No comment needed\n    apply_discount()\n```"
                },
                "dont": {
                  "description": "Comment explains bad name",
                  "content": "```python\n# Check if user is eligible for discount  # DON'T: Comment explains bad name\nif user.age < 18 or user.is_student:\n    apply_discount()\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Self-documenting function name",
                  "content": "```javascript\nfunction isEligibleForDiscount(user) {  // DO: Self-documenting function name\n  return user.age < 18 || user.isStudent;\n}\n\nif (isEligibleForDiscount(user)) {  // DO: No comment needed\n  applyDiscount();\n}\n```"
                },
                "dont": {
                  "description": "Comment explains bad name",
                  "content": "```javascript\n// Check if user is eligible for discount  // DON'T: Comment explains bad name\nif (user.age < 18 || user.isStudent) {\n  applyDiscount();\n}\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Good Comments: Legal notices, TODOs, and complex algorithm explanations.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Legal notice and actionable TODO",
                  "content": "```python\n# Copyright 2025 Company Name  # DO: Legal notice\n\n# TODO: Optimize this query using pagination  # DO: Actionable TODO\n\ndef fast_inverse_sqrt(x):\n    # Newton-Raphson approximation for 1/sqrt(x)  # DO: Algorithm explanation\n    ...\n```"
                },
                "dont": {
                  "description": "Attribution and noise comment",
                  "content": "```python\n# Added by John on 2024-01-15  # DON'T: Attribution (use git)\n# i = 0  # initialize counter  # DON'T: Noise comment\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Legal notice and actionable TODO",
                  "content": "```javascript\n// Copyright 2025 Company Name  // DO: Legal notice\n\n// TODO: Optimize with pagination  // DO: Actionable TODO\n\nfunction fastInverseSqrt(x) {\n  // Newton-Raphson approximation for 1/sqrt(x)  // DO: Algorithm explanation\n  // ...\n}\n```"
                },
                "dont": {
                  "description": "Attribution and noise comment",
                  "content": "```javascript\n// Added by John on 2024-01-15  // DON'T: Attribution (use git)\nlet i = 0;  // initialize counter  // DON'T: Noise comment\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Bad Comments: Avoid commented-out code, misleading comments.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Delete commented-out code",
                  "content": "```python\n# (Delete commented-out code, it's in git)\ndef process(data):\n    return transform(data)\n```"
                },
                "dont": {
                  "description": "Commented-out code",
                  "content": "```python\ndef process(data):\n    # old_result = legacy_transform(data)  # DON'T: Commented-out code\n    # new_result = transform(data)  # DON'T: Keep as backup\n    return transform(data)\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Delete commented-out code",
                  "content": "```javascript\n// (Delete commented-out code, it's in git)\nfunction process(data) {\n  return transform(data);\n}\n```"
                },
                "dont": {
                  "description": "Commented-out code",
                  "content": "```javascript\nfunction process(data) {\n  // const oldResult = legacyTransform(data);  // DON'T: Commented-out code\n  // const newResult = transform(data);  // DON'T: Keep as backup\n  return transform(data);\n}\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Vertical Density: Group related code, declare variables close to usage.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Declared close to use",
                  "content": "```python\ndef checkout(user, cart):\n    subtotal = calculate_subtotal(cart.items)  # DO: Declared close to use\n    tax = calculate_tax(subtotal)\n    total = subtotal + tax  # DO: Related calculations together\n    return total\n```"
                },
                "dont": {
                  "description": "Declared far from use",
                  "content": "```python\ndef checkout(user, cart):\n    subtotal = 0  # DON'T: Declared far from use\n    tax = 0\n    discount = 0\n\n    # ... many lines later ...\n    \n    subtotal = calculate_subtotal(cart.items)\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Declared close to use",
                  "content": "```javascript\nfunction checkout(user, cart) {\n  const subtotal = calculateSubtotal(cart.items);  // DO: Declared close to use\n  const tax = calculateTax(subtotal);\n  const total = subtotal + tax;  // DO: Related calculations together\n  return total;\n}\n```"
                },
                "dont": {
                  "description": "Declared far from use",
                  "content": "```javascript\nfunction checkout(user, cart) {\n  let subtotal = 0;  // DON'T: Declared far from use\n  let tax = 0;\n  let discount = 0;\n\n  // ... many lines later ...\n  \n  subtotal = calculateSubtotal(cart.items);\n}\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Consistent Indentation: Use consistent indentation (4 spaces for Python, 2 spaces for JavaScript).",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Consistent 4-space indentation",
                  "content": "```python\ndef process(data):\n    if data:  # DO: Consistent 4-space indentation\n        for item in data:\n            process_item(item)\n```"
                },
                "dont": {
                  "description": "Inconsistent indentation",
                  "content": "```python\ndef process(data):\n  if data:  # DON'T: Inconsistent 2-space indentation\n      for item in data:  # DON'T: Mixed indentation\n            process_item(item)\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Consistent 2-space indentation",
                  "content": "```javascript\nfunction process(data) {\n  if (data) {  // DO: Consistent 2-space indentation\n    for (const item of data) {\n      processItem(item);\n    }\n  }\n}\n```"
                },
                "dont": {
                  "description": "Inconsistent indentation",
                  "content": "```javascript\nfunction process(data) {\n    if (data) {  // DON'T: Inconsistent 4-space indentation\n      for (const item of data) {  // DON'T: Mixed indentation\n          processItem(item);\n      }\n    }\n}\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Test Quality: Tests should be as clean as production code.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Descriptive test name",
                  "content": "```python\ndef test_calculates_student_discount():  # DO: Descriptive test name\n    user = User(is_student=True)\n    assert price_for(user, Plan(base=100)) == 50  # DO: Clear assertion\n```"
                },
                "dont": {
                  "description": "Meaningless test name",
                  "content": "```python\ndef test_1():  # DON'T: Meaningless test name\n    # DON'T: Unclear test setup\n    assert func(data) == expected\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Descriptive test name",
                  "content": "```javascript\ntest('calculates student discount', () => {  // DO: Descriptive test name\n  const user = { isStudent: true };\n  expect(priceFor(user, { base: 100 })).toBe(50);  // DO: Clear assertion\n});\n```"
                },
                "dont": {
                  "description": "Meaningless test name",
                  "content": "```javascript\ntest('test1', () => {  // DON'T: Meaningless test name\n  // DON'T: Unclear test setup\n  expect(func(data)).toBe(expected);\n});\n```"
                }
              }
            ]
          }
        },
        {
          "description": "One Concept Per Test: Test one behavior per test function.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "One concept per test",
                  "content": "```python\ndef test_student_receives_50_percent_discount():  # DO: One concept\n    user = User(is_student=True)\n    assert price_for(user, Plan(100)) == 50\n\ndef test_regular_user_pays_full_price():  # DO: Separate concept\n    user = User(is_student=False)\n    assert price_for(user, Plan(100)) == 100\n```"
                },
                "dont": {
                  "description": "Multiple concepts in one test",
                  "content": "```python\ndef test_pricing():  # DON'T: Multiple concepts in one test\n    assert price_for(Student(), Plan(100)) == 50\n    assert price_for(Regular(), Plan(100)) == 100\n    assert price_for(None, Plan(100)) == 0\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "One concept per test",
                  "content": "```javascript\ntest('student receives 50% discount', () => {  // DO: One concept\n  const user = { isStudent: true };\n  expect(priceFor(user, { base: 100 })).toBe(50);\n});\n\ntest('regular user pays full price', () => {  // DO: Separate concept\n  const user = { isStudent: false };\n  expect(priceFor(user, { base: 100 })).toBe(100);\n});\n```"
                },
                "dont": {
                  "description": "Multiple concepts in one test",
                  "content": "```javascript\ntest('pricing', () => {  // DON'T: Multiple concepts in one test\n  expect(priceFor({ isStudent: true }, { base: 100 })).toBe(50);\n  expect(priceFor({ isStudent: false }, { base: 100 })).toBe(100);\n  expect(priceFor(null, { base: 100 })).toBe(0);\n});\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Test-Driven Development: Write tests first (Red-Green-Refactor).",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Red-Green-Refactor cycle",
                  "content": "```python\n# 1. RED: Write failing test first\ndef test_applies_tax_rate():\n    assert total_with_tax(100, 0.13) == 113.0\n\n# 2. GREEN: Minimal implementation\ndef total_with_tax(subtotal, tax_rate):\n    return subtotal * (1 + tax_rate)\n\n# 3. REFACTOR: Improve with confidence\n```"
                },
                "dont": {
                  "description": "Write tests after code",
                  "content": "```python\n# DON'T: Write tests after code is done\n# DON'T: Skip refactoring step\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Red-Green-Refactor cycle",
                  "content": "```javascript\n// 1. RED: Write failing test first\ntest('applies tax rate', () => {\n  expect(totalWithTax(100, 0.13)).toBe(113.0);\n});\n\n// 2. GREEN: Minimal implementation\nfunction totalWithTax(subtotal, taxRate) {\n  return subtotal * (1 + taxRate);\n}\n\n// 3. REFACTOR: Improve with confidence\n```"
                },
                "dont": {
                  "description": "Write tests after code",
                  "content": "```javascript\n// DON'T: Write tests after code is done\n// DON'T: Skip refactoring step\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Isolate Third-Party Code: Wrap external APIs behind your interfaces.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Wrapper around third-party",
                  "content": "```python\nclass EmailService:  # DO: Wrapper around third-party\n    def __init__(self, smtp_client):\n        self._client = smtp_client  # DO: Encapsulated dependency\n\n    def send_receipt(self, to: str, invoice):\n        subject = f\"Order #{invoice.id}\"\n        self._client.send(to=to, subject=subject)  # DO: Isolated usage\n```"
                },
                "dont": {
                  "description": "Direct third-party usage",
                  "content": "```python\nimport third_party_lib\n\ndef checkout(user, cart):\n    third_party_lib.send(user.email)  # DON'T: Direct third-party usage\n    return third_party_lib.Invoice(...)  # DON'T: Leaked third-party types\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Wrapper around third-party",
                  "content": "```javascript\nexport class EmailService {  // DO: Wrapper around third-party\n  constructor(smtpClient) {\n    this.client = smtpClient;  // DO: Encapsulated dependency\n  }\n\n  async sendReceipt(to, invoice) {\n    const subject = `Order #${invoice.id}`;\n    return this.client.send({ to, subject });  // DO: Isolated usage\n  }\n}\n```"
                },
                "dont": {
                  "description": "Direct third-party usage",
                  "content": "```javascript\nimport thirdPartyLib from 'third-party';\n\nasync function checkout(user, cart) {\n  await thirdPartyLib.send(user.email);  // DON'T: Direct third-party usage\n  return new thirdPartyLib.Invoice(...);  // DON'T: Leaked third-party types\n}\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Adapt and Test: Test boundary behavior explicitly.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Test boundary",
                  "content": "```python\ndef test_email_service_sends_receipt():  # DO: Test boundary\n    mock_smtp = MockSMTP()\n    service = EmailService(mock_smtp)\n    service.send_receipt(\"user@example.com\", Invoice(id=123))\n    assert mock_smtp.sent_count == 1\n```"
                },
                "dont": {
                  "description": "Skip testing third-party integration",
                  "content": "```python\n# DON'T: Skip testing third-party integration\n# DON'T: Trust third-party behavior implicitly\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Test boundary",
                  "content": "```javascript\ntest('email service sends receipt', async () => {  // DO: Test boundary\n  const mockSMTP = { send: jest.fn() };\n  const service = new EmailService(mockSMTP);\n  await service.sendReceipt('user@example.com', { id: 123 });\n  expect(mockSMTP.send).toHaveBeenCalledTimes(1);\n});\n```"
                },
                "dont": {
                  "description": "Skip testing third-party integration",
                  "content": "```javascript\n// DON'T: Skip testing third-party integration\n// DON'T: Trust third-party behavior implicitly\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Use severity levels appropriately: critical (breaks maintainability), important (significantly impacts readability), suggested (minor improvements).",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Appropriate severity levels for Python violations",
                  "content": "```python\n# CRITICAL: Function >50 lines violates Small and Focused principle\ndef process_order(user, cart, payment, inventory, email_service, logger, metrics):\n    # ... 60+ lines of mixed responsibilities\n    # This breaks maintainability - CRITICAL violation\n\n# IMPORTANT: Function >20 lines impacts readability\ndef calculate_total_with_discounts_and_taxes(items, user, promotions):\n    # ... 25 lines\n    # Significantly impacts readability - IMPORTANT violation\n\n# SUGGESTED: Function >15 lines, minor improvement\ndef format_user_name(first, last, middle=None):\n    # ... 18 lines\n    # Minor improvement - SUGGESTED violation\n```"
                },
                "dont": {
                  "description": "Don't overuse critical severity",
                  "content": "```python\n# WRONG: Flagging loop variable as critical violation\nfor i in items:  # DON'T: Critical violation for 'i' (WRONG - should be suggested or ignored)\n    process(i)\n\n# WRONG: Flagging type hint as critical\nfrom typing import Optional\ndef func(x: Optional[int]) -> str:  # DON'T: Critical violation for Optional (WRONG - it's idiomatic)\n    return str(x)\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Appropriate severity levels for JavaScript violations",
                  "content": "```javascript\n// CRITICAL: Function >50 lines violates Small and Focused principle\nasync function processOrder(user, cart, payment, inventory, emailService, logger, metrics) {\n  // ... 60+ lines of mixed responsibilities\n  // This breaks maintainability - CRITICAL violation\n}\n\n// IMPORTANT: Function >20 lines impacts readability\nfunction calculateTotalWithDiscountsAndTaxes(items, user, promotions) {\n  // ... 25 lines\n  // Significantly impacts readability - IMPORTANT violation\n}\n\n// SUGGESTED: Function >15 lines, minor improvement\nfunction formatUserName(first, last, middle = null) {\n  // ... 18 lines\n  // Minor improvement - SUGGESTED violation\n}\n```"
                },
                "dont": {
                  "description": "Don't overuse critical severity",
                  "content": "```javascript\n// WRONG: Flagging loop variable as critical violation\nfor (let i = 0; i < items.length; i++) {  // DON'T: Critical violation for 'i' (WRONG - should be suggested or ignored)\n  process(items[i]);\n}\n\n// WRONG: Flagging arrow function as critical\nconst fn = () => {};  // DON'T: Critical violation for arrow function (WRONG - it's idiomatic)\n```"
                }
              }
            ]
          }
        },
        {
          "description": "Respect language-specific idioms and patterns. Python list comprehensions, JavaScript arrow functions, etc. are idiomatic and should not be flagged as violations.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Respect Python idioms",
                  "content": "```python\n# Type hints are idiomatic\ndef calculate_price(items: list[Item], discount: float = 0.0) -> float:\n    return sum(i.price for i in items) * (1 - discount)\n\n# List comprehensions are idiomatic\nprices = [item.price for item in items if item.available]\n\n# Dataclasses are idiomatic\nfrom dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass Order:\n    id: int\n    user_id: int\n    total: float\n\n# Context managers are idiomatic\nwith open('file.txt') as f:\n    data = f.read()\n```"
                },
                "dont": {
                  "description": "Don't flag idiomatic Python patterns as violations",
                  "content": "Flag Python list comprehension as violation (WRONG - it's idiomatic). Flag type hints as unnecessary (WRONG - they're idiomatic and improve code quality)."
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Respect JavaScript idioms",
                  "content": "```javascript\n// Arrow functions are idiomatic\nexport function calculatePrice(items, discount = 0) {\n  return items.reduce((sum, i) => sum + i.price, 0) * (1 - discount);\n}\n\n// Destructuring is idiomatic\nconst { user, cart, taxRate } = request;\nconst [first, second, ...rest] = items;\n\n// Async/await is idiomatic\nasync function fetchUser(userId) {\n  const response = await fetch(`/users/${userId}`);\n  return response.json();\n}\n\n// Optional chaining and nullish coalescing are idiomatic\nconst userName = user?.profile?.name ?? 'Guest';\nconst port = config.port ?? 3000;\n```"
                },
                "dont": {
                  "description": "Don't flag idiomatic JavaScript patterns as violations",
                  "content": "Flag arrow function as violation (WRONG - it's idiomatic). Flag destructuring as complex (WRONG - it's idiomatic and improves readability)."
                }
              }
            ]
          }
        },
        {
          "description": "Consider code context when identifying violations. Code in test files, scripts, or prototypes may have different standards than production code.",
          "examples": {
            "python": [
              {
                "do": {
                  "description": "Consider context appropriately",
                  "content": "```python\n# Test file: Longer functions acceptable for test setup\ndef test_complex_order_processing():\n    user = create_test_user()  # DO: Magic numbers OK in tests\n    cart = create_test_cart()\n    # ... 30+ lines of test setup is acceptable\n    assert process_order(user, cart) == expected\n\n# Script: Magic numbers acceptable for one-off utilities\nif __name__ == '__main__':\n    port = 8080  # DO: Magic number OK in script\n    host = 'localhost'  # DO: No need for constants in one-off scripts\n    run_server(host, port)\n\n# Production code: Stricter standards\nSERVER_PORT = 8080  # DO: Use constants in production\nSERVER_HOST = 'localhost'\n```"
                },
                "dont": {
                  "description": "Don't apply same standards to all contexts",
                  "content": "```python\n# WRONG: Flagging magic numbers in test files as critical violations\ndef test_user_creation():\n    user = User(age=18)  # DON'T: Flag as critical violation (WRONG - context matters)\n    assert user.is_adult()\n\n# WRONG: Flagging longer test setup functions as critical\ndef test_complex_scenario():\n    # ... 25 lines of test setup\n    # DON'T: Flag as critical violation (WRONG - test context allows longer functions)\n    assert result == expected\n```"
                }
              }
            ],
            "javascript": [
              {
                "do": {
                  "description": "Consider context appropriately",
                  "content": "```javascript\n// Test file: Longer functions acceptable for test setup\ntest('complex order processing', () => {\n  const user = createTestUser();  // DO: Magic numbers OK in tests\n  const cart = createTestCart();\n  // ... 30+ lines of test setup is acceptable\n  expect(processOrder(user, cart)).toBe(expected);\n});\n\n// Script: Magic numbers acceptable for one-off utilities\nif (require.main === module) {\n  const port = 8080;  // DO: Magic number OK in script\n  const host = 'localhost';  // DO: No need for constants in one-off scripts\n  runServer(host, port);\n}\n\n// Production code: Stricter standards\nconst SERVER_PORT = 8080;  // DO: Use constants in production\nconst SERVER_HOST = 'localhost';\n```"
                },
                "dont": {
                  "description": "Don't apply same standards to all contexts",
                  "content": "```javascript\n// WRONG: Flagging magic numbers in test files as critical violations\ntest('user creation', () => {\n  const user = new User({ age: 18 });  // DON'T: Flag as critical violation (WRONG - context matters)\n  expect(user.isAdult()).toBe(true);\n});\n\n// WRONG: Flagging longer test setup functions as critical\ntest('complex scenario', () => {\n  // ... 25 lines of test setup\n  // DON'T: Flag as critical violation (WRONG - test context allows longer functions)\n  expect(result).toBe(expected);\n});\n```"
                }
              }
            ]
          }
        }
      ]
    }
  },
  "prompt_templates": {
    "context_clarification": {
      "clarification_instructions": {
        "template": "**CRITICAL WORKFLOW ENFORCEMENT - NO EXCEPTIONS:**\n\nWhen moving to ANY behavior, you MUST start at the clarification action (first action). Do NOT skip clarification or planning stages. Do NOT make assumptions about whether clarification/planning has been done. The user can explicitly tell you to skip, but you must NEVER skip on your own initiative.\n\n**MANDATORY WORKFLOW RULE:**\n- You MUST go through clarification for EVERY behavior\n- Do NOT skip clarification stage\n- Do NOT make assumptions about whether clarification has been done\n- The user can explicitly tell you to skip, but you must NEVER skip on your own\n- Present ALL required questions and wait for answers before proceeding\n\n**MANDATORY CLARIFICATION PROCESS:**\n1. Review all provided context (code files, existing violations reports, conversation history, etc.)\n2. For EACH required question below, THOUGHTFULLY attempt to answer it yourself using the available context\n3. When answering questions:\n   - ACTUALLY ANSWER THE QUESTION - don't just list available options without answering\n   - If the question asks \"what file\", answer what file IS based on context\n   - If the question requires a CHOICE/DECISION from the user, identify the available options/deltas and ask the user to choose\n   - Be thoughtful and specific in your answers based on what's available in context\n4. Place your answers directly with each question in the format:\n   **Question:** [question text]\n   **Answer:** [your thoughtful answer based on context]\n   OR if a choice is needed:\n   **Answer:** [your answer based on context]. **Available options:** [list options]. **Which option do you want to choose?**\n   OR if information is missing:\n   **Answer:**  **NOT ENOUGH INFORMATION - REQUIRES USER INPUT**\n5. Be EXPLICIT and CLEAR when you cannot answer a question - use \" **NOT ENOUGH INFORMATION - REQUIRES USER INPUT**\" so the user knows they must provide this information\n6. Do NOT guess or infer answers - if information is not clearly available in context, state that user input is required\n7. When a question requires a decision/choice, identify the available deltas/options from context and ask the user to select\n8. Present ALL questions with your answers to the user\n9. Ask the user to review, confirm, correct, or provide missing answers\n10. Do NOT proceed until the user has reviewed and confirmed/corrected all answers\n\nAssess the provided context against the required questions and evidence below.\n\n**Required Key Questions:**\n{{key_questions}}\n\n**Required Evidence:**\n{{evidence}}\n\nFor each question, provide a thoughtful answer based on available context. If the question requires a choice/decision, identify available options and ask the user to choose. If the answer cannot be determined from available context, clearly state \" **NOT ENOUGH INFORMATION - REQUIRES USER INPUT\".",
        "description": "Instructions for AI to assess context and identify missing information"
      },
      "context_sufficient": {
        "template": "Context validation complete. The following key questions were answered:\n{{key_questions_answered}}\n\nThe following evidence was provided:\n{{evidence_provided}}\n\nProceeding to planning stage.",
        "description": "Used when context is sufficient to proceed"
      },
      "context_insufficient": {
        "template": "Context validation indicates missing information. The following key questions still need answers:\n{{missing_key_questions}}\n\nThe following evidence is still required:\n{{missing_evidence}}\n\nPlease provide the missing information to proceed.",
        "description": "Used when context is insufficient and more information is needed"
      }
    },
    "planning": {
      "planning_instructions": {
        "template": "**CRITICAL WORKFLOW ENFORCEMENT - NO EXCEPTIONS:**\n\nYou MUST go through planning AFTER clarification for EVERY behavior. Do NOT skip planning stage. Do NOT make assumptions about whether planning has been done. The user can explicitly tell you to skip, but you must NEVER skip on your own initiative.\n\n**MANDATORY WORKFLOW RULE:**\n- You MUST go through planning AFTER clarification for EVERY behavior\n- Do NOT skip planning stage\n- Do NOT make assumptions about whether planning has been done\n- The user can explicitly tell you to skip, but you must NEVER skip on your own\n- Present ALL decision criteria and assumptions, get user selections before proceeding\n\n**CRITICAL: Previous Clarification and Planning Data:**\nThe clarification and planning data from previous stages has been loaded and is shown above. You MUST review and reference this data when presenting assumptions and decision criteria. Previous decisions and assumptions inform the current planning session.\n\nPresent the following assumptions and decision criteria to the user and ask for their opinion on key decisions.\n\n**Typical Assumptions:**\n{{assumptions}}\n\n**Decision Making Criteria:**\n{{decision_criteria}}\n\nPresent these assumptions and decision criteria to the user. Ask them to review the assumptions and select their preferred criteria/options for each decision point.\n\n**MANDATORY STORAGE STEP:** After user confirms decisions, you MUST call `agent_store_planning()` MCP tool with:\n   - `decisions_made`: dict mapping decision keys to selected options/values\n   - `assumptions_made`: dict mapping assumption keys to assumption content\n   - The MCP tool will automatically save these to planning.json under the current behavior's section\n   - Example: decisions_made={'analysis_depth': 'Deep analysis', 'severity_threshold': 'Report all violations'}",
        "description": "Instructions for AI to present assumptions and decision criteria to user, and store planning decisions"
      },
      "assumptions_and_criteria": {
        "template": "Planning Assessment:\n\n**Assumptions I will make:**\n{{assumptions_list}}\n\n**Decision Criteria Available:**\n{{decision_criteria_questions}}\n\n**Options for each criterion:**\n{{criteria_options}}\n\nPlease review the assumptions and select your preferred criteria/options.",
        "description": "Used to present assumptions and decision criteria to user"
      },
      "high_level_assessment": {
        "template": "Based on your selections, here's my approach:\n\n**Selected Criteria:**\n{{selected_criteria}}\n\n**High-Level Assessment:**\n{{high_level_assessment}}\n\n**Reasoning:**\n{{reasoning}}\n\nPlease confirm if this approach is correct, or provide feedback for adjustments.",
        "description": "Used to present high-level assessment after user selects criteria"
      }
    },
    "generate": {
      "build_instructions": {
        "template": "**MANDATORY: Before generating any content, you MUST load and review the project's clarification.json and planning.json files from the project's docs/ directory. These files contain critical requirements, decisions, and context that MUST be incorporated into all generated content.**\n\n**CRITICAL: Load planning.json and check for the current behavior's section (e.g., 'code'). Reference decisions_made and assumptions_made for the current behavior.**\n\n**CRITICAL: Load clarification.json to determine the specialization (python, javascript, or both). When loading rules examples, use the examples keyed by the specialization. For example, if specialization is 'python', use examples.python; if 'javascript', use examples.javascript; if 'both', include examples from both specializations.**\n\nGenerate structured code design following the rules and schema provided.\n\n**Rules:**\n{{behavior_rules}}\n\n**Specialization:** {{specialization}} (determine from clarification.json - use this to select the correct examples from rules)\n\n**Schema:** Use schema '{{schema}}'\n\n**Description:** {{description}}\n\n**Instructions:** {{instructions}}\n\n**CONTEXT AWARENESS:**\n- Check if code already exists at the target location\n- If code exists: Analyze it, identify violations, and propose improvements\n- If no code exists: Generate clean code design based on requirements\n- Load inputs from previous phases (stories, domain maps, BDD tests) as specified in planning decisions\n- Follow architecture and dependency management decisions from planning\n- Ensure single responsibility, dependency injection, proper layering\n\nGenerate the structured content according to the schema and rules above, ensuring all requirements from clarification.json and planning.json (especially the current behavior's decisions_made and assumptions_made) are incorporated.\n\n**AUTOMATIC PROGRESSION: After completing build_structure and storing the structured content, automatically proceed to validate action without stopping or waiting for user confirmation. These two actions should execute sequentially as a single workflow step.**",
        "description": "Instructions for AI to generate structured code design following rules and schema"
      },
      "initial_prompt": {
        "template": "Generate {{content_type}} with the following context:\n\n**Confirmed Assumptions:**\n{{confirmed_assumptions}}\n\n**Decision Criteria Applied:**\n{{applied_criteria}}\n\n**Approach:**\n{{approach_summary}}\n\n{{behavior_specific_instructions}}",
        "description": "Base prompt for generation, gets behavior-specific instructions injected"
      }
    },
    "validate": {
      "validation_instructions": {
        "template": "**MANDATORY: Before validating any content, you MUST load and review the project's clarification.json and planning.json files from the project's docs/ directory. These files contain critical requirements and decisions that MUST be checked against during validation.**\n\n**CRITICAL: Load planning.json and check for the current behavior's section (e.g., 'code'). Reference decisions_made and assumptions_made for the current behavior.**\n\n**CRITICAL: Load clarification.json to determine the specialization (python, javascript, or both). When evaluating rules, use the examples keyed by the specialization. For example, if specialization is 'python', use examples.python; if 'javascript', use examples.javascript; if 'both', include examples from both specializations.**\n\n**Instructions:**\n1. Load and review clarification.json and planning.json to understand all requirements and decisions\n2. Determine specialization from clarification.json (python, javascript, or both)\n3. Check planning.json for the current behavior's decisions_made and assumptions_made sections\n4. Evaluate the Content Data against all rules listed above, using the correct examples for the specialization\n5. Check for violations of each rule\n6. Verify that Content Data incorporates all requirements from clarification.json and planning.json (especially the current behavior's decisions_made and assumptions_made)\n7. Generate a validation report with:\n   - List of all violations found (if any)\n   - Specific examples from the Content Data that violate rules\n   - Any missing requirements from clarification.json or planning.json (including stage-specific decisions/assumptions)\n   - Recommendations for fixing violations\n8. If no violations found, confirm that Content Data follows all rules and incorporates all requirements",
        "description": "Instructions for AI to evaluate violations report against rules and generate validation report"
      },
      "validation_results": {
        "template": "Validation Results:\n\n**Status:** {{validation_status}}\n\n**Violations Found:**\n{{violations_list}}\n\n**Recommendations:**\n{{recommendations}}\n\nIf violations are found, you may regenerate the code design to address them.",
        "description": "Used to present validation results to user"
      }
    }
  },
  "trigger_words": {
    "validate": {
      "patterns": [
        "check.*against.*rule",
        "validate.*content",
        "verify.*compliance",
        "validate.*violations"
      ],
      "priority": 5
    },
    "build_structure": {
      "patterns": [
        "create.*structure",
        "build.*content",
        "generate.*violations",
        "analyze.*code"
      ],
      "priority": 5
    }
  },
  "mcp": {
    "server_name": "agent-{agent_name}",
    "command": "python",
    "args": [
      "agents/base/src/agent_mcp_server.py",
      "{agent_name}"
    ],
    "cwd": "{workspace_root}",
    "env": {
      "AGENT_NAME": "{agent_name}",
      "PYTHONPATH": "{workspace_root}"
    }
  }
}

