---
description: Domain-Driven Design analysis principles for extracting domain structures and interaction flows
globs: ["**/*.md", "**/*.txt", "**/*.mdc", "**/*.js", "**/*.ts", "**/*.py", "**/*.mjs", "**/*-domain-map.*", "**/*-domain-interactions.*"]
alwaysApply: false
---
**When** analyzing code, text, or diagrams to extract domain models and interaction flows,
**then** follow these principles to create clear, business logic-centered domain representations.

Domain analysis identifies core business concepts, their relationships, organizing principles, and interaction flows. The goal is to map from the user's mental model and business processes, not the code's structure.

**Executing Commands:**
* `/ddd-structure` — Analyze file/code/text to extract domain structure
* `/ddd-interaction` — Document domain concept interactions and business flows

---

## Conventions

Naming conventions, file locations, and structural conventions for domain analysis outputs:

* **Domain map naming**: `<system-name>-domain-map.txt` (hierarchical structure)
* **Interaction file naming**: `<system-name>-domain-interactions.txt` (scenario-based flows)
* **File location**: Place in same directory as source code being analyzed
* **Output format**: Text-based hierarchical structures (NOT JSON)
* **Indentation**: Use tabs for nesting levels in domain maps
* **Concept naming**: Nouns for concepts, verbs for behaviors
* **Relationship notation**: Embedded within each concept (not separate section)

---

## 1. Use Outcome Verbs, Not Communication Verbs

Each verb should describe the actual outcome or artifact being created, not the act of communicating/presenting information. If you can ask 'showing WHAT?' or 'displaying WHAT?', the verb is too generic—use what comes after instead.

**[DO]:**
* Use verbs that describe artifacts/outcomes: "Animation", "Feedback", "Indicators", "Configuration"
* Name concepts by what they ARE or CREATE: "Power Activation Animation", "Combat Outcome Feedback"
* Focus on tangible results: "Hit Indicators", "Save Result Feedback"
* Use domain-specific action verbs: "animates", "triggers", "composes", "orchestrates"

**[DON'T]:**
* Use generic communication verbs: "showing", "displaying", "visualizing", "presenting"
* Use vague enablement verbs: "providing", "enabling", "allowing"
* Name concepts by their mechanism: "Visualizing Power Activation", "Showing Combat Results"
* Focus on presentation: "Display System", "Show Component"

## 2. Integrate System Support Into Domain Concepts

When you see 'SYSTEM SUPPORT FOR X' or other system type sections that contain lots of references to other domain sections, ask: does this implement the exact same functional capability as section X, just showing technical details? If yes, nest and integrate the system support UNDER the domain concept it implements, not as a separate section.

**[DO]:**
* Nest technical implementation under the domain concept it serves
* Integrate "how" under "what" when they serve the same functional goal
* Keep implementation details close to the feature they implement
* Group by functional capability, not code organization

**[DON'T]:**
* Separate domain concepts from their implementations into parallel sections
* Create "SYSTEM SUPPORT" sections that duplicate domain structure
* Organize by code boundaries (services, models, controllers)
* Split concepts users see as one thing into multiple sections

## 3. Order by User Mental Model, Not Code Structure

Order concepts by user's mental model: what do they encounter first and what builds on what? If something labeled 'Technical Implementation' contains the core objects users interact with, ensure it's a primary domain concept that other features build upon.

**[DO]:**
* Order concepts by user encounter sequence
* Put foundational objects BEFORE features that use them
* Start with core domain objects (PowerItem, User, Vehicle)
* Follow with operations on those objects
* End with supporting infrastructure
* Ask: "What builds on what?" from user perspective

**[DON'T]:**
* Order by code structure (models, services, controllers)
* Hide core objects in "Technical Implementation" sections
* Start with features before introducing the objects they operate on
* Follow code dependency graphs instead of user understanding flow

## 4. Organize by Domain First, System Support Second

Organize by what the user understands (domain concepts) not by how the code is structured (system layers). Favor domain-specific concepts over system-level concepts.

**[DO]:**
* Lead with domain-specific concepts (Powers, Combat, Vehicles, Users)
* Name sections by business capabilities: "Power Activation", "Payment Processing"
* Group related domain concepts together
* Put system infrastructure at the end
* Frame purpose from functional perspective: "Make powers feel distinct"

**[DON'T]:**
* Lead with system concepts (Events, UI, Services, Data Layer)
* Name sections by technical layers: "Presentation Layer", "Business Logic"
* Mix domain and system concepts at same level
* Frame purpose from technical perspective: "Render visual effects"

## 5. Refine Scope to Functional Accomplishment

Refine scope of the domain to what is actually being accomplished from a functional perspective. Frame domains by what they accomplish for users, not by their technical implementation.

**[DO]:**
* Focus on functional outcomes, not mechanisms
* Frame domains by what they accomplish for users
* Ask: "What does this enable the user to do or understand?"
* State the transformation or capability provided
* Be specific about the functional benefit

**[DON'T]:**
* Frame domains by their technical implementation
* Focus on "how" before "what"
* Use generic system capabilities as domain names
* Describe mechanisms instead of outcomes

## 6. Maximize Integration of Related Concepts

Related concepts that serve the same functional goal should be maximally integrated, not artificially separated by code boundaries. If two concepts always work together from the user's perspective, they should be presented together.

**[DO]:**
* Group concepts that the user sees as one capability
* Nest implementation details under the feature they serve
* Keep related data and operations together
* Eliminate artificial boundaries based on code organization

**[DON'T]:**
* Separate related concepts into different major sections
* Split based on code layers (data, business, presentation)
* Duplicate related concepts across multiple sections
* Create gaps that break the user's mental model

## 7. Domain Concepts Are Nouns, Behaviors Are Verbs

Domain concepts should be named as nouns (things that exist), and their operations should be described as behaviors (verbs). If a verb feels important enough to be its own concept, it must have state and logic of its own - then it becomes a noun.

**[DO]:**
* Name domain concepts as nouns: "Animation", "Power Item", "Sequence", "Configuration"
* Describe what the concept IS first, then what it DOES
* Use verbs to describe behaviors on concepts: "Resolves animation", "Executes when triggered"
* If a verb has its own state/logic, make it a noun concept

**[DON'T]:**
* Name domain concepts as verbs or gerunds: "Animation Resolution", "Animation Execution"
* Use "-ing" forms for concept names: "Animating", "Resolving", "Processing"
* Create separate concepts for "Doing X" vs "X" - combine them
* Hide the noun form - always lead with what the thing IS

## 8. Assign Behaviors to the Concept That Performs Them

Always assign behaviors to the domain concept that actually performs them, not to the result or output. Ask "Who does this?" or "What class/object contains this logic?" to determine correct placement.

**[DO]:**
* Place behavior under the concept that contains the logic
* Ask "Whose responsibility is this?" when placing behaviors
* Look at the code - which class has the method?
* Put creation logic with the creator, not the created
* Assign resolution logic to the resolver, not the resolved

**[DON'T]:**
* Place behavior under the result/output concept
* Assign behavior based on what it produces
* Put logic under the artifact it creates
* Organize by data flow instead of responsibility

## 9. Avoid Noun Redundancy in Domain and Concept Names

When multiple domains or concepts share the same root noun, they create ambiguity and suggest poor separation of concerns. PREFER INTEGRATION - nest related concepts under one domain. Only use distinct nouns when domains truly serve different purposes that cannot be integrated.

**[DO]:**
* INTEGRATE first: nest related capabilities under one domain (90% of cases)
* Only then rename: use distinct nouns ONLY when integration doesn't make sense
* Test for uniqueness: can you remove the qualifier and still know what it is?
* Use subject-area nouns when domains are genuinely separate

**[DON'T]:**
* Rename without considering integration (this hides the real issue)
* Repeat same noun with different prefixes: "X Animation", "Y Animation", "Z Animation"
* Use vague qualifiers to avoid integration: "Animation 1", "Animation System"
* Create parallel domains that should be nested

## 10. Organization: Domain Concepts Over File Structure

Organize around domain concepts (what things ARE and what you DO with them), not file structure, code organization, or technical artifacts. If you find yourself organizing by file types or technical layers, stop and reorganize around user-facing capabilities.

**[DO]:**
* Organize by domain concepts: "Behavior" with nested capabilities
* Ask: "What is this domain about?" not "What files does it have?"
* Group by functional capability
* Name sections by what they accomplish: "Validation", "Creation", "Deployment"

**[DON'T]:**
* Organize by file types: "Rule Files", "Command Files", "Runner Files"
* Organize by technical structure: "Configuration Layer", "Execution Layer"
* Split capabilities across multiple sections
* Name sections by artifacts: "Documentation", "Scripts", "Configs"

## 11. Domain Interaction Analysis

When documenting how domain concepts interact to fulfill business scenarios, maintain the same abstraction level as the domain map, focusing on domain concept flows rather than implementation details.

### 11.1 Maintain Domain-Level Abstraction

Speak at the same abstraction level as the domain map. Only get specific when describing business transformations, business lookups, or business rules. Never include technical implementation details.

**[DO]:**
* Refer to domain concepts by name from domain map
* Describe business transformations (PowerItem to Animation configuration)
* Describe business lookups and validations (finds macro by priority, matches power by type)
* Describe business rules (teleport cancels drag, attached takes precedence)
* Mention platform/external APIs at high level (Foundry triggers hook)
* Focus on what business concept does and why

**[DON'T]:**
* Include field names, property paths, or data structure details
* Show HTML queries, DOM manipulation, or UI framework calls
* Display code syntax, variable names, or function signatures
* List CSS properties, styling details, or visual implementation
* Show API parameters, configuration objects, or technical schemas

### 11.2 Structure Scenarios as Business Flows

Structure each scenario to show a complete business flow from trigger to result. Focus on domain concept participation and business logic, not code execution.

**[DO]:**
* Start with business event or trigger
* List domain concepts that participate (Actors)
* Show domain concept interactions in Flow
* Describe transformations (Object A to Object B)
* Describe lookups (finds by pattern, searches by type)
* State business rules clearly
* End with business result

**[DON'T]:**
* Show code execution flow with function calls
* List function parameters or variable assignments
* Include error handling or logging details
* Show conditional logic (if/else)
* Focus on implementation sequence

### 11.3 Describe Transformations at Business Level

Describe business transformations showing what changes from one domain concept to another and why, without implementation details.

**[DO]:**
* State source and target concepts clearly
* Describe business purpose of transformation
* Mention key characteristics extracted/added
* Use arrow notation for clarity (Source to Target)

**[DON'T]:**
* Show constructor calls or object creation code
* List every field being copied
* Include data type conversions
* Show object mapping logic

### 11.4 Describe Lookups as Business Strategy

Describe business lookup logic showing search strategy and matching criteria without implementation details.

**[DO]:**
* Describe search strategy (priority order, pattern matching)
* State matching criteria as business rules
* Show fallback logic as business flow
* Use domain terminology

**[DON'T]:**
* Show database queries or API calls
* Include search algorithms or iteration code
* List filter functions or predicates
* Show null checking or error handling

### 11.5 State Business Rules as Domain Logic

State business rules, priorities, and constraints clearly as domain logic, not code conditionals.

**[DO]:**
* State priorities as ordered lists
* Describe special cases as business rules
* Explain why rules exist (business rationale)
* Use domain terminology

**[DON'T]:**
* Show if/else code structure
* Include boolean logic operators
* List edge case handling code
* Show validation implementation

## Commands

Commands that implement or use this rule:

* `/ddd-structure` — Analyze code/text/diagrams to extract domain structure
* `/ddd-structure-generate` — Generate domain structure analysis
* `/ddd-structure-validate` — Validate domain structure against DDD principles
* `/ddd-interaction` — Document domain concept interactions and business flows
* `/ddd-interaction-generate` — Generate domain interaction analysis
* `/ddd-interaction-validate` — Validate interaction analysis against DDD principles

## Executing Commands
* /ddd-ddd-interaction — Document domain interactions and business flows

* /ddd-ddd-structure — Analyze code/text/diagrams to extract domain structure
