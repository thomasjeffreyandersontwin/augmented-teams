---
alwaysApply: true
---

## BDD Testing Checklist

### When Building Test Skeletons
✅ **Natural phrasing** - Describes + it() read as complete sentence  
✅ **Describes use NOUNS/STATES** - A concept, condition, or state (may be in response to an action or event)  
✅ **it() uses "should" + RESULT** - A reaction defined as a more detailed state, reaction, or response  
✅ **Test concrete system behavior** - Test functions that encapsulate business logic using behavioral language 
✅ **Be comprehensive** - Cover existence, state, validation, calculations, business rules, lookups, interactions
✅ **Test interaction steps sequentially** - Create describes at the same level for each interaction step  
✅ **Test across architecture layers** - Domain, front-end, events using stubs and mocking  
❌ **Don't express technical setup** - Focus on user interactions and behavior  

### When Organizing Tests
✅ **Hierarchical describes** - Start with broad overarching concepts, refine more specific concepts with nesting  
✅ **Build scenarios step-by-step** - Each describe adds context 
✅ **Connect nested describes and it() into complete sentences** - "An Attack Power converted from a legacy pouvoir, that is a standard power, that is a ranged power should have a range distance equal to X times the effect rank of the original pouvoir"

### When Implementing Tests
✅ **Reuse helpers and variables** - Share as much as possible; place at lowest feasible scope while sharing across describes  
✅ **Factory helper functions** - Chain using beforeEach stacking to decorate broader test objects with specialized properties  
✅ **Naming conventions** - Use `create*()`, `make*()`, `add*ToActor()` patterns  
✅ **Single factory instance** - Reuse one MockFoundryFactory instance with reset() to return clean stubs/mocks


---

## Detailed Guidelines

### 1. Describes Use NOUNS/STATES

**Explanation:** Describe blocks set the scene/context using noun phrases that describe concepts, states , sonditions They answer "what" or "in what state", or even "what action" has taken place. Avoid use verb noun style often seen in xSpec Given/When/Then or user story format. Test are meant to enable an object oriented and domain oraiented approach.

**✅ DO:**
```python
from mamba import description, context

with description('a ranged damage power'):
    with context('that has targeted and resulted in a successful attack'):
        with context('that the target has rolled a resistance save against'):
            pass
```

**❌ DON'T:**
```python
with description('when attacking a target'):  # "attacking" = action verb
    pass
with description('converting powers'):  # "converting" = action verb
    pass
```

---
### 2. it() Uses "should" + RESULT

**Explanation:** Test names state expected results as assertions. Start with "should" followed by either verb or condition describing the expected result.

**✅ DO:**
```python
from mamba import it
from expects import expect

with it('should be a ranged attack'):
    expect(attack.is_ranged).to.equal(True)

with it('should calculate DC from the targets dodge'):
    expect(attack_result.DC).to.equal(20)

with it('should apply injury to target'):
    expect(target.injury).to.equal(2)
```

**❌ DON'T:**
```python
with it('the attack is ranged'):  # Missing "should"
    pass
with it('checks if ranged'):  # Action, not assertion
    pass
```

---

### 3. Context Inheritance - Don't Repeat Parent

**Explanation:** Each describe inherits all context from its parent. Only add NEW information in child describes. Don't repeat what the parent already established.

**✅ DO:**
```python
with description('and powers are converted to attacks'):
    with it('should have the same effect name and rank as the original power'):
        expect(attack.effect_name).to.equal(power.effect_name)
    
    with context('an attack converted from a damage power'):
        with it('should have the same resiliency type as the original power'):
            expect(attack.resiliency_type).to.equal(power.resiliency_type)
```

**❌ DON'T:**
```python
with description('and powers are converted to attacks'):
    with it('should have the same effect name and rank as the original power'):
        pass
    
    with context('a converted attack from damage'):
        with it('should have the same effect name and rank as the original power'):  # repeats name and rank
            pass
        with it('should have the same resiliency type as the original power'):
            pass
```

---

### 4. Be Comprehensive

**Explanation:** Create tests that comprehensively cover all aspects of system behavior: existence, state, validation, calculations, business rules, lookups, and interactions. Don't just test one aspect - ensure complete coverage.

**✅ DO:**
```python
with description('a damage attack converted from a ranged power'):
    with it('should be an Attack'):  # existence
        expect(attack.is_attack).to.equal(True)
    
    with it('should have the effect type, rank, and name properties'):  # state
        expect(attack.effect_type).to.be.an(str)
        expect(attack.rank).to.be.a(int)
        expect(attack.name).to.be.a(str)
    
    with it('should calculate toHit from the its characters total Dexterity rank plus combat skill rank'):  # calculations
        expect(attack.to_hit).to.equal(actor.dexterity + actor.combat_skill)
    
    with context('that has targeted another actor and has executed an attack'):
        with it('should roll to hit against target dodge'):  # Interactions
            result = attack.roll_to_hit()
            expect(result.target).to.equal(target)
        
        with it('should determine hit based on roll vs DC'):  # business rule
            expect(attack_result.hit).to.equal(True)
        
        with context('that has hit the target'):
            with it('should trigger a resistance roll for target'):  # interactions
                expect(target.resistance_rolled).to.equal(True)
            
            with context('that is failed by the target'):
                with it('should calculate damage based on degrees of failure'):  # Calculations
                    expect(resistance_result.damage).to.equal(expected_damage)
                
                with it('should apply that damage to the target'):  # interactions
                    expect(target.injury).to.equal(damage_amount)
                
                with it('should apply a condition to the target based on how badly the damage save was failed'):
                    expect(target.condition).to.not.be.none
```

**❌ DON'T:**
```python
with description('a damage attack'):
    with it('should apply damage'):  # Only testing interactions, missing state, calculations, business rules
        attack.apply_damage(target)
        expect(target.damaged).to.equal(True)
```

---

### 5. Factory Pattern with beforeEach Stacking

**Explanation:** Use factory functions to create test objects. Start with base factory at top level, then use `beforeEach` at each nested describe to progressively decorate the object with more specific properties.

**✅ DO:**
```python
from mamba import description, context, it, before_each

power = None
attack = None
ranged_attack = None

with description('a Power'):
    with before_each:
        power = create_expected_power()  # Base
    
    with context('that is converted to an attack'):
        with before_each:
            attack = create_expected_attack(power)  # Add attack
        
        with context('that is ranged'):
            with before_each:
                ranged_attack = create_expected_ranged_attack(attack)  # Specialize
```

**❌ DON'T:**
```python
with description('a Power'):
    power = None
    with before_each:
        power = {...}  # Base
    
    with context('that is converted to an attack'):
        with before_each:
            attack = None
            power_parent = None
            with before_each:  # Nested before_each invalid
                power_parent = {...}
                attack = {...}
        
        with context('that is ranged'):
            ranged_attack = None
            with before_each:
                range_power_parent = {...}
                ranged_attack = {...}
```

---

### 6. Single Factory Instance with Reset

**Explanation:** Use MockFactories for families of objects we want to stub or mock eg a single platform.  Reset before each test using top-level `beforeEach`. This keeps management of mocks as well as documwentation of api usage in a centralized place.
**✅ DO:**
```python
mock_factory = MockFoundryFactory()

with before_each:
    mock_factory.reset()  # Runs before ALL tests
```

**❌ DON'T:**
```python
with before_each:
    mocks = MockFoundryFactory()  # New instance each time
```

---

### 7. Place Setup at Correct Describe Level

**Explanation:** Place `beforeEach` and variables in the describe that semantically and positionally matches what they set up. If multiple nested describes need the same data, place it in their common parent describe.

**✅ DO:**
```python
tokens = None

with description('a token on the scene'):
    with before_each:
        tokens = get_tokens()
    
    with context('that has been clicked'):
        # uses tokens
        pass
    
    with context('that has been dragged to a new position on the scene'):
        # uses tokens
        pass
```

**❌ DON'T:**
```python
with description('a token on the scene'):
    with context('that has been clicked'):
        tokens = None
        with before_each:
            tokens = get_tokens()  # Should be in parent
    
    with context('that has been dragged to a new position on the scene'):
        tokens = None
        with before_each:
            tokens = get_tokens()  # Should be in parent
```

---

### 8. Test Both Data and Rendering (UI Tests)

**Explanation:** For UI tests, verify BOTH the data structure passed to templates (context) AND the rendered HTML output. This ensures templates receive correct data AND render it correctly.

**✅ DO:**
```python
with it('should include attack bonus in context'):
    expect(context['attack_powers'][0]['bonus']).to.equal(8)  # Data

with it('should render attack bonus in HTML'):
    expect(html).to.contain('value="8"')  # Rendering
```

**❌ DON'T:**
```python
with it('should render attack bonus'):
    expect(html).to.contain('value="8"')  # Only HTML, not data
```

---

### 9. Extract Long Blocks into Named Helpers

**Explanation:** When code exceeds ~10-15 lines or needs a comment to explain it, extract into a named helper function. Function names are self-documenting. Functions can be used for test data setup, complex expects, data marshalling, and simplifying API calss

**✅ DO:**
```python
async def convert_powers_to_attacks(actor_id):
    # ...
    pass

with before_each:
    await read_power_from_character_sheet(actor_id, power_id)
```

**❌ DON'T:**
```python
with before_each:
    # Open actor character sheet, and read power into a data object for simple expect matching
    # ... 60 lines of complex setup ...
    result = await page.evaluate(lambda a_id, p_id: ..., actor_id, power_id)
```

---

### 10. Use Natural Language - Not Technical Terms

**Explanation:** Test names should read like natural English describing what something IS or HAS, not technical implementation details like "flags" or "marked as".

**✅ DO:**
```python
with it('should be a multiattack'):
    expect(attack.is_multiattack).to.equal(True)

with it('should be ranged'):
    expect(attack.is_ranged).to.equal(True)
```

**❌ DON'T:**
```python
with it('should be flagged as "M" in the ATTACK_M flag field'):
    expect(attack.flags['ATTACK_M']).to.equal('M')

with it('should have range flag set to "R"'):
    expect(attack.range_flag).to.equal('R')
```

---

## Types of Tests

### 1. Micro Tests (Mamba)
Run in vanilla Python with mocked/stubbed objects. Test logical flow of behavior across UI and domain layers while stubbing out dependencies.

**1a) Domain Tests** all of the above guidelines apply and apply exactly
When executing tests
- **Fast execution** - Target ~under 5 seconds for full test suite
- **Clean output** - Avoid unnecessary console logs
- **ALway Use Claude Debugs For You MCP server** for analyzing test execution and results - don't build custom scripts for what MCP can do

**1b) UI Tests**
Test UI components in isolation by stubbing dependencies and rendering templates.

**What to Test:**
1. **Helpers** - Context preparation functions (e.g., prepare_context)
2. **Action Handlers** - Button click handlers that call other components
3. **Template Data** - Verify correct data structure passed to templates
4. **Template Rendering** - Verify HTML/output rendering
5. **Messages** - Both message structure AND rendered content

**Key Principle:** Test BOTH the data structure (what goes into the template) AND the rendered output (what users see).

**Example:**
```python
from mamba import description, context, it, before_each
from expects import expect

power = None
actor = None
target = None
attack_result = None
resistance_result = None
context_data = None
html = None
capture = None

with description('a ranged damage power'):
    with before_each:
        actor = mock_factory.create_actor(dexterity=8)
        target = mock_factory.create_target(dodge=10, toughness=6)
        power = create_damage_power(actor, rank=10, range='distance')
    
    with it('should have bonus equal to actor dexterity'):
        expect(power.attack.bonus).to.equal(8)  # STATE: Property value
    
    with context('that has targeted another actor and has executed an attack'):
        with before_each:
            power.attack.targets.add(target)
            # Mock Roll
            attack_result = power.attack.roll_to_hit(mock_roll_total=20)
        
        with it('should calculate DC from target dodge'):
            expect(attack_result.DC).to.equal(20)  # CALCULATION: Formula (dodge + base)
        
        with it('should determine hit based on roll vs DC'):
            expect(attack_result.hit).to.equal(True)  # BUSINESS RULE: Hit determination
        
        with context('on failed resistance save'):
            with before_each:
                resistance_result = attack_result.roll_resistance(mock_roll_total=15)
            
            with it('should calculate degrees of failure'):
                expect(resistance_result.degrees_of_failure).to.equal(2)  # CALCULATION: (DC - roll) / 5
            
            with it('should apply injury to target'):
                resistance_result.apply_to_target()
                expect(target.actor.system.blessure).to.equal(2)  # INTERACTION: State change on target
        
        with context('whose actor data is being displayed on a character sheet'):
            with before_each:
                # Use factory to render sheet with test data
                context_data, html = mock_factory.prepare_attack_sheet_and_render_html(actor, powers)
            
            with it('should include attack data in context'):
                expect(context_data['attack_powers'][0]['bonus']).to.equal(8)  # Test data structure
            
            with it('should render attack bonus in template'):
                expect(html).to.contain('value="8"')  # Test HTML rendering
        
        with context('the attack chat card is displayed'):
            with before_each:
                capture = mock_factory.capture_chat_card_rendering('test-id')
                AttackChatCard.create(attack_result, power)
            
            with it('should create template data with correct structure'):
                data = capture.template_data()
                expect(data['formula']).to.equal('1d20 + 8')  # Verify data
                expect(data['total']).to.equal(18)
            
            with it('should render attack roll in HTML'):
                expect(capture.chat_content()).to.contain('dice-total formula')  # Verify HTML
                expect(capture.chat_content()).to.contain('18')
```

### 2. End-to-End Tests (Playwright)
When building End to End Tests Use Puppeteer with real Foundry instance to validate complete working solutions through user journeys.
- **Single browser setup** in `beforeAll` (once per test file)
- **Browser reuse** across all tests in the file

When running end to end tests
- **always Open Chrome in debug mode** before starting Playwright tests to reuse browser instances across test runs
- **Always Use Chrome MCP dev tools** for analyzing Foundry objects - don't build custom scripts for what MCP can do, dont wait to bwe asked to do this!

**Context Building (Nouns/States):**
- "a loaded foundry game"
- "that is logged into by a GM user" 
- "that has an active scene"
- "with several tokens placed on the scene"
- "when the mouse is hovered over a token"


**Example:**
```javascript
test.describe('a loaded foundry game', () => {
  test.describe('that is logged into by a GM user', () => {
    test.describe('with several tokens placed on the scene', () => {
      let tokens;
      let tokenResults;
      
      beforeEach(async () => {
        // Setup tokens at correct context level
        tokenResults = await page.evaluate(() => {
          tokens = canvas.tokens.placeables;
          return { tokenCount, tokensWithActors };
        });
      });
      
      test.describe('the token hover menu', () => {
        test('it should appear when the mouse is hovered over a token', async () => {
          // Test the actual user behavior
        });
        
        test('action buttons and resource panel should be displayed', async () => {
          // Test composite behavior
        });
      });
    });
  });
});
```

## File Structure
- `better-attacks_test.py` - Main test file for end to end tests
- `attacks_test.py` - main test file for micro tests
- `playwright.config.mjs` - Playwright configuration (for E2E tests)
- `.vscode/tasks.json` - IDE task shortcuts
- `.vscode/launch.json` - Debug configurations
- `.vscode/settings.json` - VS Code integration

## Common AI Mistakes Without These Guidelines

| ❌ Wrong Approach (AI Default) | ✅ Correct BDD Approach |
|-----|---|
| Describes as object names: "AttackResult" | Describes as states: "on failed resistance save" |
| Tests as function names: "should call roll_resistance()" | Tests as behaviors: "should calculate degrees of failure" |
| Test function existence | Test behaviors and outcomes |
| "should be flagged as multiattack" | "should be a multiattack" |
| Repeat parent context in child tests | Inherit context - only add new info |
| Duplicate mock setup code everywhere | Single factory with reset() |
| Create new mock instances each test | Reuse one factory instance |
| Test only HTML OR only data | Test BOTH data structure AND rendering |
| Flat structure or one giant description | Hierarchical context building |
| Verbose test names repeating everything | Concise names relying on parent context |
| Guess what to test | Read file documentation first |
| Build helper scripts for debugging | Use MCP tools (Chrome/Claude Debugs) |
| Test implementation details | Test user-visible behavior |