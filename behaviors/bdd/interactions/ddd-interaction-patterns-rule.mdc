---
description: Domain interaction modeling patterns and practices
globs: ["**/ddd-detailed-interactions.txt", "**/ddd-detailed-model.txt", "**/*-interactions.txt", "**/*-model.txt"]
alwaysApply: false
---
**When** documenting domain interactions and object behaviors,
**then** follow these patterns to create clear, maintainable interaction models.

Domain interaction models show how objects collaborate through explicit method calls and property access, following the scaffold hierarchy.

## 1. Property-Based Access Over Verbose Method Calls

**Do:**
* Use property access instead of verbose method signatures
* Assume objects manage state internally through properties
* Hide logic in property getters/setters
* Set state properties before accessing computed properties
* Use concise property names: `this.rule.specializedRule` not `this.specializingRule.selectSpecializedRule(fileExtension)`

**Don't:**
* Show full method signatures with parameter types and return types
* Repeat verbose method calls: `specializedRule.getExamplesForPrinciple(principleNumber: int): Example[]`
* Expose internal implementation details in property access
* Use `this` references that don't belong to the current context

**Pattern:**
```javascript
// ✅ DO: Property-based access
this.rule.fileExtension = content.fileExtension
specializedRule = this.rule.specializedRule
  // logic hidden in property getter

// ❌ DON'T: Verbose method calls
specializedRule = this.specializingRule.selectSpecializedRule(content.fileExtension: string): SpecializedRule
```

## 2. Nesting Groups Code Under Functions/Properties

**Do:**
* Use indentation to show code belongs to a function/property
* Place all code executed within a function under that function call
* Use dashes under function/property names to visually group code
* Keep nested code indented consistently
* Show internal logic as comments under the function/property

**Don't:**
* Mix code at the same indentation level that belongs to different functions
* Skip nesting when code is clearly part of a function's execution
* Use inconsistent indentation levels
* Place unrelated code under a function call

**Pattern:**
```javascript
// ✅ DO: Clear nesting with dashes
commandRunner.validate(content)
-------------------------------
  this.content = content
  rule = this.rule
    this.loadRuleFromRuleFile()
    ----------------------------------
      this.principles = base.principles
      for each p in this.principles 
        p.examples = this.examples.filter(e => e.principle == p)

// ❌ DON'T: Flat structure, unclear grouping
commandRunner.validate(content)
this.content = content
rule = this.rule
this.loadRuleFromRuleFile()
this.principles = base.principles
```

## 3. Show Details Only on First Call

**Do:**
* Show full interaction details the first time a function/property is called
* Abbreviate subsequent calls with comment: `// (details shown above)`
* Reference where details were shown if called multiple times
* Keep repeated calls concise and clear

**Don't:**
* Repeat full details every time a function is called
* Show verbose implementation details on every call
* Duplicate nested code structures
* Lose track of where details were first shown

**Pattern:**
```javascript
// ✅ DO: Full details first time
specializedRule = this.rule.specializedRule
-------------------------------
  // SpecializingRule : BaseRule
  // logic hidden in property getter - matches fileExtensionPattern
  // for each rule in this.specializedRules
  //   if fileExtension matches rule.fileExtensionPattern
  //     return rule

// Later in same flow:
specializedRule = this.rule.specializedRule  // (details shown above)

// ❌ DON'T: Repeat full details
specializedRule = this.rule.specializedRule
  // SpecializingRule : BaseRule
  // logic hidden in property getter...
// ... (repeated multiple times)
```

## 4. Dashes Under Functions and Properties

**Do:**
* Place dashes directly under function/property names that have nested code
* Use dashes to visually separate function/property from its implementation
* Match dash length approximately to function/property name length
* Use dashes for both functions and properties with nested code
* Keep dash formatting consistent

**Don't:**
* Skip dashes when code is nested underneath
* Use inconsistent dash lengths or styles
* Place dashes incorrectly (too far, too close, misaligned)
* Use dashes for simple property access without nested code

**Pattern:**
```javascript
// ✅ DO: Dashes under functions/properties with nested code
commandRunner.validate(content)
-------------------------------
  this.content = content
  specializedRule = this.rule.specializedRule
  --------------------------------
    // nested logic here

// ❌ DON'T: Missing dashes or inconsistent formatting
commandRunner.validate(content)
  this.content = content
specializedRule = this.rule.specializedRule
    // nested logic here (unclear grouping)
```

## 5. Follow Scaffold Hierarchy

**Do:**
* Structure interactions following the scaffold hierarchy exactly
* Use scaffold comments to organize sections: `// that implements a specializing rule`
* Preserve the nested structure from the scaffold
* Show behaviors in the order they appear in the scaffold
* Reference scaffold sections explicitly

**Don't:**
* Deviate from scaffold hierarchy without reason
* Skip scaffold sections
* Reorder behaviors arbitrarily
* Ignore scaffold structure when documenting interactions

**Pattern:**
```javascript
// ✅ DO: Follow scaffold hierarchy
// that implements a specializing rule
specializedRule = this.rule.specializedRule
  // selects appropriate specialized rule based on file extension pattern

// and the specializing has been loaded
baseRule = specializedRule.baseRule
  // it should have access to the base rule and its principles

// ❌ DON'T: Ignore scaffold structure
specializedRule = this.rule.specializedRule
baseRule = specializedRule.baseRule
// (missing scaffold context)
```

## 6. State Management Through Properties

**Do:**
* Set state properties before accessing computed properties
* Show state changes explicitly: `this.rule.fileExtension = content.fileExtension`
* Assume property getters use internal state
* Document state dependencies in comments
* Show state flow clearly

**Don't:**
* Access properties without setting required state first
* Hide state dependencies
* Assume state is magically available
* Skip showing state initialization

**Pattern:**
```javascript
// ✅ DO: Set state before accessing
this.rule.fileExtension = content.fileExtension
specializedRule = this.rule.specializedRule
  // property getter uses fileExtension state

heuristic.content = content
detectedViolations = heuristic.violations
  // property getter uses content state

// ❌ DON'T: Access without setting state
specializedRule = this.rule.specializedRule
  // (fileExtension not set - unclear how it works)
```

## 7. Comments Explain Logic, Not Replicate Code

**Do:**
* Use comments to explain WHY or WHAT, not replicate code
* Document internal logic that's hidden in property getters
* Explain relationships and dependencies
* Show algorithmic logic in comments when hidden
* Keep comments concise and meaningful

**Don't:**
* Repeat code in comments
* Write obvious comments that add no value
* Use comments to show code that should be in the actual implementation
* Create verbose comment blocks that duplicate structure

**Pattern:**
```javascript
// ✅ DO: Comments explain hidden logic
specializedRule = this.rule.specializedRule
-------------------------------
  // SpecializingRule : BaseRule
  // logic hidden in property getter - matches fileExtensionPattern
  // for each rule in this.specializedRules
  //   if fileExtension matches rule.fileExtensionPattern
  //     return rule

// ❌ DON'T: Comments replicate code
specializedRule = this.rule.specializedRule
  // gets specializedRule
  // returns specializedRule
  // specializedRule is returned
```

## 8. Domain Concept Organization

**Do:**
* Organize interactions by domain concept (like class definitions)
* Group related interactions under the same concept
* Show inheritance relationships: `CodeGuidingCommand : Command`
* Use domain model structure as guide
* Separate base concepts from specialized concepts

**Don't:**
* Mix unrelated interactions
* Ignore domain boundaries
* Flatten concept hierarchy
* Skip showing relationships between concepts

**Pattern:**
```javascript
// ✅ DO: Organized by domain concept
Content {
  commandRunner.validate(content)
  --------------------------------
    // interactions for Content
}

CodeGuidingCommand : Command {
  violationReport = codeGuidingCommand.validate(content)
  ---------------------------------------------
    // interactions for CodeGuidingCommand
}

// ❌ DON'T: Flat, unorganized structure
commandRunner.validate(content)
violationReport = codeGuidingCommand.validate(content)
// (no concept grouping)
```

## 9. Abbreviate Repeated Patterns

**Do:**
* Show full pattern once, then abbreviate
* Use comments to indicate abbreviation: `// Same as base validation`
* Reference where full pattern was shown
* Keep abbreviations clear and consistent

**Don't:**
* Repeat identical patterns multiple times
* Create confusion about what "same as" means
* Abbreviate without clear reference
* Lose important details in abbreviations

**Pattern:**
```javascript
// ✅ DO: Abbreviate repeated patterns
// First occurrence - full details
codeGuidingCommand.validate(content)
  // full implementation shown

// Later - abbreviated
bddCodeGuidingCommand.validate(testFile)
  // Same as base validation, but BDD-specific principles

// ❌ DON'T: Repeat full pattern
codeGuidingCommand.validate(content)
  // full implementation
bddCodeGuidingCommand.validate(testFile)
  // full implementation again (duplicate)
```

## 10. Interaction Flow Summary

**Do:**
* Provide summary sections showing major interaction flows
* Document common patterns as reusable flows
* Show how multiple interactions combine
* Reference domain concepts in flow summaries
* Keep summaries at appropriate abstraction level

**Don't:**
* Skip flow summaries
* Make summaries too detailed (defeats purpose)
* Create summaries that don't match actual interactions
* Ignore important flows

**Pattern:**
```javascript
// ✅ DO: Flow summary
/*
VALIDATION FLOW:
1. CodeGuidingCommand.validate(content)
   → Loads specialized rule based on file extension
   → Gets principles and heuristics for each principle
   → Analyzes content for violations using heuristics
   → Assembles ViolationReport with violations, principles, examples
   → Sends report to AIGuidanceSystem
   → Receives FixSuggestion[]
   → Applies fixes to content
*/
```

## Validation Checklist

When reviewing interaction models, verify:
- [ ] Property-based access used instead of verbose method calls
- [ ] Code properly nested under functions/properties
- [ ] Dashes used under functions/properties with nested code
- [ ] Scaffold hierarchy followed
- [ ] State set before accessing computed properties
- [ ] Details shown only on first call, abbreviated on repeats
- [ ] Comments explain logic, don't replicate code
- [ ] Interactions organized by domain concept
- [ ] Repeated patterns abbreviated with clear references
- [ ] Flow summaries provided for major patterns
