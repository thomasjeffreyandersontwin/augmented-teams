// ============================================================================
// DOMAIN INTERACTION MODEL
// ============================================================================
FUNCTIONAL PURPOSE: Detailed object interaction model showing explicit method calls, parameters, and return values following scaffold hierarchy

This document models behaviors from the scaffold hierarchy, showing exact method call chains with object references.
Source of Truth: ddd-detailed-model.txt, bdd.domain.scaffold.txt

// ============================================================================
// INTERACTION PATTERNS BY DOMAIN CONCEPT
// ============================================================================

Content {
  // Content is being processed by Command (1:1)
  
  commandRunner.validate(content)
  --------------------------------
    this.content = content
    
    rule = this.rule
      this.loadRuleFromRuleFile()
      ----------------------------------
        this.principles = base.principles
        for each p in this.principles 
          p.examples = this.examples.filter(e => e.principle == p)
          p.heuristics = this.heuristics.filter(h => h.principle == p)
    
    // that implements a specializing rule
    this.rule.fileExtension = content.fileExtension
    specializedRule = this.rule.specializedRule
    --------------------------------
      // SpecializingRule : BaseRule
      // logic hidden in property getter - matches fileExtensionPattern
      // for each rule in this.specializedRules
      //   if fileExtension matches rule.fileExtensionPattern
      //     return rule
    
    // it should include base rule principles
    basePrinciples = specializedRule.principles
    ----------------------------------------
      // SpecializingRule : BaseRule
      // BaseRule provides principled guidance through Principle[] (1:*)
      // ordered by principleNumber
    
    // and the specializing has been loaded
    baseRule = specializedRule.baseRule
    --------------------------------
      // SpecializedRule : SpecializingRule : BaseRule
      // property returns this.parent.baseRule
    
    principles = specializedRule.principles
    ----------------------------------------
      // property returns baseRule.principles
    
    // it should provide access to specialized examples with Dos and Donts for each principle
    examplesByPrinciple = {}
    for each principle in principles
      examples = principle.examples
      ------------------------
        // SpecializedRule provides Example[] (1:*)
        // Example illustrates Dos and Donts for Principle (1:1)
        // property filters this.examples by principle
        // ordered by exampleType (DO, DONT)
      examplesByPrinciple[principle] = examples
    
    codeHeuristicsByPrinciple = {}
    for each principle in principles
      heuristics = principle.heuristics
      ---------------------------
        // SpecializedRule has CodeHeuristic[] (1:*)
        // CodeHeuristic validates Principle (1:1)
        // property filters this.codeHeuristics by principle
      codeHeuristicsByPrinciple[principle] = heuristics
    
    // that is being verified for consistency
    consistencyReport = specializedRule.verifyConsistency()
    -------------------------------------------
      // it should verify specialized rule references specializing rule
      if specializedRule.parent == null
        return ConsistencyViolation("SpecializedRule must reference parent SpecializingRule")
      if specializedRule.parent.ruleType != specializedRule.ruleType
        return ConsistencyViolation("Rule type mismatch")
      return ConsistencyOK()
      
      // it should verify specialized examples map to specializing rule principles
      basePrinciples = specializedRule.baseRule.principles
      for each example in specializedRule.examples
        if example.principle not in basePrinciples
          return ConsistencyViolation("Example maps to unknown principle")
      return ConsistencyOK()
  
  - has violations detected in it --> Violation[] (1:*)
  - applies fixes from --> FixSuggestion[] (1:*)
}

CodeGuidingCommand : Command {
  // CodeGuidingCommand performs code augmented AI guidance
  
  violationReport = codeGuidingCommand.validate(content)
  ---------------------------------------------
    // it should load a code heuristics for each principle from associated specializing rule
    this.rule.fileExtension = content.fileExtension
    specializedRule = this.rule.specializedRule  // (details shown above)
    principles = specializedRule.principles
    heuristicsByPrinciple = {}
    for each principle in principles
      heuristics = principle.heuristics
      heuristicsByPrinciple[principle] = heuristics
    
    // it should analyze content for violations using the heuristic
    violations = []
    for each principle in principles
      heuristics = heuristicsByPrinciple[principle]
      for each heuristic in heuristics
        heuristic.content = content
        detectedViolations = heuristic.violations
        ---------------------------
          // CodeHeuristic analyzes content for violations using detection pattern
          // CodeHeuristic detects Violation[] (1:*)
          // property getter applies detectionPattern to content.rawContent
          // creates Violation instances with lineNumber, columnNumber, severity, message
        violations.push(...detectedViolations)
    
    // it should assemble related violations, principles, and examples into a checklist based report
    violationReport = ViolationReport()
    violationReport.violations = violations
    violationReport.principles = principles
    violationReport.examples = []
    for each principle in principles
      violationReport.examples.push(...principle.examples)
    violationReport.generatedAt = currentTimestamp()
    violationReport.reportFormat = CHECKLIST
    
    // Group violations by principle
    for each principle in principles
      principleViolations = violations.filter(v => v.principle == principle)
      if principleViolations.length > 0
        violationReport.checklistItems.push(
          principle: principle,
          violations: principleViolations,
          examples: principle.examples
        )
    
    // it should send the violation report to AI
    this.aiGuidanceSystem.violationReport = violationReport
    fixSuggestions = this.aiGuidanceSystem.fixSuggestions
    -------------------------------------------
      // AIGuidanceSystem receives ViolationReport[] (1:*)
      // AIGuidanceSystem generates FixSuggestion[] (1:*)
      // property getter builds prompt, sends to AI, parses response
      // creates FixSuggestion for each violation
    
    // it should apply fix suggestions from AI
    content.fixSuggestions = fixSuggestions
    content.applyFixes()
    -------------------
      // Content applies FixSuggestion[] (1:*)
      // property setter triggers fix application
      // replaces originalCode with suggestedCode at each lineNumber
      // clears violations after fixes applied
      content.violations = []
  
  - loads code heuristics for each principle from --> SpecializedRule (1:1)
  - analyzes content for violations using --> CodeHeuristic[] (1:*)
  - assembles related violations, principles, and examples into --> ViolationReport (1:1)
  - sends violation report to --> AIGuidanceSystem (1:1)
  - applies fix suggestions from --> FixSuggestion[] (1:*)
}

IncrementalCommand : Command {
  // IncrementalCommand implements incremental runs
  
  // it should provide the sample size based on code analysis and configured maximum
  incrementalCommand.content = content
  incrementalCommand.maxSampleSize = maxSampleSize
  sampleSize = incrementalCommand.sampleSize
  ----------------------------------------
    // IncrementalCommand provides sample size based on code analysis and configured maximum
    // property getter analyzes content structure, finds smallest work unit
    // returns min(smallestUnitSize, maxSampleSize)
  
  // it should confirm sample size with AI
  incrementalCommand.sampleSizeContext = context
  confirmed = incrementalCommand.sampleSizeConfirmed
  -------------------------------------------
    // IncrementalCommand confirms sample size with AI
    // property getter sends sampleSize and context to AI, returns confirmation
    // uses internal aiGuidanceSystem reference
  
  // it should submit sample size instructions to limit AI batch size before stopping
  incrementalCommand.submitSampleSizeInstructions()
  ------------------------------------------------
    // property setter builds instructions and sends to internal aiGuidanceSystem
  
  // that has completed a run
  incrementalCommand.sampleSize = sampleSize
  run = incrementalCommand.currentRun
  ---------------------------
    // IncrementalCommand has completed a Run (when done)
    // property getter creates Run if needed, increments currentRunNumber
    // sets startedAt, status = IN_PROGRESS
    
    // it should mark run complete
    run.status = COMPLETE
      // Run has completed execution
      // Run is marked complete
      // property setter also sets completedAt timestamp
    
    // it should save run to history
    incrementalCommand.runHistory.runs.push(run)
      // IncrementalCommand saves run to RunHistory (1:*)
      // RunHistory contains completed Run[] (1:*)
    
    // it should save state to disk
    incrementalCommand.state.persistToDisk()
      // IncrementalCommand saves state to IncrementalState (persisted to disk)
      // property getter creates IncrementalState with current state
      // persistToDisk() writes to .bdd-workflow/*.state.json
  
  // that has been repeated
  incrementalCommand.repeatRun()
  ---------------------------
    // IncrementalCommand can revert current run results when repeated
    this.currentRun.revert()
      // Run can be reverted when repeated
      // run.status = REVERTED
      // content.restoreFromSnapshot(run.snapshotBeforeRun)
    
    incrementalCommand.restartRun(run)
      // run.status = IN_PROGRESS
      // run.startedAt = currentTimestamp()
      // run.completedAt = null
      // this.currentRun = run
  
  // that is proceeding to the next run
  incrementalCommand.proceedToNextRun()
  ------------------------------------
    // IncrementalCommand can proceed to next run with same sample size
    // this.currentRunNumber++
    // this.sampleSize = this.sampleSize  // same sample size
    // this.createRun(this.sampleSize)
  
  // that is proceeding to expand to all work
  incrementalCommand.expandToAllWork()
  -----------------------------------
    // IncrementalCommand can expand to all work after learning from mistakes in previous runs
    lessons = this.runHistory.extractLessons()
      // RunHistory is used to learn from mistakes in previous runs
      // analyzes completed runs, extracts patterns from violations
    
    incrementalCommand.executeAllRemaining()
      // remainingWorkUnits = this.totalWorkUnits - this.completedWorkUnits
      // this.sampleSize = remainingWorkUnits  // expand to all
      // this.createRun(this.sampleSize)
  
  - provides sample size based on --> code analysis and configured maximum
  - confirms sample size with --> AI
  - has completed a --> Run (when done)
  - saves run to --> RunHistory (1:*)
  - saves state to --> IncrementalState (persisted to disk)
  - can revert current run results when --> repeated
  - can proceed to next run with --> same sample size
  - can expand to all work after --> learning from mistakes in previous runs
}

PhaseCommand : Command {
  // PhaseCommand is a phase in Workflow (1:1)
  
  // it should initialize workflow phase
  phaseCommand.initialize(workflow, phaseNumber)
  ----------------------------------------------
    // PhaseCommand initializes workflow phase
    // this.workflow = workflow
    // this.phaseNumber = phaseNumber
    // this.phaseName = getPhaseName(phaseNumber)
    // this.phaseOrder = phaseNumber
    // this.phaseState = PhaseState(phaseStatus: STARTING, startedAt: currentTimestamp())
  
  // it should set state of phase to starting
  phaseCommand.setPhaseStateToStarting()
  ---------------------------------------
    // PhaseCommand sets state of phase to starting
    // this.phaseState.phaseStatus = STARTING
    // this.phaseState.startedAt = currentTimestamp()
  
  // it should save state to disk
  phaseCommand.saveStateToDisk()
  ------------------------------
    // PhaseCommand saves state to disk through PhaseState
    // this.phaseState.persistToDisk(this.getPhaseStateFilePath())
    //   writeJSONToFile(this.getPhaseStateFilePath(), this.phaseState.toJSON())
  
  // in order the correct phase order
  canExecute = workflow.canExecutePhase(phaseNumber)
  ------------------------------------------------
    // PhaseCommand executes in correct phase order
    // if phaseNumber != this.currentPhaseNumber
    //   return false  // out of order
    // return true
  
  // it should the command to be invoked
  phaseCommand.start()
  --------------------
    // if not this.workflow.canExecutePhase(this.phaseNumber)
    //   this.blockExecution("Phase out of order")
    //   return
    // this.phaseState.phaseStatus = IN_PROGRESS
    // this.executePhaseLogic()
  
  // that is being resumed from previous session
  phaseCommand.resume()
  ---------------------
    // PhaseCommand may be resumed from previous session (loads state from disk)
    phaseState = PhaseState.loadFromDisk(phaseStateFilePath)
      // PhaseState is loaded from disk when resuming
      // if fileExists(phaseStateFilePath)
      //   json = readJSONFromFile(phaseStateFilePath)
      //   return PhaseState.fromJSON(json)
      // return null
    
    phaseCommand.resumeFromPhase()
      // phaseState = PhaseState.loadFromDisk(this.getPhaseStateFilePath())
      // if phaseState
      //   this.phaseState = phaseState
      //   this.phaseNumber = phaseState.phaseNumber
      //   this.start()
    
    phaseCommand.resumeFromRun()
      // if this.isIncrementalCommand()
      //   incrementalState = IncrementalState.loadFromDisk(this.getIncrementalStateFilePath())
      //   if incrementalState
      //     this.currentRunNumber = incrementalState.currentRun
      //     this.createRun(this.sampleSize)
  
  // that has been invoked out of Phase order
  phaseCommand.blockExecution(reason)
  -----------------------------------------
    // PhaseCommand blocks execution
    // this.canExecute = false
    // this.phaseState.phaseStatus = BLOCKED
    // this.blockingReason = reason
  
  statusReport = workflow.getCurrentPhaseStatus()
  ------------------------------------------------
    // PhaseCommand reports on current phase that needs to be completed
    // currentPhase = this.phases[this.currentPhaseNumber]
    // return PhaseStatusReport(...)
  
  // that has completed all steps for the command
  phaseCommand.checkCompletion()
  ---------------------------------
    // PhaseCommand has completed all steps --> provides option to proceed to next phase, verify, or redo
    // if this.allStepsComplete()
    //   return NextAction([PROCEED_TO_NEXT_PHASE, VERIFY_AGAINST_RULES, REDO_PHASE])
    // return null
  
  // that has been approved to proceed
  phaseCommand.proceed()
  ----------------------
    nextAction = phaseState.determineNextAction()
      // PhaseCommand determines next action from state
      // if this.phaseStatus == COMPLETE
      //   return PROCEED_TO_NEXT_PHASE
      // if this.phaseStatus == IN_PROGRESS
      //   return CONTINUE_PHASE
      // if this.phaseStatus == BLOCKED
      //   return FIX_VIOLATIONS
    
    workflow.markPhaseComplete(phaseNumber)
      // PhaseCommand marks phase as complete in Workflow
      // phase = this.phases[phaseNumber]
      // phase.phaseState.phaseStatus = COMPLETE
      // phase.phaseState.completedAt = currentTimestamp()
      // this.currentPhaseNumber++
    
    workflow.startNextPhase()
      // PhaseCommand starts next phase command in Workflow
      // nextPhase = this.phases[this.currentPhaseNumber]
      // if nextPhase
      //   nextPhase.start()
  
  - is a phase in --> Workflow (1:1)
  - initializes workflow phase
  - sets state of phase to --> starting
  - saves state to --> disk through PhaseState
  - executes in correct phase order
  - may be resumed from --> previous session (loads state from disk)
  - has been invoked out of phase order --> blocks execution
  - has completed all steps --> provides option to proceed to next phase, verify, or redo
  - has been approved to proceed --> determines next action from state
  - marks phase as complete in --> Workflow
  - starts next phase command in --> Workflow
}

Workflow {
  // Workflow has ordered phases --> PhaseCommand[] (1:*)
  
  workflow.create(workflowName, content)
  --------------------------------------
    // Workflow sets workflowName
    // Workflow sets content reference
    // Workflow sets status to NOT_STARTED
    // Workflow sets currentPhaseNumber to 0
    // Workflow creates PhaseCommand[] array (empty initially)
  
  workflow.addPhase(phaseCommand)
  --------------------------------
    // Workflow adds phaseCommand to PhaseCommand[] array
    // Workflow sets phaseCommand.workflow reference to this
    // Workflow orders PhaseCommand[] by phaseOrder
  
  workflow.executePhases()
  ------------------------
    // Workflow sets status to IN_PROGRESS
    // Workflow iterates through PhaseCommand[] ordered by phaseOrder
    // For each PhaseCommand:
    //   - Calls Workflow.canExecutePhase(phaseCommand.phaseNumber)
    //   - If true: calls PhaseCommand.start()
    //   - Waits for phase completion
    //   - Calls Workflow.markPhaseComplete(phaseCommand.phaseNumber)
    // When all phases complete: sets status to COMPLETE
  
  workflowState.persistToDisk(filePath)
  --------------------------------------
    // WorkflowState serializes to JSON:
    //   - currentPhase: int
    //   - currentRun: int
    //   - canResume: boolean
    //   - persistedAt: timestamp
    // WorkflowState writes JSON to filePath
  
  workflowState.loadFromDisk(filePath)
  -------------------------------------
    // WorkflowState checks if file exists
    // If exists: reads JSON, deserializes to WorkflowState
    // If not exists: returns null
  
  workflow.resume()
  -----------------
    // Workflow calls WorkflowState.loadFromDisk()
    // If state exists:
    //   - Sets currentPhaseNumber from WorkflowState.currentPhase
    //   - Sets currentRun from WorkflowState.currentRun
    //   - Loads PhaseState for current phase
    //   - Sets status to IN_PROGRESS
    // If no state: initializes new workflow
  
  - has ordered phases --> PhaseCommand[] (1:*)
  - processes --> Content (1:1)
  - invokes phases in correct order
  - marks phase as complete
  - starts next phase command
  - has state saved to --> WorkflowState (persisted to disk)
  - can be resumed from --> previous session
}

SpecializedRule : SpecializingRule {
  // SpecializedRule provides access to specialized examples with Dos and Donts for --> Principle[] (1:*)
  
  specializedRule.getExamplesForPrinciple(principleNumber)
  ---------------------------------------------------------
    // SpecializedRule provides Example[] (1:*)
    // Example illustrates Dos and Donts for Principle (1:1)
    // property filters this.examples by principle
    // ordered by exampleType (DO, DONT)
    // return this.examples.filter(e => e.principle.principleNumber == principleNumber)
  
  specializedRule.getHeuristicsForPrinciple(principleNumber)
  --------------------------------------------------------
    // SpecializedRule has CodeHeuristic[] (1:*)
    // CodeHeuristic validates Principle (1:1)
    // property filters this.codeHeuristics by principle
    // return this.codeHeuristics.filter(h => h.principle.principleNumber == principleNumber)
  
  - provides access to specialized examples with Dos and Donts for --> Principle[] (1:*)
  - provides --> Example[] (1:*)
  - has code heuristics loaded for --> CodeHeuristic[] (1:*)
}

CodeHeuristic {
  // CodeHeuristic analyzes content for violations using detection pattern
  
  heuristic.content = content
  detectedViolations = heuristic.violations
  ---------------------------
    // CodeHeuristic analyzes content for violations using detection pattern
    // CodeHeuristic detects Violation[] (1:*)
    // property getter applies detectionPattern to content.rawContent
    // creates Violation instances with lineNumber, columnNumber, severity, message
    // matches = applyPattern(heuristic.detectionPattern, content.rawContent)
    // for each match in matches
    //   violation = Violation(...)
    //   result.push(violation)
    // return result
  
  - is loaded for each principle from --> SpecializedRule (1:1)
  - validates --> Principle (1:1)
  - analyzes content for violations using --> detection pattern
  - detects --> Violation[] (1:*)
}

ViolationReport {
  // ViolationReport assembles related Violation[] (1:*)
  
  violationReport = ViolationReport()
  violationReport.violations = violations
  violationReport.principles = principles
  violationReport.examples = []
  for each principle in principles
    violationReport.examples.push(...principle.examples)
  violationReport.generatedAt = currentTimestamp()
  violationReport.reportFormat = CHECKLIST
  
  // Group violations by principle
  for each principle in principles
    principleViolations = violations.filter(v => v.principle == principle)
    if principleViolations.length > 0
      violationReport.checklistItems.push(
        principle: principle,
        violations: principleViolations,
        examples: principle.examples
      )
  
  - assembles related --> Violation[] (1:*)
  - references --> Principle[] (1:*)
  - includes --> Example[] (1:*)
  - is a checklist based report
  - is sent to --> AIGuidanceSystem (1:1)
  - is generated by --> CodeGuidingCommand (1:1)
}

AIGuidanceSystem {
  // AIGuidanceSystem receives ViolationReport[] (1:*)
  
  this.aiGuidanceSystem.violationReport = violationReport
  fixSuggestions = this.aiGuidanceSystem.fixSuggestions
  -------------------------------------------
    // AIGuidanceSystem generates FixSuggestion[] (1:*)
    // property getter builds prompt, sends to AI, parses response
    // creates FixSuggestion for each violation
    // prompt = buildPrompt(violationReport)
    // aiResponse = sendToAI(prompt)
    // fixSuggestions = parseAIResponse(aiResponse)
    // for each violation in violationReport.violations
    //   fixSuggestion = FixSuggestion(...)
    //   fixSuggestions.push(fixSuggestion)
    // return fixSuggestions
  
  - receives --> ViolationReport[] (1:*)
  - generates --> FixSuggestion[] (1:*)
  - is prompted to learn from --> mistakes in previous runs
}

// ============================================================================
// BDD-SPECIFIC INTERACTIONS
// ============================================================================

BDDCommand : CodeGuidingCommand {
  // BDD-specific command processing
  
  // that implements a specializing rule for test frameworks
  bddSpecializingRule.selectSpecializedRule(testFile.fileExtension)
  ----------------------------------------------------------------
    // for Jest: *.test.js, *.spec.js, *.test.ts
    // for Mamba: *_test.py, test_*.py
    // if testFile.fileExtension matches "*.test.js" or "*.spec.js" or "*.test.ts"
    //   return BDDJestSpecializedRule()
    // if testFile.fileExtension matches "*_test.py" or "test_*.py"
    //   return BDDMambaSpecializedRule()
    // throw RuleNotFoundException()
  
  bddSpecializingRule.getBDDPrinciples()
  ---------------------------------------
    // § 1: Business Readable Language
    // § 2: Comprehensive and Brief Coverage
    // § 3: Balance Context Sharing
    // § 4: Cover All Layers
    // § 5: Unit Tests Front-End
    // baseRule = this.getBaseRule()  // bdd-rule.mdc
    // return baseRule.getPrinciples()  // returns 5 BDD principles
  
  // that is being validated against BDD principles
  bddCodeGuidingCommand.validate(testFile)
  -----------------------------------------
    // it should load test code heuristics specific to the language, for each principle from specialized rule
    specializedRule = this.selectSpecializedRule(testFile.fileExtension)
    principles = specializedRule.getPrinciples()  // 5 BDD principles
    heuristicsByPrinciple = {}
    for each principle in principles
      heuristics = specializedRule.getHeuristicsForPrinciple(principle.principleNumber)
      heuristicsByPrinciple[principle] = heuristics  // language-specific heuristics
    
    // it should analyze test structure for violations using heuristics
    testStructure = testFile.parseTestStructure()
      // For Jest: identifies describe() and it() blocks
      // For Mamba: identifies with description() and with it() blocks
      // return parseTestHierarchy(testFile.rawContent)
    
    violations = []
    for each principle in principles
      heuristics = heuristicsByPrinciple[principle]
      for each heuristic in heuristics
        detectedViolations = heuristic.analyzeContent(testFile)
        violations.push(...detectedViolations)
    
    // it should assemble related violations, principles, and examples into checklist report
    violationReport = ViolationReport.assemble(violations, principles, examples)
      // Same as base validation, but BDD-specific principles and examples
      // return assembleBDDChecklistReport(violations, principles, examples)
    
    // it should send violation report to AI
    fixSuggestions = aiGuidanceSystem.analyzeViolations(violationReport)
      // Same as base validation
      // return generateBDDFixes(violationReport)
    
    // it should apply fix suggestions from AI
    testFile.applyFixes(fixSuggestions)
      // Same as base validation
      // applyFixesToTestFile(testFile, fixSuggestions)
}

BDDIncrementalCommand : IncrementalCommand {
  // BDD-specific incremental execution
  
  // it should provide a smaller sample size based on describe block analysis and configured maximum
  bddIncrementalCommand.calculateSampleSize(testFile, maxSampleSize = 6)
  ---------------------------------------------------------------------
    // BDD: 6 tests maximum (lowest-level describe block)
    // testStructure = testFile.parseTestStructure()
    // lowestLevelDescribeBlocks = testStructure.findLowestLevelDescribeBlocks()
    // for each describeBlock in lowestLevelDescribeBlocks
    //   testCount = describeBlock.countTests()
    //   if testCount <= maxSampleSize
    //     return testCount
    // return maxSampleSize  // default to max if no suitable block found
  
  // that has completed a run
  bddIncrementalCommand.markTestCompletion(testFile, run)
  -------------------------------------------------------
    // BDD-specific: mark completion status in test code
    // testStructure = testFile.parseTestStructure()
    // for each testBlock in run.completedTests
    //   testBlock.markAsComplete()  // adds comment or marker in code
  
  // that has been repeated
  bddIncrementalCommand.repeatRun()
  ---------------------------------
    // BDD-specific: revert test code changes
    // this.currentRun.revert()
    // testFile.restoreFromSnapshot(this.currentRun.snapshotBeforeRun)
  
  // that is proceeding to expand to all work
  bddIncrementalCommand.expandToAllWork()
  ----------------------------------------
    // it should provide the next sample size based on describe block analysis and configured maximum
    nextSampleSize = bddIncrementalCommand.calculateNextSampleSize()
      // Same calculation logic, but for next describe block
      // return this.calculateSampleSize(this.getNextDescribeBlock(), this.maxSampleSize)
    
    // it should prompt AI to learn from mistakes in previous runs
    lessons = this.runHistory.extractLessons()
      // Same as base incremental command
      // return this.analyzeBDDPatterns(this.runHistory.runs)
    
    // it should execute the next set of test blocks
    bddIncrementalCommand.executeNextTestBlocks()
      // BDD-specific: execute next describe block
      // nextDescribeBlock = this.getNextDescribeBlock()
      // this.createRun(nextDescribeBlock.testCount)
  
  // with more test blocks remaining
  if bddIncrementalCommand.hasMoreTestBlocks()
  ---------------------------------------------
    // BDD-specific: check for remaining describe blocks
    // testStructure = testFile.parseTestStructure()
    // return testStructure.hasUncompletedDescribeBlocks()
  
  // with all test blocks complete
  if bddIncrementalCommand.allTestBlocksComplete()
  ------------------------------------------------
    // BDD-specific: check if all describe blocks completed
    // testStructure = testFile.parseTestStructure()
    // if testStructure.allDescribeBlocksComplete()
    //   this.status = COMPLETE
    //   return true
    // return false
}

BDDWorkflow : Workflow {
  // BDD-specific workflow
  
  // it should invoke phases in the following order
  bddWorkflow.initializePhases()
  ------------------------------------------------
    // Phase 0: Domain Scaffolding
    // Phase 1: Build Test Signatures
    // Phase 2: RED - Create Failing Tests
    // Phase 3: GREEN - Make Tests Pass
    // Phase 4: REFACTOR - Improve Code
    // this.phases = [
    //   PhaseCommand(0, "Domain Scaffolding"),
    //   PhaseCommand(1, "Build Test Signatures"),
    //   PhaseCommand(2, "RED - Create Failing Tests"),
    //   PhaseCommand(3, "GREEN - Make Tests Pass"),
    //   PhaseCommand(4, "REFACTOR - Improve Code")
    // ]
  
  // that has started Phase 0: Domain Scaffolding
  phase0.execute(testFile, domainMapPath)
  -----------------------------------------
    // it should read domain map structure
    domainMap = Content.loadFromFile(domainMapPath)
      // domainMapContent = readFile(domainMapPath)
      // return Content(domainMapContent)
    
    // it should generate plain English describe hierarchy
    describeHierarchy = phase0.generateDescribeHierarchy(domainMap)
      // Translates domain concepts (nouns) → describe blocks
      // concepts = parseDomainConcepts(domainMap.rawContent)
      // hierarchy = []
      // for each concept in concepts
      //   hierarchy.push(`describe ${concept.name}`)
      // return hierarchy
    
    // it should generate plain English it should statements for each line in hierarchy
    itStatements = phase0.generateItStatements(describeHierarchy)
      // Translates behaviors (verbs) → it blocks
      // behaviors = parseBehaviors(domainMap.rawContent)
      // statements = []
      // for each behavior in behaviors
      //   statements.push(`it should ${behavior.description}`)
      // return statements
    
    // it should preserve domain map nesting depth
    nestedHierarchy = phase0.preserveNesting(describeHierarchy, domainMap)
      // Nested concepts → nested describe blocks
      // return buildNestedStructure(describeHierarchy, domainMap.nestingDepth)
    
    // it should apply behavioral fluency rules
    fluentHierarchy = phase0.applyBehavioralFluency(nestedHierarchy)
      // Applies BDD fluent language rules
      // return applyBDDFluentLanguage(nestedHierarchy)
  
  // that has started Phase 1: Build Test Signatures
  phase1.execute(testFile)
  -------------------------
    // it should generate describe/it hierarchy in code (jest / mamba) with empty bodies
    testSignatures = phase1.generateTestSignatures(testFile, fluentHierarchy)
      // Generates actual test code with describe/it or with description/with it
      // specializedRule = this.selectSpecializedRule(testFile.fileExtension)
      // if specializedRule.targetFramework == "Jest"
      //   return generateJestSignatures(fluentHierarchy)
      // if specializedRule.targetFramework == "Mamba"
      //   return generateMambaSignatures(fluentHierarchy)
    
    // it should validate signatures against § 1 Business Language
    violationReport = phase1.validateSignatures(testSignatures)
      // Validates against BDD Principle 1: Business Readable Language
      // principle1 = specializedRule.getPrinciple(1)
      // heuristics = specializedRule.getHeuristicsForPrinciple(1)
      // violations = []
      // for each heuristic in heuristics
      //   violations.push(...heuristic.analyzeContent(testSignatures))
      // return ViolationReport.assemble(violations, [principle1], examples)
    
    // it should keep test bodies empty
    phase1.ensureEmptyBodies(testSignatures)
      // Ensures all it blocks have empty bodies (pass statements only)
      // testStructure = parseTestStructure(testSignatures)
      // for each testBlock in testStructure.testBlocks
      //   if testBlock.bodyNotEmpty()
      //     testBlock.clearBody()  // set to empty/pass
  
  // that has started Phase 2: RED - Create Failing Tests
  phase2.execute(testFile)
  -------------------------
    // it should implement Arrange-Act-Assert in tests
    phase2.implementTests(testFile, sampleSize)
      // Implements test bodies with Arrange-Act-Assert pattern
      // testStructure = testFile.parseTestStructure()
      // sampleTests = testStructure.getSampleTests(sampleSize)
      // for each test in sampleTests
      //   test.implementWithAAA()
    
    // it should validate against all five BDD principles
    violationReport = phase2.validateTests(testFile)
      // Validates against all 5 BDD principles
      // specializedRule = this.selectSpecializedRule(testFile.fileExtension)
      // principles = specializedRule.getPrinciples()  // all 5 principles
      // violations = []
      // for each principle in principles
      //   heuristics = specializedRule.getHeuristicsForPrinciple(principle.principleNumber)
      //   for each heuristic in heuristics
      //     violations.push(...heuristic.analyzeContent(testFile))
      // return ViolationReport.assemble(violations, principles, examples)
    
    // it should execute tests to verify correct failure
    testResult = phase2.executeTests(testFile)
      // Executes tests via framework
      // specializedRule = this.selectSpecializedRule(testFile.fileExtension)
      // if specializedRule.targetFramework == "Jest"
      //   return executeJestTests(testFile.filePath)
      // if specializedRule.targetFramework == "Mamba"
      //   return executeMambaTests(testFile.filePath)
    
    // it should verify tests fail for right reason (not syntax errors)
    isValidFailure = phase2.verifyFailureReason(testResult)
      // Verifies tests fail for right reason (not syntax errors)
      // if testResult.hasSyntaxErrors()
      //   return false  // failing for wrong reason
      // if testResult.failuresAreExpected()
      //   return true  // failing for right reason (missing implementation)
      // return false
  
  // that has started Phase 3: GREEN - Make Tests Pass
  phase3.execute(testFile)
  -------------------------
    // it should implement minimal production code
    phase3.implementProductionCode(testFile)
      // Implements minimal production code to make tests pass
      // failingTests = testFile.getFailingTests()
      // for each test in failingTests
      //   productionCode = generateMinimalCode(test)
      //   writeProductionCode(productionCode)
    
    // it should validate production code against principles
    violationReport = phase3.validateProductionCode(productionCode)
      // Validates production code (may use clean-code rules, not just BDD)
      // return validateCode(productionCode)
    
    // it should execute tests to verify passing
    testResult = phase3.executeTests(testFile)
      // Same as Phase 2
      // return executeTests(testFile)
    
    // it should check for regressions in existing tests
    regressionCheck = phase3.checkForRegressions(testResult)
      // Checks for regressions in existing tests
      // if testResult.passedCount < testResult.previousPassedCount
      //   return true  // regression detected
      // return false
  
  // that has started Phase 4: REFACTOR - Improve Code
  phase4.execute(testFile, productionCode)
  ----------------------------------------------------
    // it should analyze code smells
    codeSmells = phase4.analyzeCodeSmells(productionCode)
      // Analyzes production code for code smells
      // return detectCodeSmells(productionCode)
    
    // it should propose specific refactorings
    refactorings = phase4.proposeRefactorings(codeSmells)
      // Proposes specific refactorings for each code smell
      // refactorings = []
      // for each smell in codeSmells
      //   refactoring = generateRefactoring(smell)
      //   refactorings.push(refactoring)
      // return refactorings
    
    // it should await user approval of refactorings
    approvedRefactorings = phase4.awaitUserApproval(refactorings)
      // Awaits user approval of refactorings
      // return getUserApproval(refactorings)
    
    // it should apply approved refactorings
    phase4.applyRefactorings(approvedRefactorings)
      // Applies approved refactorings
      // for each refactoring in approvedRefactorings
      //   applyRefactoring(refactoring)
    
    // it should execute tests to verify still passing
    testResult = phase4.executeTests(testFile)
      // Executes tests to verify still passing after refactoring
      // return executeTests(testFile)
    
    // it should validate refactored code against principles
    violationReport = phase4.validateRefactoredCode(refactoredCode)
      // Validates refactored code against principles
      // return validateCode(refactoredCode)
}

// ============================================================================
// INTERACTION FLOW SUMMARY
// ============================================================================

/*
VALIDATION FLOW:
1. CodeGuidingCommand.validate(content)
   → Loads specialized rule based on file extension
   → Gets principles and heuristics for each principle
   → Analyzes content for violations using heuristics
   → Assembles ViolationReport with violations, principles, examples
   → Sends report to AIGuidanceSystem
   → Receives FixSuggestion[]
   → Applies fixes to content

INCREMENTAL RUN FLOW:
1. IncrementalCommand calculates sample size
2. Confirms sample size with AI
3. Creates Run
4. Executes work on sample
5. Marks run complete
6. Saves run to history
7. Saves state to disk
8. Provides user options (repeat, next, expand, abandon)

PHASE EXECUTION FLOW:
1. PhaseCommand.initialize(workflow, phaseNumber)
2. Workflow.canExecutePhase(phaseNumber)
3. PhaseCommand.start()
4. Execute phase-specific work
5. CodeGuidingCommand.validate(content)
6. If violations: fix and re-validate
7. If clean: Workflow.markPhaseComplete(phaseNumber)
8. Workflow.startNextPhase()

WORKFLOW RESUME FLOW:
1. WorkflowState.loadFromDisk(filePath)
2. Workflow.resume()
3. PhaseState.loadFromDisk(phaseFilePath)
4. PhaseCommand.start() (resume from current phase)
5. IncrementalState.loadFromDisk(runFilePath)
6. Continue from current run
*/

// ============================================================================
// END OF INTERACTION MODEL
// ============================================================================
