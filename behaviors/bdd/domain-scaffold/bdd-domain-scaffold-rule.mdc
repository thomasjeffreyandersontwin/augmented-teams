---
description: BDD test hierarchy and behavioral fluency principles
globs: ["**/*.test.js", "**/*.spec.js", "**/*.test.ts", "**/*.spec.ts", "**/*.test.jsx", "**/*.spec.jsx", "**/*.test.tsx", "**/*.spec.tsx", "**/*.test.mjs", "**/*.spec.mjs", "**/*_test.py", "**/test_*.py", "**/*_spec.py", "**/spec_*.py"]
alwaysApply: false
---

**When** creating BDD test structure (describe blocks),
**then** organize by behavioral story hierarchy, not function/module lists.

This rule extends `bdd-rule.mdc` with hierarchy and fluency principles.
References `ddd-structure-analysis-rule.mdc` for domain concept mapping.

**Executing Commands:**
* `\bdd-domain-scaffold` — Generate natural language test hierarchy from domain map
* `\bdd-domain-scaffold-verify` — Validate hierarchy follows these principles

---

## Core Principle: Tests Tell Stories, Not Document APIs

Tests should read like behavioral narratives showing how concepts relate, evolve, and interact.
NOT like API documentation listing available functions.

**✅ DO: Concept-Centric Behavioral Stories**
```javascript
describe('a power item', () => {                    // Main concept
  describe('created from a power', () => {          // Birth/initialization
    describe('that provides animation characteristics', () => {  // Capabilities
      // Tests for what it provides
    });
  });
  
  describe('whose animation is being edited', () => { // Modification state
    describe('that has its effects modified', () => { // Specific modification
      // Tests for effect changes
    });
    
    describe('whose descriptor is set to fire', () => { // State variation
      // Tests for fire-specific behavior
    });
  });
  
  describe('used to launch an attack', () => {       // Usage/action
    describe('that hits the target', () => {         // Outcome
      // Tests for hit scenario
    });
  });
});
```

**❌ DON'T: Module/Function Lists**
```javascript
describe('power roll animations', () => {});    // What is this? A module?
describe('animation resolution', () => {});     // How does this relate to power?
describe('sequence runner editor', () => {});   // Disconnected - editor of what?
describe('descriptor class lookup', () => {});  // Function list, no story
```

---

## Hierarchy Patterns

### Pattern 1: Concept Lifecycle

Follow natural object lifecycle: creation → modification → usage → destruction

**✅ DO:**
```javascript
describe('a user session', () => {
  describe('created from login credentials', () => {});      // Birth
  describe('that has been authenticated', () => {});         // Established
  describe('whose permissions have been updated', () => {});  // Modified
  describe('used to access protected resources', () => {});  // Usage
  describe('that has expired', () => {});                    // End of life
});
```

**❌ DON'T:**
```javascript
describe('user login', () => {});           // Separate
describe('session management', () => {});   // Separate
describe('permission updates', () => {});   // Separate - missing relationships
```

### Pattern 2: State Variations with Context

Test different states/configurations of same concept under shared parent.

**✅ DO:**
```javascript
describe('a power item', () => {
  describe('with fire descriptor', () => {
    describe('that is ranged', () => {
      describe('with cone area', () => {
        // Very specific scenario tests
      });
    });
  });
  
  describe('with ice descriptor', () => {
    // Ice-specific tests
  });
});
```

**❌ DON'T:**
```javascript
describe('fire powers', () => {});   // Flat
describe('ice powers', () => {});    // No relationship shown
describe('ranged powers', () => {});  // Orthogonal concern mixed
```

### Pattern 3: Behavioral Relationships

Show how concepts interact and depend on each other.

**✅ DO:**
```javascript
describe('an animation editor', () => {                      // Subject
  describe('that opens for a power item', () => {           // Relationship clear
    describe('whose configuration is being modified', () => { // Action on subject
      // Modification tests
    });
    
    describe('that saves customizations', () => {            // Another action
      describe('as an attached macro', () => {               // Specific variation
        // Attachment tests
      });
    });
  });
});
```

**❌ DON'T:**
```javascript
describe('sequence runner editor', () => {});  // Opens for what?
describe('saving animations', () => {});        // Saving from where?
describe('attached macros', () => {});          // Attached to what?
```

---

## Domain Map → Test Hierarchy Mapping

When domain map exists, use it as primary source for test structure.

**Mapping Rules:**

| Domain Element | Test Structure | Example |
|----------------|----------------|---------|
| Domain Concept | `describe('a concept', () => {})` | Power Item → `describe('a power item', () => {})` |
| Concept State/Property | `describe('with X', () => {})` | Fire descriptor → `describe('with fire descriptor', () => {})` |
| Concept State (passive) | `describe('that has X', () => {})` | Macro attached → `describe('that has an attached macro', () => {})` |
| Concept State (active) | `describe('that is doing X', () => {})` | Being edited → `describe('that is being edited', () => {})` |
| Concept Action/Usage | `describe('used to do X', () => {})` | Launch attack → `describe('used to launch an attack', () => {})` |
| Relationship | `describe('whose X', () => {})` | Animation being edited → `describe('whose animation is being edited', () => {})` |
| Condition/Trigger | `describe('when X happens', () => {})` | Macro exists → `describe('when attached macro exists', () => {})` |

**Example Domain Map Section:**
```
Power Item (PowerItem class)
  Provides descriptor (fire, ice, etc.)
  Provides effect type (damage, affliction)
  Provides range (melee, ranged)
  
  Animation Resolution
    Checks attached macros (highest priority)
    Searches name-matched macros
    Generates descriptor-based animation (fallback)
```

**Generated Test Hierarchy:**
```javascript
describe('a power item', () => {                           // Domain Concept
  
  describe('that provides animation characteristics', () => { // Properties group
    // Tests for descriptor, effect type, range
  });
  
  describe('that resolves which animation to use', () => {  // Sub-concept relationship
    describe('when attached macro exists', () => {          // Condition
      // Highest priority tests
    });
    
    describe('when name-matched macro exists', () => {
      // Second priority tests
    });
    
    describe('using descriptor-based generation as fallback', () => { // Final fallback
      // Generation tests
    });
  });
});
```

---

## Natural Language Fluency Test

**The Read-Aloud Test:**

Read each describe chain as a sentence. It should sound natural.

**✅ PASS:**
- "a power item that provides animation characteristics" ✓
- "a power item whose animation is being edited that has its effects modified" ✓
- "a power item used to launch an attack that hits the target" ✓

**❌ FAIL:**
- "power roll animations detection" ✗ (what's the subject?)
- "sequence runner editor configuration preview testing" ✗ (too many nouns)
- "effect section registration that are elemental effects" ✗ (grammar broken)

---

## Anti-Patterns to Avoid

### Anti-Pattern 1: Missing Subject

**❌ DON'T:**
```javascript
describe('detection', () => {});        // Detection of what? By what?
describe('type detection', () => {});   // Still unclear
describe('resolution', () => {});       // Resolution of what?
```

**✅ DO:**
```javascript
describe('movement animation', () => {      // Subject clear
  describe('detection', () => {});          // NOW we know: movement detection
  describe('type mapping', () => {});       // Movement type mapping
});
```

### Anti-Pattern 2: Function/Module Names as Describes

**❌ DON'T:**
```javascript
describe('PowerItem', () => {});              // Class name
describe('AnimationResolver', () => {});      // Class name
describe('getUserSession()', () => {});       // Function name
describe('authentication module', () => {});  // Module name
```

**✅ DO:**
```javascript
describe('a power item', () => {});                     // Behavioral concept
describe('animation that is being resolved', () => {});  // Behavioral process
describe('a user session that is being retrieved', () => {}); // Behavioral action
describe('user authentication', () => {});              // Behavioral capability
```

### Anti-Pattern 3: Disconnected Siblings

**❌ DON'T:**
```javascript
describe('a power item', () => {
  // Basic tests
});

// Later in file, disconnected:
describe('power item updates', () => {});     // Should be nested under 'a power item'
describe('power item in combat', () => {});   // Should be nested under 'a power item'
```

**✅ DO:**
```javascript
describe('a power item', () => {
  describe('created from power data', () => {});
  describe('that has been updated', () => {});    // Nested - relationship clear
  describe('used in combat', () => {});            // Nested - relationship clear
});
```

---

## Validation Checklist

When validating hierarchy, check ALL of these:

1. ✓ **Top-level describes** - Are they domain concepts (nouns with 'a/an')?
2. ✓ **Nesting depth** - Does depth show specificity (general → specific)?
3. ✓ **Sibling cohesion** - Do siblings relate to same parent concept?
4. ✓ **Natural flow** - Does each chain read naturally when spoken aloud?
5. ✓ **Subject clarity** - Is the subject obvious in every describe?
6. ✓ **Domain alignment** - Does structure match domain map (if exists)?
7. ✓ **Relationship words** - Are "that/whose/when/with" used to connect concepts?
8. ✓ **No class names** - Are class/function/module names avoided?

---

## Domain-Driven Structure

When domain map exists, test hierarchy should mirror domain structure:

**Domain Map:**
```
POWER ACTIVATION ANIMATION
  Power Item
    Animation Resolution
      Priority 1: Attached Macro
      Priority 2: Name-Matched Macro
      Priority 3: AutoRec Entry
      Priority 4: Descriptor Generation
```

**Test Hierarchy:**
```javascript
describe('power activation animation', () => {
  describe('a power item', () => {
    describe('that resolves which animation to use', () => {
      describe('when attached macro exists', () => {});    // Priority 1
      describe('when name-matched macro exists', () => {}); // Priority 2
      describe('when automated recognition entry exists', () => {}); // Priority 3
      describe('using descriptor generation as fallback', () => {}); // Priority 4
    });
  });
});
```

Hierarchy mirrors domain structure → makes tests domain-aligned by construction.

---

## Sample Size: ~18 Describe Blocks

For Stage 0 (scaffolding), a sample should contain approximately 18 describe blocks (not it() blocks).

This typically covers:
- 1 top-level concept
- 3-5 major behaviors/states
- 2-4 levels of nesting
- Represents one cohesive domain area

**Example Sample 1:**
```javascript
describe('a power item', () => {                     // 1
  describe('created from power data', () => {        // 2
    describe('that provides characteristics', () => { // 3
    });
  });
  describe('that resolves animation', () => {        // 4
    describe('when attached macro exists', () => {   // 5
    });
    describe('when name-matched macro exists', () => { // 6
    });
    describe('when AutoRec entry exists', () => {    // 7
    });
    describe('using descriptor generation', () => {  // 8
    });
  });
});
// 8 describes so far - add more behaviors to reach ~18
```

---

## Integration with BDD Rules

This rule ADDS hierarchy/fluency to existing BDD § 1 (Business Readable Language).

**bdd-rule.mdc § 1 says:**
- Use nouns for describe
- Start it() with "should"
- Use plain behavioral language

**This rule ADDS:**
- HOW to nest those describes
- HOW to show relationships
- HOW to mirror domain structure

**Both rules work together** to create readable, well-structured tests.

**Reference Flow:**
1. Stage 0: Follow `bdd-hierarchy-rule.mdc` (structure)
2. Stage 1 onward: Follow `bdd-jest-rule.mdc` (full BDD principles including structure from hierarchy rule)
