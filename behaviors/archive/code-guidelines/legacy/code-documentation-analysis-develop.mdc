---
alwaysApply: true
---

## Code Analysis - Always Check Documentation First

### CRITICAL Rule: Read File Documentation Before Analyzing

**When analyzing code or creating tests, ALWAYS read the documentation at the top of the file first.**

## The Rule

**Before writing tests or analyzing any code file:**
1. Read the TABLE OF CONTENTS or documentation at the top of the file
2. Use this documentation to understand ALL features and scenarios
3. Ensure your tests/analysis covers ALL documented functionality
4. Never assume you know all the features - check the docs!

## Why This Matters

Documentation at the top of files typically contains:
- ✅ Complete feature list with hierarchical organization
- ✅ All scenarios and edge cases to test
- ✅ Proper terminology and naming conventions
- ✅ Feature relationships and dependencies
- ✅ Implementation details and special cases

## Example: attack_handler.py

```python
# ============================================================================
# TABLE OF CONTENTS
# ============================================================================
# 1. HOVER MENU
#   1.2 Display Token Interface
#     1.2.1 Show/hide action buttons using animation when hovering over token
#     1.2.2 Display attack, powers, and maneuvers buttons below token
#     1.2.3 Maintain visibility within expanded hover area (100px buffer)
#   1.3 Manage Resources
#     1.3.1 Display resource panel with animation when hovering over token
# 2. ATTACKS
#   2.1 Convert Attacks from Powers
#     2.1.1 Create attacks from powers when clicking "Convert Powers" button
#     2.1.2 Convert range, close, or perception to attack
#     2.1.3 Convert power to attack for character that has a skill for that attack
#     2.1.4 Convert standard power to attack (damage, affliction, weaken, etc)
#       2.1.4.1 Map English resistance names to French system keys
#       2.1.4.2 Extract target ability from weaken power description
#     2.1.5 Convert linked power to attack
#     2.1.6 Convert power with area of effect to attack
#     2.1.7 Convert power with Attack or Multiattack extras
```

**This documentation tells you:**
- All the features to test (1.2.1, 1.2.2, 1.2.3, etc.)
- The proper hierarchy and organization
- Specific scenarios like "skill-based attack" (2.1.3)
- Sub-features like "Map English resistance names" (2.1.4.1)

## Process

### ✅ CORRECT Approach:
```
1. Read file documentation/TOC
2. Create test structure matching documented features being worked on
3. Verify you haven't missed any scenarios
4. Write tests covering complete functionality
```

### ❌ WRONG Approach:
```
1. Look at some code
2. Guess what features exist
3. Write tests for what you see
4. Miss important scenarios documented at top
```

## Application

**When asked to:**
- "Create tests for this feature / requirement"
- "Analyze this code"
- "Add scaffolding for tests"

**You MUST:**
1. First read the file's TABLE OF CONTENTS or documentation
2. List all relevant behaviors/scenarios from the docs
3. Ensure your work covers everything documented
4. Ask if documentation is unclear or missing

## Real Example

**User asks:** "Add tests for attack conversion"

**Wrong:** Look at code, add tests for damage/affliction/weaken

**Right:** 

code-->
- 2.1.1 Create attacks from powers
   - 2.1.2 Range, close, or perception
   - 2.1.3 Skill-based attacks ← Would have missed!
   - 2.1.4.1 Map English→French ← Would have missed!
   - 2.1.4.2 Extract target ability ← Would have missed!
   - 2.1.5 Linked powers
   - 2.1.6 Area of effect
   - 2.1.7 Attack or Multiattack extras ← Would have missed "Attack"!
   - 2.1.8 Critical extra
   - 2.1.9 Inaccurate flaw
1. User prompt --> Implement Linked powers 
2. Read attack_handler.py TOC (lines 1-60)
3. See code for all requirements (2.1.1 through 2.1.9)
4. Narrow in on Linked (2.1.5)
5. Create test shell(test methods - no implementation) for 2.1.5 Linked powers
6. Implement first test code (or x number if specified)
7. Human feedback
8. Implement code to make test pass
9. Huma feedback
10. Repeat
   

**Result:** Complete test coverage instead of partial!

## This Applies To:

- ✅ Writing tests
- ✅ Code analysis
- ✅ Feature implementation
- ✅ Documentation updates
- ✅ Refactoring
- ✅ Bug investigation

**Always check the docs first. They tell you what the code SHOULD do.**

